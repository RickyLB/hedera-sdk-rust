pub mod services {
    /// An exact date and time. This is the same data structure as the protobuf Timestamp.proto (see the
    /// comments in <https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto>)
    pub struct Timestamp {
        /// Number of complete seconds since the start of the epoch
        #[prost(int64, tag = "1")]
        pub seconds: i64,
        /// Number of nanoseconds since the start of the last second
        #[prost(int32, tag = "2")]
        pub nanos: i32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Timestamp {
        #[inline]
        fn clone(&self) -> Timestamp {
            {
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i32>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Timestamp {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Timestamp {
        #[inline]
        fn eq(&self, other: &Timestamp) -> bool {
            match *other {
                Timestamp {
                    seconds: ref __self_1_0,
                    nanos: ref __self_1_1,
                } => match *self {
                    Timestamp {
                        seconds: ref __self_0_0,
                        nanos: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Timestamp) -> bool {
            match *other {
                Timestamp {
                    seconds: ref __self_1_0,
                    nanos: ref __self_1_1,
                } => match *self {
                    Timestamp {
                        seconds: ref __self_0_0,
                        nanos: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for Timestamp {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.seconds != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.seconds, buf);
            }
            if self.nanos != 0i32 {
                ::prost::encoding::int32::encode(2u32, &self.nanos, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Timestamp";
            match tag {
                1u32 => {
                    let mut value = &mut self.seconds;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "seconds");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.nanos;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "nanos");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.seconds != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.seconds)
            } else {
                0
            } + if self.nanos != 0i32 {
                ::prost::encoding::int32::encoded_len(2u32, &self.nanos)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.seconds = 0i64;
            self.nanos = 0i32;
        }
    }
    impl ::core::default::Default for Timestamp {
        fn default() -> Self {
            Timestamp {
                seconds: 0i64,
                nanos: 0i32,
            }
        }
    }
    impl ::core::fmt::Debug for Timestamp {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Timestamp");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.seconds)
                };
                builder.field("seconds", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.nanos)
                };
                builder.field("nanos", &wrapper)
            };
            builder.finish()
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Timestamp {}
    impl ::core::marker::StructuralEq for Timestamp {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Timestamp {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i32>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for Timestamp {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                Timestamp {
                    seconds: ref __self_0_0,
                    nanos: ref __self_0_1,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state)
                }
            }
        }
    }
    /// An exact date and time,  with a resolution of one second (no nanoseconds).
    pub struct TimestampSeconds {
        /// Number of complete seconds since the start of the epoch
        #[prost(int64, tag = "1")]
        pub seconds: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TimestampSeconds {
        #[inline]
        fn clone(&self) -> TimestampSeconds {
            match *self {
                TimestampSeconds {
                    seconds: ref __self_0_0,
                } => TimestampSeconds {
                    seconds: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TimestampSeconds {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TimestampSeconds {
        #[inline]
        fn eq(&self, other: &TimestampSeconds) -> bool {
            match *other {
                TimestampSeconds {
                    seconds: ref __self_1_0,
                } => match *self {
                    TimestampSeconds {
                        seconds: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TimestampSeconds) -> bool {
            match *other {
                TimestampSeconds {
                    seconds: ref __self_1_0,
                } => match *self {
                    TimestampSeconds {
                        seconds: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for TimestampSeconds {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.seconds != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.seconds, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TimestampSeconds";
            match tag {
                1u32 => {
                    let mut value = &mut self.seconds;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "seconds");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.seconds != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.seconds)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.seconds = 0i64;
        }
    }
    impl ::core::default::Default for TimestampSeconds {
        fn default() -> Self {
            TimestampSeconds { seconds: 0i64 }
        }
    }
    impl ::core::fmt::Debug for TimestampSeconds {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TimestampSeconds");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.seconds)
                };
                builder.field("seconds", &wrapper)
            };
            builder.finish()
        }
    }
    /// Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative
    /// realm number (that number might be reused in other shards). And each account, file, and smart
    /// contract instance within a given realm has a nonnegative number (which might be reused in other
    /// realms).  Every account, file, and smart contract instance is within exactly one realm. So a
    /// FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.
    /// Each realm maintains a single counter for assigning numbers,  so if there is a file with ID
    /// 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
    ///
    /// Everything is partitioned into realms so that each Solidity smart contract can  access everything
    /// in just a single realm, locking all those entities while it's  running, but other smart contracts
    /// could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized
    /// somewhat, even though the  language itself assumes everything is serial.
    pub struct ShardId {
        /// the shard number (nonnegative)
        #[prost(int64, tag = "1")]
        pub shard_num: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ShardId {
        #[inline]
        fn clone(&self) -> ShardId {
            {
                let _: ::core::clone::AssertParamIsClone<i64>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ShardId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ShardId {
        #[inline]
        fn eq(&self, other: &ShardId) -> bool {
            match *other {
                ShardId {
                    shard_num: ref __self_1_0,
                } => match *self {
                    ShardId {
                        shard_num: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ShardId) -> bool {
            match *other {
                ShardId {
                    shard_num: ref __self_1_0,
                } => match *self {
                    ShardId {
                        shard_num: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for ShardId {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.shard_num != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.shard_num, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ShardId";
            match tag {
                1u32 => {
                    let mut value = &mut self.shard_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "shard_num");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.shard_num != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.shard_num)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.shard_num = 0i64;
        }
    }
    impl ::core::default::Default for ShardId {
        fn default() -> Self {
            ShardId { shard_num: 0i64 }
        }
    }
    impl ::core::fmt::Debug for ShardId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ShardId");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.shard_num)
                };
                builder.field("shard_num", &wrapper)
            };
            builder.finish()
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for ShardId {}
    impl ::core::marker::StructuralEq for ShardId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for ShardId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for ShardId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                ShardId {
                    shard_num: ref __self_0_0,
                } => ::core::hash::Hash::hash(&(*__self_0_0), state),
            }
        }
    }
    /// The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and
    /// contract instance belongs to exactly one realm.
    pub struct RealmId {
        /// The shard number (nonnegative)
        #[prost(int64, tag = "1")]
        pub shard_num: i64,
        /// The realm number (nonnegative)
        #[prost(int64, tag = "2")]
        pub realm_num: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for RealmId {
        #[inline]
        fn clone(&self) -> RealmId {
            {
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for RealmId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for RealmId {
        #[inline]
        fn eq(&self, other: &RealmId) -> bool {
            match *other {
                RealmId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                } => match *self {
                    RealmId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &RealmId) -> bool {
            match *other {
                RealmId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                } => match *self {
                    RealmId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for RealmId {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.shard_num != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.shard_num, buf);
            }
            if self.realm_num != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.realm_num, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "RealmId";
            match tag {
                1u32 => {
                    let mut value = &mut self.shard_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "shard_num");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.realm_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "realm_num");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.shard_num != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.shard_num)
            } else {
                0
            } + if self.realm_num != 0i64 {
                ::prost::encoding::int64::encoded_len(2u32, &self.realm_num)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.shard_num = 0i64;
            self.realm_num = 0i64;
        }
    }
    impl ::core::default::Default for RealmId {
        fn default() -> Self {
            RealmId {
                shard_num: 0i64,
                realm_num: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for RealmId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("RealmId");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.shard_num)
                };
                builder.field("shard_num", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.realm_num)
                };
                builder.field("realm_num", &wrapper)
            };
            builder.finish()
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for RealmId {}
    impl ::core::marker::StructuralEq for RealmId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for RealmId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for RealmId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                RealmId {
                    shard_num: ref __self_0_0,
                    realm_num: ref __self_0_1,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state)
                }
            }
        }
    }
    /// The ID for an a cryptocurrency account
    pub struct AccountId {
        /// The shard number (nonnegative)
        #[prost(int64, tag = "1")]
        pub shard_num: i64,
        /// The realm number (nonnegative)
        #[prost(int64, tag = "2")]
        pub realm_num: i64,
        /// The account number unique within its realm which can be either a non-negative integer or an alias public key.
        /// For any AccountID fields in the query response, transaction record or transaction receipt only accountNum will
        /// be populated.
        #[prost(oneof = "account_id::Account", tags = "3, 4")]
        pub account: ::core::option::Option<account_id::Account>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for AccountId {
        #[inline]
        fn clone(&self) -> AccountId {
            match *self {
                AccountId {
                    shard_num: ref __self_0_0,
                    realm_num: ref __self_0_1,
                    account: ref __self_0_2,
                } => AccountId {
                    shard_num: ::core::clone::Clone::clone(&(*__self_0_0)),
                    realm_num: ::core::clone::Clone::clone(&(*__self_0_1)),
                    account: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for AccountId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for AccountId {
        #[inline]
        fn eq(&self, other: &AccountId) -> bool {
            match *other {
                AccountId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    account: ref __self_1_2,
                } => match *self {
                    AccountId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        account: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &AccountId) -> bool {
            match *other {
                AccountId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    account: ref __self_1_2,
                } => match *self {
                    AccountId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        account: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for AccountId {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.shard_num != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.shard_num, buf);
            }
            if self.realm_num != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.realm_num, buf);
            }
            if let Some(ref oneof) = self.account {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "AccountId";
            match tag {
                1u32 => {
                    let mut value = &mut self.shard_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "shard_num");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.realm_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "realm_num");
                            error
                        },
                    )
                }
                3u32 | 4u32 => {
                    let mut value = &mut self.account;
                    account_id::Account::merge(value, tag, wire_type, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "account");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.shard_num != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.shard_num)
            } else {
                0
            } + if self.realm_num != 0i64 {
                ::prost::encoding::int64::encoded_len(2u32, &self.realm_num)
            } else {
                0
            } + self
                .account
                .as_ref()
                .map_or(0, account_id::Account::encoded_len)
        }
        fn clear(&mut self) {
            self.shard_num = 0i64;
            self.realm_num = 0i64;
            self.account = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for AccountId {
        fn default() -> Self {
            AccountId {
                shard_num: 0i64,
                realm_num: 0i64,
                account: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for AccountId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("AccountId");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.shard_num)
                };
                builder.field("shard_num", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.realm_num)
                };
                builder.field("realm_num", &wrapper)
            };
            let builder = {
                let wrapper = &self.account;
                builder.field("account", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for AccountId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for AccountId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<account_id::Account>>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for AccountId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                AccountId {
                    shard_num: ref __self_0_0,
                    realm_num: ref __self_0_1,
                    account: ref __self_0_2,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state)
                }
            }
        }
    }
    /// Nested message and enum types in `AccountID`.
    pub mod account_id {
        /// The account number unique within its realm which can be either a non-negative integer or an alias public key.
        /// For any AccountID fields in the query response, transaction record or transaction receipt only accountNum will
        /// be populated.
        pub enum Account {
            /// A non-negative account number unique within its realm
            #[prost(int64, tag = "3")]
            AccountNum(i64),
            /// The public key bytes to be used as the account's alias. The public key bytes are the result of serializing
            /// a protobuf Key message for any primitive key type. Currently only primitive key bytes are supported as an alias
            /// (ThresholdKey, KeyList, ContractID, and delegatable_contract_id are not supported)
            ///
            /// At most one account can ever have a given alias and it is used for account creation if it
            /// was automatically created using a crypto transfer. It will be null if an account is created normally.
            /// It is immutable once it is set for an account.
            ///
            /// If a transaction auto-creates the account, any further transfers to that alias will simply be deposited
            /// in that account, without creating anything, and with no creation fee being charged.
            #[prost(bytes, tag = "4")]
            Alias(::prost::alloc::vec::Vec<u8>),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Account {
            #[inline]
            fn clone(&self) -> Account {
                match (&*self,) {
                    (&Account::AccountNum(ref __self_0),) => {
                        Account::AccountNum(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Account::Alias(ref __self_0),) => {
                        Account::Alias(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Account {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Account {
            #[inline]
            fn eq(&self, other: &Account) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Account::AccountNum(ref __self_0),
                                &Account::AccountNum(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Account::Alias(ref __self_0), &Account::Alias(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Account) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Account::AccountNum(ref __self_0),
                                &Account::AccountNum(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Account::Alias(ref __self_0), &Account::Alias(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Account {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Account::AccountNum(ref value) => {
                        ::prost::encoding::int64::encode(3u32, &*value, buf);
                    }
                    Account::Alias(ref value) => {
                        ::prost::encoding::bytes::encode(4u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Account>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    3u32 => match field {
                        ::core::option::Option::Some(Account::AccountNum(ref mut value)) => {
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Account::AccountNum(owned_value))
                            })
                        }
                    },
                    4u32 => match field {
                        ::core::option::Option::Some(Account::Alias(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field = ::core::option::Option::Some(Account::Alias(owned_value))
                            })
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Account tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Account::AccountNum(ref value) => {
                        ::prost::encoding::int64::encoded_len(3u32, &*value)
                    }
                    Account::Alias(ref value) => {
                        ::prost::encoding::bytes::encoded_len(4u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Account {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Account::AccountNum(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("AccountNum").field(&wrapper).finish()
                    }
                    Account::Alias(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Alias").field(&wrapper).finish()
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for Account {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Account {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i64>;
                    let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Account {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&Account::AccountNum(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Account::Alias(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                }
            }
        }
    }
    /// The ID for a file
    pub struct FileId {
        /// The shard number (nonnegative)
        #[prost(int64, tag = "1")]
        pub shard_num: i64,
        /// The realm number (nonnegative)
        #[prost(int64, tag = "2")]
        pub realm_num: i64,
        /// A nonnegative File number unique within its realm
        #[prost(int64, tag = "3")]
        pub file_num: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FileId {
        #[inline]
        fn clone(&self) -> FileId {
            {
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FileId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FileId {
        #[inline]
        fn eq(&self, other: &FileId) -> bool {
            match *other {
                FileId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    file_num: ref __self_1_2,
                } => match *self {
                    FileId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        file_num: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FileId) -> bool {
            match *other {
                FileId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    file_num: ref __self_1_2,
                } => match *self {
                    FileId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        file_num: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for FileId {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.shard_num != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.shard_num, buf);
            }
            if self.realm_num != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.realm_num, buf);
            }
            if self.file_num != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.file_num, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FileId";
            match tag {
                1u32 => {
                    let mut value = &mut self.shard_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "shard_num");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.realm_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "realm_num");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.file_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "file_num");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.shard_num != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.shard_num)
            } else {
                0
            } + if self.realm_num != 0i64 {
                ::prost::encoding::int64::encoded_len(2u32, &self.realm_num)
            } else {
                0
            } + if self.file_num != 0i64 {
                ::prost::encoding::int64::encoded_len(3u32, &self.file_num)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.shard_num = 0i64;
            self.realm_num = 0i64;
            self.file_num = 0i64;
        }
    }
    impl ::core::default::Default for FileId {
        fn default() -> Self {
            FileId {
                shard_num: 0i64,
                realm_num: 0i64,
                file_num: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for FileId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FileId");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.shard_num)
                };
                builder.field("shard_num", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.realm_num)
                };
                builder.field("realm_num", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.file_num)
                };
                builder.field("file_num", &wrapper)
            };
            builder.finish()
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for FileId {}
    impl ::core::marker::StructuralEq for FileId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for FileId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for FileId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                FileId {
                    shard_num: ref __self_0_0,
                    realm_num: ref __self_0_1,
                    file_num: ref __self_0_2,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state)
                }
            }
        }
    }
    /// The ID for a smart contract instance
    pub struct ContractId {
        /// The shard number (nonnegative)
        #[prost(int64, tag = "1")]
        pub shard_num: i64,
        /// The realm number (nonnegative)
        #[prost(int64, tag = "2")]
        pub realm_num: i64,
        #[prost(oneof = "contract_id::Contract", tags = "3, 4")]
        pub contract: ::core::option::Option<contract_id::Contract>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractId {
        #[inline]
        fn clone(&self) -> ContractId {
            match *self {
                ContractId {
                    shard_num: ref __self_0_0,
                    realm_num: ref __self_0_1,
                    contract: ref __self_0_2,
                } => ContractId {
                    shard_num: ::core::clone::Clone::clone(&(*__self_0_0)),
                    realm_num: ::core::clone::Clone::clone(&(*__self_0_1)),
                    contract: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractId {
        #[inline]
        fn eq(&self, other: &ContractId) -> bool {
            match *other {
                ContractId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    contract: ref __self_1_2,
                } => match *self {
                    ContractId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        contract: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractId) -> bool {
            match *other {
                ContractId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    contract: ref __self_1_2,
                } => match *self {
                    ContractId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        contract: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ContractId {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.shard_num != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.shard_num, buf);
            }
            if self.realm_num != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.realm_num, buf);
            }
            if let Some(ref oneof) = self.contract {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractId";
            match tag {
                1u32 => {
                    let mut value = &mut self.shard_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "shard_num");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.realm_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "realm_num");
                            error
                        },
                    )
                }
                3u32 | 4u32 => {
                    let mut value = &mut self.contract;
                    contract_id::Contract::merge(value, tag, wire_type, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "contract");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.shard_num != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.shard_num)
            } else {
                0
            } + if self.realm_num != 0i64 {
                ::prost::encoding::int64::encoded_len(2u32, &self.realm_num)
            } else {
                0
            } + self
                .contract
                .as_ref()
                .map_or(0, contract_id::Contract::encoded_len)
        }
        fn clear(&mut self) {
            self.shard_num = 0i64;
            self.realm_num = 0i64;
            self.contract = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ContractId {
        fn default() -> Self {
            ContractId {
                shard_num: 0i64,
                realm_num: 0i64,
                contract: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractId");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.shard_num)
                };
                builder.field("shard_num", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.realm_num)
                };
                builder.field("realm_num", &wrapper)
            };
            let builder = {
                let wrapper = &self.contract;
                builder.field("contract", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for ContractId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for ContractId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<contract_id::Contract>>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for ContractId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                ContractId {
                    shard_num: ref __self_0_0,
                    realm_num: ref __self_0_1,
                    contract: ref __self_0_2,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state)
                }
            }
        }
    }
    /// Nested message and enum types in `ContractID`.
    pub mod contract_id {
        pub enum Contract {
            /// A nonnegative number unique within a given shard and realm
            #[prost(int64, tag = "3")]
            ContractNum(i64),
            /// The 20-byte EVM address of the contract to call.
            ///
            /// Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
            /// This address is as follows:
            ///   <ol>
            ///     <li>The first 4 bytes are the big-endian representation of the shard.</li>
            ///     <li>The next 8 bytes are the big-endian representation of the realm.</li>
            ///     <li>The final 8 bytes are the big-endian representation of the number.</li>
            ///   </ol>  
            ///
            /// Contracts created via CREATE2 have an <b>additional, primary address</b> that is
            /// derived from the <a href="<https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>>
            /// specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
            ///
            /// (Please do note that CREATE2 contracts can also be referenced by the three-part
            /// EVM address described above.)
            #[prost(bytes, tag = "4")]
            EvmAddress(::prost::alloc::vec::Vec<u8>),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Contract {
            #[inline]
            fn clone(&self) -> Contract {
                match (&*self,) {
                    (&Contract::ContractNum(ref __self_0),) => {
                        Contract::ContractNum(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Contract::EvmAddress(ref __self_0),) => {
                        Contract::EvmAddress(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Contract {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Contract {
            #[inline]
            fn eq(&self, other: &Contract) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Contract::ContractNum(ref __self_0),
                                &Contract::ContractNum(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Contract::EvmAddress(ref __self_0),
                                &Contract::EvmAddress(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Contract) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Contract::ContractNum(ref __self_0),
                                &Contract::ContractNum(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Contract::EvmAddress(ref __self_0),
                                &Contract::EvmAddress(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Contract {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Contract::ContractNum(ref value) => {
                        ::prost::encoding::int64::encode(3u32, &*value, buf);
                    }
                    Contract::EvmAddress(ref value) => {
                        ::prost::encoding::bytes::encode(4u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Contract>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    3u32 => match field {
                        ::core::option::Option::Some(Contract::ContractNum(ref mut value)) => {
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Contract::ContractNum(owned_value))
                            })
                        }
                    },
                    4u32 => match field {
                        ::core::option::Option::Some(Contract::EvmAddress(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Contract::EvmAddress(owned_value))
                            })
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Contract tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Contract::ContractNum(ref value) => {
                        ::prost::encoding::int64::encoded_len(3u32, &*value)
                    }
                    Contract::EvmAddress(ref value) => {
                        ::prost::encoding::bytes::encoded_len(4u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Contract {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Contract::ContractNum(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("ContractNum").field(&wrapper).finish()
                    }
                    Contract::EvmAddress(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("EvmAddress").field(&wrapper).finish()
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for Contract {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Contract {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i64>;
                    let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Contract {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&Contract::ContractNum(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Contract::EvmAddress(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                }
            }
        }
    }
    /// The ID for a transaction. This is used for retrieving receipts and records for a transaction, for
    /// appending to a file right after creating it, for instantiating a smart contract with bytecode in
    /// a file just created, and internally by the network for detecting when duplicate transactions are
    /// submitted. A user might get a transaction processed faster by submitting it to N nodes, each with
    /// a different node account, but all with the same TransactionID. Then, the transaction will take
    /// effect when the first of all those nodes submits the transaction and it reaches consensus. The
    /// other transactions will not take effect. So this could make the transaction take effect faster,
    /// if any given node might be slow. However, the full transaction fee is charged for each
    /// transaction, so the total fee is N times as much if the transaction is sent to N nodes.
    ///
    /// Applicable to Scheduled Transactions:
    ///  - The ID of a Scheduled Transaction has transactionValidStart and accountIDs inherited from the
    ///    ScheduleCreate transaction that created it. That is to say that they are equal
    ///  - The scheduled property is true for Scheduled Transactions
    ///  - transactionValidStart, accountID and scheduled properties should be omitted
    pub struct TransactionId {
        /// The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid
        #[prost(message, optional, tag = "1")]
        pub transaction_valid_start: ::core::option::Option<Timestamp>,
        /// The Account ID that paid for this transaction
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
        /// Whether the Transaction is of type Scheduled or no
        #[prost(bool, tag = "3")]
        pub scheduled: bool,
        /// The identifier for an internal transaction that was spawned as part
        /// of handling a user transaction. (These internal transactions share the
        /// transactionValidStart and accountID of the user transaction, so a
        /// nonce is necessary to give them a unique TransactionID.)
        ///
        /// An example is when a "parent" ContractCreate or ContractCall transaction
        /// calls one or more HTS precompiled contracts; each of the "child"
        /// transactions spawned for a precompile has a id with a different nonce.
        #[prost(int32, tag = "4")]
        pub nonce: i32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionId {
        #[inline]
        fn clone(&self) -> TransactionId {
            match *self {
                TransactionId {
                    transaction_valid_start: ref __self_0_0,
                    account_id: ref __self_0_1,
                    scheduled: ref __self_0_2,
                    nonce: ref __self_0_3,
                } => TransactionId {
                    transaction_valid_start: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    scheduled: ::core::clone::Clone::clone(&(*__self_0_2)),
                    nonce: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionId {
        #[inline]
        fn eq(&self, other: &TransactionId) -> bool {
            match *other {
                TransactionId {
                    transaction_valid_start: ref __self_1_0,
                    account_id: ref __self_1_1,
                    scheduled: ref __self_1_2,
                    nonce: ref __self_1_3,
                } => match *self {
                    TransactionId {
                        transaction_valid_start: ref __self_0_0,
                        account_id: ref __self_0_1,
                        scheduled: ref __self_0_2,
                        nonce: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionId) -> bool {
            match *other {
                TransactionId {
                    transaction_valid_start: ref __self_1_0,
                    account_id: ref __self_1_1,
                    scheduled: ref __self_1_2,
                    nonce: ref __self_1_3,
                } => match *self {
                    TransactionId {
                        transaction_valid_start: ref __self_0_0,
                        account_id: ref __self_0_1,
                        scheduled: ref __self_0_2,
                        nonce: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TransactionId {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.transaction_valid_start {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.scheduled != false {
                ::prost::encoding::bool::encode(3u32, &self.scheduled, buf);
            }
            if self.nonce != 0i32 {
                ::prost::encoding::int32::encode(4u32, &self.nonce, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionId";
            match tag {
                1u32 => {
                    let mut value = &mut self.transaction_valid_start;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transaction_valid_start");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.scheduled;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "scheduled");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.nonce;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "nonce");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .transaction_valid_start
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.scheduled != false {
                    ::prost::encoding::bool::encoded_len(3u32, &self.scheduled)
                } else {
                    0
                }
                + if self.nonce != 0i32 {
                    ::prost::encoding::int32::encoded_len(4u32, &self.nonce)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.transaction_valid_start = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
            self.scheduled = false;
            self.nonce = 0i32;
        }
    }
    impl ::core::default::Default for TransactionId {
        fn default() -> Self {
            TransactionId {
                transaction_valid_start: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
                scheduled: false,
                nonce: 0i32,
            }
        }
    }
    impl ::core::fmt::Debug for TransactionId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionId");
            let builder = {
                let wrapper = &self.transaction_valid_start;
                builder.field("transaction_valid_start", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.scheduled)
                };
                builder.field("scheduled", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.nonce)
                };
                builder.field("nonce", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for TransactionId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TransactionId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<Timestamp>>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<AccountId>>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<i32>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for TransactionId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                TransactionId {
                    transaction_valid_start: ref __self_0_0,
                    account_id: ref __self_0_1,
                    scheduled: ref __self_0_2,
                    nonce: ref __self_0_3,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state);
                    ::core::hash::Hash::hash(&(*__self_0_3), state)
                }
            }
        }
    }
    /// An account, and the amount that it sends or receives during a cryptocurrency or token transfer.
    pub struct AccountAmount {
        /// The Account ID that sends/receives cryptocurrency or tokens
        #[prost(message, optional, tag = "1")]
        pub account_id: ::core::option::Option<AccountId>,
        /// The amount of tinybars (for Crypto transfers) or in the lowest
        /// denomination (for Token transfers) that the account sends(negative) or
        /// receives(positive)
        #[prost(sint64, tag = "2")]
        pub amount: i64,
        /// If true then the transfer is expected to be an approved allowance and the
        /// accountID is expected to be the owner. The default is false (omitted).
        #[prost(bool, tag = "3")]
        pub is_approval: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for AccountAmount {
        #[inline]
        fn clone(&self) -> AccountAmount {
            match *self {
                AccountAmount {
                    account_id: ref __self_0_0,
                    amount: ref __self_0_1,
                    is_approval: ref __self_0_2,
                } => AccountAmount {
                    account_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    amount: ::core::clone::Clone::clone(&(*__self_0_1)),
                    is_approval: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for AccountAmount {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for AccountAmount {
        #[inline]
        fn eq(&self, other: &AccountAmount) -> bool {
            match *other {
                AccountAmount {
                    account_id: ref __self_1_0,
                    amount: ref __self_1_1,
                    is_approval: ref __self_1_2,
                } => match *self {
                    AccountAmount {
                        account_id: ref __self_0_0,
                        amount: ref __self_0_1,
                        is_approval: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &AccountAmount) -> bool {
            match *other {
                AccountAmount {
                    account_id: ref __self_1_0,
                    amount: ref __self_1_1,
                    is_approval: ref __self_1_2,
                } => match *self {
                    AccountAmount {
                        account_id: ref __self_0_0,
                        amount: ref __self_0_1,
                        is_approval: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for AccountAmount {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.amount != 0i64 {
                ::prost::encoding::sint64::encode(2u32, &self.amount, buf);
            }
            if self.is_approval != false {
                ::prost::encoding::bool::encode(3u32, &self.is_approval, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "AccountAmount";
            match tag {
                1u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::sint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.is_approval;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "is_approval");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .account_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.amount != 0i64 {
                    ::prost::encoding::sint64::encoded_len(2u32, &self.amount)
                } else {
                    0
                }
                + if self.is_approval != false {
                    ::prost::encoding::bool::encoded_len(3u32, &self.is_approval)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.account_id = ::core::option::Option::None;
            self.amount = 0i64;
            self.is_approval = false;
        }
    }
    impl ::core::default::Default for AccountAmount {
        fn default() -> Self {
            AccountAmount {
                account_id: ::core::default::Default::default(),
                amount: 0i64,
                is_approval: false,
            }
        }
    }
    impl ::core::fmt::Debug for AccountAmount {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("AccountAmount");
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.is_approval)
                };
                builder.field("is_approval", &wrapper)
            };
            builder.finish()
        }
    }
    /// A list of accounts and amounts to transfer out of each account (negative) or into it (positive).
    pub struct TransferList {
        /// Multiple list of AccountAmount pairs, each of which has an account and
        /// an amount to transfer into it (positive) or out of it (negative)
        #[prost(message, repeated, tag = "1")]
        pub account_amounts: ::prost::alloc::vec::Vec<AccountAmount>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransferList {
        #[inline]
        fn clone(&self) -> TransferList {
            match *self {
                TransferList {
                    account_amounts: ref __self_0_0,
                } => TransferList {
                    account_amounts: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransferList {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransferList {
        #[inline]
        fn eq(&self, other: &TransferList) -> bool {
            match *other {
                TransferList {
                    account_amounts: ref __self_1_0,
                } => match *self {
                    TransferList {
                        account_amounts: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransferList) -> bool {
            match *other {
                TransferList {
                    account_amounts: ref __self_1_0,
                } => match *self {
                    TransferList {
                        account_amounts: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for TransferList {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.account_amounts {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransferList";
            match tag {
                1u32 => {
                    let mut value = &mut self.account_amounts;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "account_amounts");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.account_amounts)
        }
        fn clear(&mut self) {
            self.account_amounts.clear();
        }
    }
    impl ::core::default::Default for TransferList {
        fn default() -> Self {
            TransferList {
                account_amounts: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TransferList {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransferList");
            let builder = {
                let wrapper = &self.account_amounts;
                builder.field("account_amounts", &wrapper)
            };
            builder.finish()
        }
    }
    /// A sender account, a receiver account, and the serial number of an NFT of a Token with
    /// NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be the default AccountID instance
    /// (0.0.0) and when burning NFTs, the receiver will be the default AccountID instance.
    pub struct NftTransfer {
        /// The accountID of the sender
        #[prost(message, optional, tag = "1")]
        pub sender_account_id: ::core::option::Option<AccountId>,
        /// The accountID of the receiver
        #[prost(message, optional, tag = "2")]
        pub receiver_account_id: ::core::option::Option<AccountId>,
        /// The serial number of the NFT
        #[prost(int64, tag = "3")]
        pub serial_number: i64,
        /// If true then the transfer is expected to be an approved allowance and the
        /// senderAccountID is expected to be the owner. The default is false (omitted).
        #[prost(bool, tag = "4")]
        pub is_approval: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NftTransfer {
        #[inline]
        fn clone(&self) -> NftTransfer {
            match *self {
                NftTransfer {
                    sender_account_id: ref __self_0_0,
                    receiver_account_id: ref __self_0_1,
                    serial_number: ref __self_0_2,
                    is_approval: ref __self_0_3,
                } => NftTransfer {
                    sender_account_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    receiver_account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    serial_number: ::core::clone::Clone::clone(&(*__self_0_2)),
                    is_approval: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for NftTransfer {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for NftTransfer {
        #[inline]
        fn eq(&self, other: &NftTransfer) -> bool {
            match *other {
                NftTransfer {
                    sender_account_id: ref __self_1_0,
                    receiver_account_id: ref __self_1_1,
                    serial_number: ref __self_1_2,
                    is_approval: ref __self_1_3,
                } => match *self {
                    NftTransfer {
                        sender_account_id: ref __self_0_0,
                        receiver_account_id: ref __self_0_1,
                        serial_number: ref __self_0_2,
                        is_approval: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NftTransfer) -> bool {
            match *other {
                NftTransfer {
                    sender_account_id: ref __self_1_0,
                    receiver_account_id: ref __self_1_1,
                    serial_number: ref __self_1_2,
                    is_approval: ref __self_1_3,
                } => match *self {
                    NftTransfer {
                        sender_account_id: ref __self_0_0,
                        receiver_account_id: ref __self_0_1,
                        serial_number: ref __self_0_2,
                        is_approval: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for NftTransfer {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.sender_account_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.receiver_account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.serial_number != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.serial_number, buf);
            }
            if self.is_approval != false {
                ::prost::encoding::bool::encode(4u32, &self.is_approval, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "NftTransfer";
            match tag {
                1u32 => {
                    let mut value = &mut self.sender_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "sender_account_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.receiver_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "receiver_account_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.serial_number;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "serial_number");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.is_approval;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "is_approval");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .sender_account_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .receiver_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.serial_number != 0i64 {
                    ::prost::encoding::int64::encoded_len(3u32, &self.serial_number)
                } else {
                    0
                }
                + if self.is_approval != false {
                    ::prost::encoding::bool::encoded_len(4u32, &self.is_approval)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.sender_account_id = ::core::option::Option::None;
            self.receiver_account_id = ::core::option::Option::None;
            self.serial_number = 0i64;
            self.is_approval = false;
        }
    }
    impl ::core::default::Default for NftTransfer {
        fn default() -> Self {
            NftTransfer {
                sender_account_id: ::core::default::Default::default(),
                receiver_account_id: ::core::default::Default::default(),
                serial_number: 0i64,
                is_approval: false,
            }
        }
    }
    impl ::core::fmt::Debug for NftTransfer {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NftTransfer");
            let builder = {
                let wrapper = &self.sender_account_id;
                builder.field("sender_account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.receiver_account_id;
                builder.field("receiver_account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.serial_number)
                };
                builder.field("serial_number", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.is_approval)
                };
                builder.field("is_approval", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for NftTransfer {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for NftTransfer {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<AccountId>>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<AccountId>>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for NftTransfer {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                NftTransfer {
                    sender_account_id: ref __self_0_0,
                    receiver_account_id: ref __self_0_1,
                    serial_number: ref __self_0_2,
                    is_approval: ref __self_0_3,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state);
                    ::core::hash::Hash::hash(&(*__self_0_3), state)
                }
            }
        }
    }
    /// A list of token IDs and amounts representing the transferred out (negative) or into (positive)
    /// amounts, represented in the lowest denomination of the token
    pub struct TokenTransferList {
        /// The ID of the token
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
        /// Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which
        /// has an account and amount
        #[prost(message, repeated, tag = "2")]
        pub transfers: ::prost::alloc::vec::Vec<AccountAmount>,
        /// Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of
        /// which has a sender and receiver account, including the serial number of the NFT
        #[prost(message, repeated, tag = "3")]
        pub nft_transfers: ::prost::alloc::vec::Vec<NftTransfer>,
        /// If present, the number of decimals this fungible token type is expected to have. The transfer
        /// will fail with UNEXPECTED_TOKEN_DECIMALS if the actual decimals differ.
        #[prost(message, optional, tag = "4")]
        pub expected_decimals: ::core::option::Option<u32>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenTransferList {
        #[inline]
        fn clone(&self) -> TokenTransferList {
            match *self {
                TokenTransferList {
                    token: ref __self_0_0,
                    transfers: ref __self_0_1,
                    nft_transfers: ref __self_0_2,
                    expected_decimals: ref __self_0_3,
                } => TokenTransferList {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    transfers: ::core::clone::Clone::clone(&(*__self_0_1)),
                    nft_transfers: ::core::clone::Clone::clone(&(*__self_0_2)),
                    expected_decimals: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenTransferList {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenTransferList {
        #[inline]
        fn eq(&self, other: &TokenTransferList) -> bool {
            match *other {
                TokenTransferList {
                    token: ref __self_1_0,
                    transfers: ref __self_1_1,
                    nft_transfers: ref __self_1_2,
                    expected_decimals: ref __self_1_3,
                } => match *self {
                    TokenTransferList {
                        token: ref __self_0_0,
                        transfers: ref __self_0_1,
                        nft_transfers: ref __self_0_2,
                        expected_decimals: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenTransferList) -> bool {
            match *other {
                TokenTransferList {
                    token: ref __self_1_0,
                    transfers: ref __self_1_1,
                    nft_transfers: ref __self_1_2,
                    expected_decimals: ref __self_1_3,
                } => match *self {
                    TokenTransferList {
                        token: ref __self_0_0,
                        transfers: ref __self_0_1,
                        nft_transfers: ref __self_0_2,
                        expected_decimals: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenTransferList {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.transfers {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            for msg in &self.nft_transfers {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.expected_decimals {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenTransferList";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.transfers;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "transfers");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.nft_transfers;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "nft_transfers");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.expected_decimals;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expected_decimals");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.transfers)
                + ::prost::encoding::message::encoded_len_repeated(3u32, &self.nft_transfers)
                + self
                    .expected_decimals
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
            self.transfers.clear();
            self.nft_transfers.clear();
            self.expected_decimals = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenTransferList {
        fn default() -> Self {
            TokenTransferList {
                token: ::core::default::Default::default(),
                transfers: ::core::default::Default::default(),
                nft_transfers: ::core::default::Default::default(),
                expected_decimals: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenTransferList {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenTransferList");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            let builder = {
                let wrapper = &self.transfers;
                builder.field("transfers", &wrapper)
            };
            let builder = {
                let wrapper = &self.nft_transfers;
                builder.field("nft_transfers", &wrapper)
            };
            let builder = {
                let wrapper = &self.expected_decimals;
                builder.field("expected_decimals", &wrapper)
            };
            builder.finish()
        }
    }
    /// A rational number, used to set the amount of a value transfer to collect as a custom fee
    pub struct Fraction {
        /// The rational's numerator
        #[prost(int64, tag = "1")]
        pub numerator: i64,
        /// The rational's denominator; a zero value will result in FRACTION_DIVIDES_BY_ZERO
        #[prost(int64, tag = "2")]
        pub denominator: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Fraction {
        #[inline]
        fn clone(&self) -> Fraction {
            {
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Fraction {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Fraction {
        #[inline]
        fn eq(&self, other: &Fraction) -> bool {
            match *other {
                Fraction {
                    numerator: ref __self_1_0,
                    denominator: ref __self_1_1,
                } => match *self {
                    Fraction {
                        numerator: ref __self_0_0,
                        denominator: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Fraction) -> bool {
            match *other {
                Fraction {
                    numerator: ref __self_1_0,
                    denominator: ref __self_1_1,
                } => match *self {
                    Fraction {
                        numerator: ref __self_0_0,
                        denominator: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for Fraction {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.numerator != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.numerator, buf);
            }
            if self.denominator != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.denominator, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Fraction";
            match tag {
                1u32 => {
                    let mut value = &mut self.numerator;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "numerator");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.denominator;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "denominator");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.numerator != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.numerator)
            } else {
                0
            } + if self.denominator != 0i64 {
                ::prost::encoding::int64::encoded_len(2u32, &self.denominator)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.numerator = 0i64;
            self.denominator = 0i64;
        }
    }
    impl ::core::default::Default for Fraction {
        fn default() -> Self {
            Fraction {
                numerator: 0i64,
                denominator: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for Fraction {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Fraction");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.numerator)
                };
                builder.field("numerator", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.denominator)
                };
                builder.field("denominator", &wrapper)
            };
            builder.finish()
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Fraction {}
    impl ::core::marker::StructuralEq for Fraction {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Fraction {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for Fraction {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                Fraction {
                    numerator: ref __self_0_0,
                    denominator: ref __self_0_1,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state)
                }
            }
        }
    }
    /// Unique identifier for a topic (used by the consensus service)
    pub struct TopicId {
        /// The shard number (nonnegative)
        #[prost(int64, tag = "1")]
        pub shard_num: i64,
        /// The realm number (nonnegative)
        #[prost(int64, tag = "2")]
        pub realm_num: i64,
        /// Unique topic identifier within a realm (nonnegative).
        #[prost(int64, tag = "3")]
        pub topic_num: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TopicId {
        #[inline]
        fn clone(&self) -> TopicId {
            {
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TopicId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TopicId {
        #[inline]
        fn eq(&self, other: &TopicId) -> bool {
            match *other {
                TopicId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    topic_num: ref __self_1_2,
                } => match *self {
                    TopicId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        topic_num: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TopicId) -> bool {
            match *other {
                TopicId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    topic_num: ref __self_1_2,
                } => match *self {
                    TopicId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        topic_num: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TopicId {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.shard_num != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.shard_num, buf);
            }
            if self.realm_num != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.realm_num, buf);
            }
            if self.topic_num != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.topic_num, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TopicId";
            match tag {
                1u32 => {
                    let mut value = &mut self.shard_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "shard_num");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.realm_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "realm_num");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.topic_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "topic_num");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.shard_num != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.shard_num)
            } else {
                0
            } + if self.realm_num != 0i64 {
                ::prost::encoding::int64::encoded_len(2u32, &self.realm_num)
            } else {
                0
            } + if self.topic_num != 0i64 {
                ::prost::encoding::int64::encoded_len(3u32, &self.topic_num)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.shard_num = 0i64;
            self.realm_num = 0i64;
            self.topic_num = 0i64;
        }
    }
    impl ::core::default::Default for TopicId {
        fn default() -> Self {
            TopicId {
                shard_num: 0i64,
                realm_num: 0i64,
                topic_num: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for TopicId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TopicId");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.shard_num)
                };
                builder.field("shard_num", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.realm_num)
                };
                builder.field("realm_num", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.topic_num)
                };
                builder.field("topic_num", &wrapper)
            };
            builder.finish()
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TopicId {}
    impl ::core::marker::StructuralEq for TopicId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TopicId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for TopicId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                TopicId {
                    shard_num: ref __self_0_0,
                    realm_num: ref __self_0_1,
                    topic_num: ref __self_0_2,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state)
                }
            }
        }
    }
    /// Unique identifier for a token
    pub struct TokenId {
        /// A nonnegative shard number
        #[prost(int64, tag = "1")]
        pub shard_num: i64,
        /// A nonnegative realm number
        #[prost(int64, tag = "2")]
        pub realm_num: i64,
        /// A nonnegative token number
        #[prost(int64, tag = "3")]
        pub token_num: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenId {
        #[inline]
        fn clone(&self) -> TokenId {
            {
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenId {
        #[inline]
        fn eq(&self, other: &TokenId) -> bool {
            match *other {
                TokenId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    token_num: ref __self_1_2,
                } => match *self {
                    TokenId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        token_num: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenId) -> bool {
            match *other {
                TokenId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    token_num: ref __self_1_2,
                } => match *self {
                    TokenId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        token_num: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenId {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.shard_num != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.shard_num, buf);
            }
            if self.realm_num != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.realm_num, buf);
            }
            if self.token_num != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.token_num, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenId";
            match tag {
                1u32 => {
                    let mut value = &mut self.shard_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "shard_num");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.realm_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "realm_num");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.token_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "token_num");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.shard_num != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.shard_num)
            } else {
                0
            } + if self.realm_num != 0i64 {
                ::prost::encoding::int64::encoded_len(2u32, &self.realm_num)
            } else {
                0
            } + if self.token_num != 0i64 {
                ::prost::encoding::int64::encoded_len(3u32, &self.token_num)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.shard_num = 0i64;
            self.realm_num = 0i64;
            self.token_num = 0i64;
        }
    }
    impl ::core::default::Default for TokenId {
        fn default() -> Self {
            TokenId {
                shard_num: 0i64,
                realm_num: 0i64,
                token_num: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for TokenId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenId");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.shard_num)
                };
                builder.field("shard_num", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.realm_num)
                };
                builder.field("realm_num", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.token_num)
                };
                builder.field("token_num", &wrapper)
            };
            builder.finish()
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TokenId {}
    impl ::core::marker::StructuralEq for TokenId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for TokenId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                TokenId {
                    shard_num: ref __self_0_0,
                    realm_num: ref __self_0_1,
                    token_num: ref __self_0_2,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state)
                }
            }
        }
    }
    /// Unique identifier for a Schedule
    pub struct ScheduleId {
        /// A nonnegative shard number
        #[prost(int64, tag = "1")]
        pub shard_num: i64,
        /// A nonnegative realm number
        #[prost(int64, tag = "2")]
        pub realm_num: i64,
        /// A nonnegative schedule number
        #[prost(int64, tag = "3")]
        pub schedule_num: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ScheduleId {
        #[inline]
        fn clone(&self) -> ScheduleId {
            {
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ScheduleId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ScheduleId {
        #[inline]
        fn eq(&self, other: &ScheduleId) -> bool {
            match *other {
                ScheduleId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    schedule_num: ref __self_1_2,
                } => match *self {
                    ScheduleId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        schedule_num: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ScheduleId) -> bool {
            match *other {
                ScheduleId {
                    shard_num: ref __self_1_0,
                    realm_num: ref __self_1_1,
                    schedule_num: ref __self_1_2,
                } => match *self {
                    ScheduleId {
                        shard_num: ref __self_0_0,
                        realm_num: ref __self_0_1,
                        schedule_num: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ScheduleId {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.shard_num != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.shard_num, buf);
            }
            if self.realm_num != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.realm_num, buf);
            }
            if self.schedule_num != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.schedule_num, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ScheduleId";
            match tag {
                1u32 => {
                    let mut value = &mut self.shard_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "shard_num");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.realm_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "realm_num");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.schedule_num;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "schedule_num");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.shard_num != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.shard_num)
            } else {
                0
            } + if self.realm_num != 0i64 {
                ::prost::encoding::int64::encoded_len(2u32, &self.realm_num)
            } else {
                0
            } + if self.schedule_num != 0i64 {
                ::prost::encoding::int64::encoded_len(3u32, &self.schedule_num)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.shard_num = 0i64;
            self.realm_num = 0i64;
            self.schedule_num = 0i64;
        }
    }
    impl ::core::default::Default for ScheduleId {
        fn default() -> Self {
            ScheduleId {
                shard_num: 0i64,
                realm_num: 0i64,
                schedule_num: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for ScheduleId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ScheduleId");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.shard_num)
                };
                builder.field("shard_num", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.realm_num)
                };
                builder.field("realm_num", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.schedule_num)
                };
                builder.field("schedule_num", &wrapper)
            };
            builder.finish()
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for ScheduleId {}
    impl ::core::marker::StructuralEq for ScheduleId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for ScheduleId {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for ScheduleId {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                ScheduleId {
                    shard_num: ref __self_0_0,
                    realm_num: ref __self_0_1,
                    schedule_num: ref __self_0_2,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state)
                }
            }
        }
    }
    /// A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where
    /// in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call
    /// these public keys <b>primitive keys</b>.
    ///
    /// If an account has primitive key associated to it, then the corresponding private key must sign
    /// any transaction to transfer cryptocurrency out of it.
    ///
    /// A Key can also be the ID of a smart contract instance, which is then authorized to perform any
    /// precompiled contract action that requires this key to sign.
    ///
    /// Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID
    /// will actually create a cryptographic signature. It only means that when the contract calls a
    /// precompiled contract, the resulting "child transaction" will be authorized to perform any action
    /// controlled by the Key.
    ///
    /// A Key can be a "threshold key", which means a list of M keys, any N of which must sign in order
    /// for the threshold signature to be considered valid. The keys within a threshold signature may
    /// themselves be threshold signatures, to allow complex signature requirements.
    ///
    /// A Key can be a "key list" where all keys in the list must sign unless specified otherwise in the
    /// documentation for a specific transaction type (e.g.  FileDeleteTransactionBody).  Their use is
    /// dependent on context. For example, a Hedera file is created with a list of keys, where all of
    /// them must sign a transaction to create or modify the file, but only one of them is needed to sign
    /// a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold
    /// key, and sometimes acts as an M-of-M threshold key.  A key list is always an M-of-M, unless
    /// specified otherwise in documentation. A key list can have nested key lists or threshold keys.
    /// Nested key lists are always M-of-M. A key list can have repeated primitive public keys, but all
    /// repeated keys are only required to sign once.
    ///
    /// A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual
    /// recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive
    /// keys has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive
    /// keys has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels:
    /// Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.
    ///
    /// Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys.
    pub struct Key {
        #[prost(oneof = "key::Key", tags = "1, 2, 3, 4, 5, 6, 7, 8")]
        pub key: ::core::option::Option<key::Key>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Key {
        #[inline]
        fn clone(&self) -> Key {
            match *self {
                Key {
                    key: ref __self_0_0,
                } => Key {
                    key: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Key {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Key {
        #[inline]
        fn eq(&self, other: &Key) -> bool {
            match *other {
                Key {
                    key: ref __self_1_0,
                } => match *self {
                    Key {
                        key: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Key) -> bool {
            match *other {
                Key {
                    key: ref __self_1_0,
                } => match *self {
                    Key {
                        key: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for Key {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.key {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Key";
            match tag {
                1u32 | 2u32 | 3u32 | 4u32 | 5u32 | 6u32 | 7u32 | 8u32 => {
                    let mut value = &mut self.key;
                    key::Key::merge(value, tag, wire_type, buf, ctx).map_err(|mut error| {
                        error.push(STRUCT_NAME, "key");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.key.as_ref().map_or(0, key::Key::encoded_len)
        }
        fn clear(&mut self) {
            self.key = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for Key {
        fn default() -> Self {
            Key {
                key: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for Key {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Key");
            let builder = {
                let wrapper = &self.key;
                builder.field("key", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for Key {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Key {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<key::Key>>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for Key {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                Key {
                    key: ref __self_0_0,
                } => ::core::hash::Hash::hash(&(*__self_0_0), state),
            }
        }
    }
    /// Nested message and enum types in `Key`.
    pub mod key {
        pub enum Key {
            /// smart contract instance that is authorized as if it had signed with a key
            #[prost(message, tag = "1")]
            ContractId(super::ContractId),
            /// Ed25519 public key bytes
            #[prost(bytes, tag = "2")]
            Ed25519(::prost::alloc::vec::Vec<u8>),
            /// (NOT SUPPORTED) RSA-3072 public key bytes
            #[prost(bytes, tag = "3")]
            Rsa3072(::prost::alloc::vec::Vec<u8>),
            /// (NOT SUPPORTED) ECDSA with the p-384 curve public key bytes
            #[prost(bytes, tag = "4")]
            Ecdsa384(::prost::alloc::vec::Vec<u8>),
            /// a threshold N followed by a list of M keys, any N of which are required to form a valid
            /// signature
            #[prost(message, tag = "5")]
            ThresholdKey(super::ThresholdKey),
            /// A list of Keys of the Key type.
            #[prost(message, tag = "6")]
            KeyList(super::KeyList),
            /// Compressed ECDSA(secp256k1) public key bytes
            #[prost(bytes, tag = "7")]
            EcdsaSecp256k1(::prost::alloc::vec::Vec<u8>),
            /// A smart contract that, if the recipient of the active message frame, should be treated
            /// as having signed. (Note this does not mean the <i>code being executed in the frame</i>
            /// will belong to the given contract, since it could be running another contract's code via
            /// <tt>delegatecall</tt>. So setting this key is a more permissive version of setting the
            /// contractID key, which also requires the code in the active message frame belong to the
            /// the contract with the given id.)
            #[prost(message, tag = "8")]
            DelegatableContractId(super::ContractId),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Key {
            #[inline]
            fn clone(&self) -> Key {
                match (&*self,) {
                    (&Key::ContractId(ref __self_0),) => {
                        Key::ContractId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Key::Ed25519(ref __self_0),) => {
                        Key::Ed25519(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Key::Rsa3072(ref __self_0),) => {
                        Key::Rsa3072(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Key::Ecdsa384(ref __self_0),) => {
                        Key::Ecdsa384(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Key::ThresholdKey(ref __self_0),) => {
                        Key::ThresholdKey(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Key::KeyList(ref __self_0),) => {
                        Key::KeyList(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Key::EcdsaSecp256k1(ref __self_0),) => {
                        Key::EcdsaSecp256k1(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Key::DelegatableContractId(ref __self_0),) => {
                        Key::DelegatableContractId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Key {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Key {
            #[inline]
            fn eq(&self, other: &Key) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Key::ContractId(ref __self_0), &Key::ContractId(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Key::Ed25519(ref __self_0), &Key::Ed25519(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Key::Rsa3072(ref __self_0), &Key::Rsa3072(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Key::Ecdsa384(ref __self_0), &Key::Ecdsa384(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Key::ThresholdKey(ref __self_0),
                                &Key::ThresholdKey(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Key::KeyList(ref __self_0), &Key::KeyList(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Key::EcdsaSecp256k1(ref __self_0),
                                &Key::EcdsaSecp256k1(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Key::DelegatableContractId(ref __self_0),
                                &Key::DelegatableContractId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Key) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Key::ContractId(ref __self_0), &Key::ContractId(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Key::Ed25519(ref __self_0), &Key::Ed25519(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Key::Rsa3072(ref __self_0), &Key::Rsa3072(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Key::Ecdsa384(ref __self_0), &Key::Ecdsa384(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Key::ThresholdKey(ref __self_0),
                                &Key::ThresholdKey(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Key::KeyList(ref __self_0), &Key::KeyList(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Key::EcdsaSecp256k1(ref __self_0),
                                &Key::EcdsaSecp256k1(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Key::DelegatableContractId(ref __self_0),
                                &Key::DelegatableContractId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Key {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Key::ContractId(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                    Key::Ed25519(ref value) => {
                        ::prost::encoding::bytes::encode(2u32, &*value, buf);
                    }
                    Key::Rsa3072(ref value) => {
                        ::prost::encoding::bytes::encode(3u32, &*value, buf);
                    }
                    Key::Ecdsa384(ref value) => {
                        ::prost::encoding::bytes::encode(4u32, &*value, buf);
                    }
                    Key::ThresholdKey(ref value) => {
                        ::prost::encoding::message::encode(5u32, &*value, buf);
                    }
                    Key::KeyList(ref value) => {
                        ::prost::encoding::message::encode(6u32, &*value, buf);
                    }
                    Key::EcdsaSecp256k1(ref value) => {
                        ::prost::encoding::bytes::encode(7u32, &*value, buf);
                    }
                    Key::DelegatableContractId(ref value) => {
                        ::prost::encoding::message::encode(8u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Key>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => match field {
                        ::core::option::Option::Some(Key::ContractId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Key::ContractId(owned_value))
                                },
                            )
                        }
                    },
                    2u32 => match field {
                        ::core::option::Option::Some(Key::Ed25519(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field = ::core::option::Option::Some(Key::Ed25519(owned_value))
                            })
                        }
                    },
                    3u32 => match field {
                        ::core::option::Option::Some(Key::Rsa3072(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field = ::core::option::Option::Some(Key::Rsa3072(owned_value))
                            })
                        }
                    },
                    4u32 => match field {
                        ::core::option::Option::Some(Key::Ecdsa384(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field = ::core::option::Option::Some(Key::Ecdsa384(owned_value))
                            })
                        }
                    },
                    5u32 => match field {
                        ::core::option::Option::Some(Key::ThresholdKey(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Key::ThresholdKey(owned_value))
                                },
                            )
                        }
                    },
                    6u32 => match field {
                        ::core::option::Option::Some(Key::KeyList(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Key::KeyList(owned_value))
                                },
                            )
                        }
                    },
                    7u32 => match field {
                        ::core::option::Option::Some(Key::EcdsaSecp256k1(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Key::EcdsaSecp256k1(owned_value))
                            })
                        }
                    },
                    8u32 => match field {
                        ::core::option::Option::Some(Key::DelegatableContractId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Key::DelegatableContractId(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Key tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Key::ContractId(ref value) => {
                        ::prost::encoding::message::encoded_len(1u32, &*value)
                    }
                    Key::Ed25519(ref value) => ::prost::encoding::bytes::encoded_len(2u32, &*value),
                    Key::Rsa3072(ref value) => ::prost::encoding::bytes::encoded_len(3u32, &*value),
                    Key::Ecdsa384(ref value) => {
                        ::prost::encoding::bytes::encoded_len(4u32, &*value)
                    }
                    Key::ThresholdKey(ref value) => {
                        ::prost::encoding::message::encoded_len(5u32, &*value)
                    }
                    Key::KeyList(ref value) => {
                        ::prost::encoding::message::encoded_len(6u32, &*value)
                    }
                    Key::EcdsaSecp256k1(ref value) => {
                        ::prost::encoding::bytes::encoded_len(7u32, &*value)
                    }
                    Key::DelegatableContractId(ref value) => {
                        ::prost::encoding::message::encoded_len(8u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Key {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Key::ContractId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractId").field(&wrapper).finish()
                    }
                    Key::Ed25519(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Ed25519").field(&wrapper).finish()
                    }
                    Key::Rsa3072(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Rsa3072").field(&wrapper).finish()
                    }
                    Key::Ecdsa384(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Ecdsa384").field(&wrapper).finish()
                    }
                    Key::ThresholdKey(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ThresholdKey").field(&wrapper).finish()
                    }
                    Key::KeyList(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("KeyList").field(&wrapper).finish()
                    }
                    Key::EcdsaSecp256k1(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("EcdsaSecp256k1").field(&wrapper).finish()
                    }
                    Key::DelegatableContractId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("DelegatableContractId")
                            .field(&wrapper)
                            .finish()
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for Key {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Key {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<super::ContractId>;
                    let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                    let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                    let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                    let _: ::core::cmp::AssertParamIsEq<super::ThresholdKey>;
                    let _: ::core::cmp::AssertParamIsEq<super::KeyList>;
                    let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                    let _: ::core::cmp::AssertParamIsEq<super::ContractId>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Key {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&Key::ContractId(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Key::Ed25519(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Key::Rsa3072(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Key::Ecdsa384(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Key::ThresholdKey(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Key::KeyList(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Key::EcdsaSecp256k1(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Key::DelegatableContractId(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                }
            }
        }
    }
    /// A set of public keys that are used together to form a threshold signature.  If the threshold is N
    /// and there are M keys, then this is an N of M threshold signature. If an account is associated
    /// with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list
    /// of M signatures, where at most M-N of them are blank, and the other at least N of them are valid
    /// signatures corresponding to at least N of the public keys listed here.
    pub struct ThresholdKey {
        /// A valid signature set must have at least this many signatures
        #[prost(uint32, tag = "1")]
        pub threshold: u32,
        /// List of all the keys that can sign
        #[prost(message, optional, tag = "2")]
        pub keys: ::core::option::Option<KeyList>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ThresholdKey {
        #[inline]
        fn clone(&self) -> ThresholdKey {
            match *self {
                ThresholdKey {
                    threshold: ref __self_0_0,
                    keys: ref __self_0_1,
                } => ThresholdKey {
                    threshold: ::core::clone::Clone::clone(&(*__self_0_0)),
                    keys: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ThresholdKey {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ThresholdKey {
        #[inline]
        fn eq(&self, other: &ThresholdKey) -> bool {
            match *other {
                ThresholdKey {
                    threshold: ref __self_1_0,
                    keys: ref __self_1_1,
                } => match *self {
                    ThresholdKey {
                        threshold: ref __self_0_0,
                        keys: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ThresholdKey) -> bool {
            match *other {
                ThresholdKey {
                    threshold: ref __self_1_0,
                    keys: ref __self_1_1,
                } => match *self {
                    ThresholdKey {
                        threshold: ref __self_0_0,
                        keys: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ThresholdKey {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.threshold != 0u32 {
                ::prost::encoding::uint32::encode(1u32, &self.threshold, buf);
            }
            if let Some(ref msg) = self.keys {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ThresholdKey";
            match tag {
                1u32 => {
                    let mut value = &mut self.threshold;
                    ::prost::encoding::uint32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "threshold");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.keys;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "keys");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.threshold != 0u32 {
                ::prost::encoding::uint32::encoded_len(1u32, &self.threshold)
            } else {
                0
            } + self
                .keys
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.threshold = 0u32;
            self.keys = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ThresholdKey {
        fn default() -> Self {
            ThresholdKey {
                threshold: 0u32,
                keys: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ThresholdKey {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ThresholdKey");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.threshold)
                };
                builder.field("threshold", &wrapper)
            };
            let builder = {
                let wrapper = &self.keys;
                builder.field("keys", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for ThresholdKey {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for ThresholdKey {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<u32>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<KeyList>>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for ThresholdKey {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                ThresholdKey {
                    threshold: ref __self_0_0,
                    keys: ref __self_0_1,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state)
                }
            }
        }
    }
    /// A list of keys that requires all keys (M-of-M) to sign unless otherwise specified in
    /// documentation. A KeyList may contain repeated keys, but all repeated keys are only required to
    /// sign once.
    pub struct KeyList {
        /// list of keys
        #[prost(message, repeated, tag = "1")]
        pub keys: ::prost::alloc::vec::Vec<Key>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for KeyList {
        #[inline]
        fn clone(&self) -> KeyList {
            match *self {
                KeyList {
                    keys: ref __self_0_0,
                } => KeyList {
                    keys: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for KeyList {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for KeyList {
        #[inline]
        fn eq(&self, other: &KeyList) -> bool {
            match *other {
                KeyList {
                    keys: ref __self_1_0,
                } => match *self {
                    KeyList {
                        keys: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &KeyList) -> bool {
            match *other {
                KeyList {
                    keys: ref __self_1_0,
                } => match *self {
                    KeyList {
                        keys: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for KeyList {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.keys {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "KeyList";
            match tag {
                1u32 => {
                    let mut value = &mut self.keys;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "keys");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.keys)
        }
        fn clear(&mut self) {
            self.keys.clear();
        }
    }
    impl ::core::default::Default for KeyList {
        fn default() -> Self {
            KeyList {
                keys: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for KeyList {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("KeyList");
            let builder = {
                let wrapper = &self.keys;
                builder.field("keys", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for KeyList {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for KeyList {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<Key>>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for KeyList {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                KeyList {
                    keys: ref __self_0_0,
                } => ::core::hash::Hash::hash(&(*__self_0_0), state),
            }
        }
    }
    /// This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
    /// here only for historical reasons.
    ///
    /// Please use the SignaturePair and SignatureMap messages.
    pub struct Signature {
        #[prost(oneof = "signature::Signature", tags = "1, 2, 3, 4, 5, 6")]
        pub signature: ::core::option::Option<signature::Signature>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Signature {
        #[inline]
        fn clone(&self) -> Signature {
            match *self {
                Signature {
                    signature: ref __self_0_0,
                } => Signature {
                    signature: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Signature {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Signature {
        #[inline]
        fn eq(&self, other: &Signature) -> bool {
            match *other {
                Signature {
                    signature: ref __self_1_0,
                } => match *self {
                    Signature {
                        signature: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Signature) -> bool {
            match *other {
                Signature {
                    signature: ref __self_1_0,
                } => match *self {
                    Signature {
                        signature: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for Signature {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.signature {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Signature";
            match tag {
                1u32 | 2u32 | 3u32 | 4u32 | 5u32 | 6u32 => {
                    let mut value = &mut self.signature;
                    signature::Signature::merge(value, tag, wire_type, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "signature");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .signature
                .as_ref()
                .map_or(0, signature::Signature::encoded_len)
        }
        fn clear(&mut self) {
            self.signature = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for Signature {
        fn default() -> Self {
            Signature {
                signature: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for Signature {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Signature");
            let builder = {
                let wrapper = &self.signature;
                builder.field("signature", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `Signature`.
    pub mod signature {
        pub enum Signature {
            /// smart contract virtual signature (always length zero)
            #[prost(bytes, tag = "1")]
            Contract(::prost::alloc::vec::Vec<u8>),
            /// ed25519 signature bytes
            #[prost(bytes, tag = "2")]
            Ed25519(::prost::alloc::vec::Vec<u8>),
            /// RSA-3072 signature bytes
            #[prost(bytes, tag = "3")]
            Rsa3072(::prost::alloc::vec::Vec<u8>),
            /// ECDSA p-384 signature bytes
            #[prost(bytes, tag = "4")]
            Ecdsa384(::prost::alloc::vec::Vec<u8>),
            /// A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M
            /// signatures, at least N of which are non-null.
            #[prost(message, tag = "5")]
            ThresholdSignature(super::ThresholdSignature),
            /// A list of M signatures, each corresponding to a Key in a KeyList of the same length.
            #[prost(message, tag = "6")]
            SignatureList(super::SignatureList),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Signature {
            #[inline]
            fn clone(&self) -> Signature {
                match (&*self,) {
                    (&Signature::Contract(ref __self_0),) => {
                        Signature::Contract(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Signature::Ed25519(ref __self_0),) => {
                        Signature::Ed25519(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Signature::Rsa3072(ref __self_0),) => {
                        Signature::Rsa3072(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Signature::Ecdsa384(ref __self_0),) => {
                        Signature::Ecdsa384(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Signature::ThresholdSignature(ref __self_0),) => {
                        Signature::ThresholdSignature(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Signature::SignatureList(ref __self_0),) => {
                        Signature::SignatureList(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Signature {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Signature {
            #[inline]
            fn eq(&self, other: &Signature) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Signature::Contract(ref __self_0),
                                &Signature::Contract(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Signature::Ed25519(ref __self_0),
                                &Signature::Ed25519(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Signature::Rsa3072(ref __self_0),
                                &Signature::Rsa3072(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Signature::Ecdsa384(ref __self_0),
                                &Signature::Ecdsa384(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Signature::ThresholdSignature(ref __self_0),
                                &Signature::ThresholdSignature(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Signature::SignatureList(ref __self_0),
                                &Signature::SignatureList(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Signature) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Signature::Contract(ref __self_0),
                                &Signature::Contract(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Signature::Ed25519(ref __self_0),
                                &Signature::Ed25519(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Signature::Rsa3072(ref __self_0),
                                &Signature::Rsa3072(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Signature::Ecdsa384(ref __self_0),
                                &Signature::Ecdsa384(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Signature::ThresholdSignature(ref __self_0),
                                &Signature::ThresholdSignature(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Signature::SignatureList(ref __self_0),
                                &Signature::SignatureList(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Signature {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Signature::Contract(ref value) => {
                        ::prost::encoding::bytes::encode(1u32, &*value, buf);
                    }
                    Signature::Ed25519(ref value) => {
                        ::prost::encoding::bytes::encode(2u32, &*value, buf);
                    }
                    Signature::Rsa3072(ref value) => {
                        ::prost::encoding::bytes::encode(3u32, &*value, buf);
                    }
                    Signature::Ecdsa384(ref value) => {
                        ::prost::encoding::bytes::encode(4u32, &*value, buf);
                    }
                    Signature::ThresholdSignature(ref value) => {
                        ::prost::encoding::message::encode(5u32, &*value, buf);
                    }
                    Signature::SignatureList(ref value) => {
                        ::prost::encoding::message::encode(6u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Signature>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => match field {
                        ::core::option::Option::Some(Signature::Contract(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Signature::Contract(owned_value))
                            })
                        }
                    },
                    2u32 => match field {
                        ::core::option::Option::Some(Signature::Ed25519(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Signature::Ed25519(owned_value))
                            })
                        }
                    },
                    3u32 => match field {
                        ::core::option::Option::Some(Signature::Rsa3072(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Signature::Rsa3072(owned_value))
                            })
                        }
                    },
                    4u32 => match field {
                        ::core::option::Option::Some(Signature::Ecdsa384(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Signature::Ecdsa384(owned_value))
                            })
                        }
                    },
                    5u32 => match field {
                        ::core::option::Option::Some(Signature::ThresholdSignature(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Signature::ThresholdSignature(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    6u32 => match field {
                        ::core::option::Option::Some(Signature::SignatureList(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Signature::SignatureList(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Signature tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Signature::Contract(ref value) => {
                        ::prost::encoding::bytes::encoded_len(1u32, &*value)
                    }
                    Signature::Ed25519(ref value) => {
                        ::prost::encoding::bytes::encoded_len(2u32, &*value)
                    }
                    Signature::Rsa3072(ref value) => {
                        ::prost::encoding::bytes::encoded_len(3u32, &*value)
                    }
                    Signature::Ecdsa384(ref value) => {
                        ::prost::encoding::bytes::encoded_len(4u32, &*value)
                    }
                    Signature::ThresholdSignature(ref value) => {
                        ::prost::encoding::message::encoded_len(5u32, &*value)
                    }
                    Signature::SignatureList(ref value) => {
                        ::prost::encoding::message::encoded_len(6u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Signature {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Signature::Contract(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Contract").field(&wrapper).finish()
                    }
                    Signature::Ed25519(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Ed25519").field(&wrapper).finish()
                    }
                    Signature::Rsa3072(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Rsa3072").field(&wrapper).finish()
                    }
                    Signature::Ecdsa384(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Ecdsa384").field(&wrapper).finish()
                    }
                    Signature::ThresholdSignature(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ThresholdSignature").field(&wrapper).finish()
                    }
                    Signature::SignatureList(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("SignatureList").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
    /// here only for historical reasons.
    ///
    /// Please use the SignaturePair and SignatureMap messages.
    pub struct ThresholdSignature {
        /// for an N-of-M threshold key, this is a list of M signatures, at least N of which must be
        /// non-null
        #[prost(message, optional, tag = "2")]
        pub sigs: ::core::option::Option<SignatureList>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ThresholdSignature {
        #[inline]
        fn clone(&self) -> ThresholdSignature {
            match *self {
                ThresholdSignature {
                    sigs: ref __self_0_0,
                } => ThresholdSignature {
                    sigs: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ThresholdSignature {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ThresholdSignature {
        #[inline]
        fn eq(&self, other: &ThresholdSignature) -> bool {
            match *other {
                ThresholdSignature {
                    sigs: ref __self_1_0,
                } => match *self {
                    ThresholdSignature {
                        sigs: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ThresholdSignature) -> bool {
            match *other {
                ThresholdSignature {
                    sigs: ref __self_1_0,
                } => match *self {
                    ThresholdSignature {
                        sigs: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for ThresholdSignature {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.sigs {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ThresholdSignature";
            match tag {
                2u32 => {
                    let mut value = &mut self.sigs;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "sigs");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .sigs
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.sigs = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ThresholdSignature {
        fn default() -> Self {
            ThresholdSignature {
                sigs: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ThresholdSignature {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ThresholdSignature");
            let builder = {
                let wrapper = &self.sigs;
                builder.field("sigs", &wrapper)
            };
            builder.finish()
        }
    }
    /// This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
    /// here only for historical reasons.
    ///
    /// Please use the SignaturePair and SignatureMap messages.
    pub struct SignatureList {
        /// each signature corresponds to a Key in the KeyList
        #[prost(message, repeated, tag = "2")]
        pub sigs: ::prost::alloc::vec::Vec<Signature>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SignatureList {
        #[inline]
        fn clone(&self) -> SignatureList {
            match *self {
                SignatureList {
                    sigs: ref __self_0_0,
                } => SignatureList {
                    sigs: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for SignatureList {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for SignatureList {
        #[inline]
        fn eq(&self, other: &SignatureList) -> bool {
            match *other {
                SignatureList {
                    sigs: ref __self_1_0,
                } => match *self {
                    SignatureList {
                        sigs: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &SignatureList) -> bool {
            match *other {
                SignatureList {
                    sigs: ref __self_1_0,
                } => match *self {
                    SignatureList {
                        sigs: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for SignatureList {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.sigs {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "SignatureList";
            match tag {
                2u32 => {
                    let mut value = &mut self.sigs;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "sigs");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(2u32, &self.sigs)
        }
        fn clear(&mut self) {
            self.sigs.clear();
        }
    }
    impl ::core::default::Default for SignatureList {
        fn default() -> Self {
            SignatureList {
                sigs: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for SignatureList {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("SignatureList");
            let builder = {
                let wrapper = &self.sigs;
                builder.field("sigs", &wrapper)
            };
            builder.finish()
        }
    }
    /// The client may use any number of bytes from zero to the whole length of the public key for
    /// pubKeyPrefix. If zero bytes are used, then it must be that only one primitive key is required
    /// to sign the linked transaction; it will surely resolve to <tt>INVALID_SIGNATURE</tt> otherwise.
    ///
    /// <b>IMPORTANT:</b> In the special case that a signature is being provided for a key used to
    /// authorize a precompiled contract, the <tt>pubKeyPrefix</tt> must contain the <b>entire public
    /// key</b>! That is, if the key is a Ed25519 key, the <tt>pubKeyPrefix</tt> should be 32 bytes
    /// long. If the key is a ECDSA(secp256k1) key, the <tt>pubKeyPrefix</tt> should be 33 bytes long,
    /// since we require the compressed form of the public key.
    ///
    /// Only Ed25519 and ECDSA(secp256k1) keys and hence signatures are currently supported.
    pub struct SignaturePair {
        /// First few bytes of the public key
        #[prost(bytes = "vec", tag = "1")]
        pub pub_key_prefix: ::prost::alloc::vec::Vec<u8>,
        #[prost(oneof = "signature_pair::Signature", tags = "2, 3, 4, 5, 6")]
        pub signature: ::core::option::Option<signature_pair::Signature>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SignaturePair {
        #[inline]
        fn clone(&self) -> SignaturePair {
            match *self {
                SignaturePair {
                    pub_key_prefix: ref __self_0_0,
                    signature: ref __self_0_1,
                } => SignaturePair {
                    pub_key_prefix: ::core::clone::Clone::clone(&(*__self_0_0)),
                    signature: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for SignaturePair {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for SignaturePair {
        #[inline]
        fn eq(&self, other: &SignaturePair) -> bool {
            match *other {
                SignaturePair {
                    pub_key_prefix: ref __self_1_0,
                    signature: ref __self_1_1,
                } => match *self {
                    SignaturePair {
                        pub_key_prefix: ref __self_0_0,
                        signature: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &SignaturePair) -> bool {
            match *other {
                SignaturePair {
                    pub_key_prefix: ref __self_1_0,
                    signature: ref __self_1_1,
                } => match *self {
                    SignaturePair {
                        pub_key_prefix: ref __self_0_0,
                        signature: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for SignaturePair {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.pub_key_prefix != b"" as &[u8] {
                ::prost::encoding::bytes::encode(1u32, &self.pub_key_prefix, buf);
            }
            if let Some(ref oneof) = self.signature {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "SignaturePair";
            match tag {
                1u32 => {
                    let mut value = &mut self.pub_key_prefix;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "pub_key_prefix");
                            error
                        },
                    )
                }
                2u32 | 3u32 | 4u32 | 5u32 | 6u32 => {
                    let mut value = &mut self.signature;
                    signature_pair::Signature::merge(value, tag, wire_type, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "signature");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.pub_key_prefix != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(1u32, &self.pub_key_prefix)
            } else {
                0
            } + self
                .signature
                .as_ref()
                .map_or(0, signature_pair::Signature::encoded_len)
        }
        fn clear(&mut self) {
            self.pub_key_prefix.clear();
            self.signature = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for SignaturePair {
        fn default() -> Self {
            SignaturePair {
                pub_key_prefix: ::core::default::Default::default(),
                signature: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for SignaturePair {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("SignaturePair");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.pub_key_prefix)
                };
                builder.field("pub_key_prefix", &wrapper)
            };
            let builder = {
                let wrapper = &self.signature;
                builder.field("signature", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for SignaturePair {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for SignaturePair {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<
                    ::core::option::Option<signature_pair::Signature>,
                >;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for SignaturePair {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                SignaturePair {
                    pub_key_prefix: ref __self_0_0,
                    signature: ref __self_0_1,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state)
                }
            }
        }
    }
    /// Nested message and enum types in `SignaturePair`.
    pub mod signature_pair {
        pub enum Signature {
            /// smart contract virtual signature (always length zero)
            #[prost(bytes, tag = "2")]
            Contract(::prost::alloc::vec::Vec<u8>),
            /// ed25519 signature
            #[prost(bytes, tag = "3")]
            Ed25519(::prost::alloc::vec::Vec<u8>),
            /// RSA-3072 signature
            #[prost(bytes, tag = "4")]
            Rsa3072(::prost::alloc::vec::Vec<u8>),
            /// ECDSA p-384 signature
            #[prost(bytes, tag = "5")]
            Ecdsa384(::prost::alloc::vec::Vec<u8>),
            /// ECDSA(secp256k1) signature
            #[prost(bytes, tag = "6")]
            EcdsaSecp256k1(::prost::alloc::vec::Vec<u8>),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Signature {
            #[inline]
            fn clone(&self) -> Signature {
                match (&*self,) {
                    (&Signature::Contract(ref __self_0),) => {
                        Signature::Contract(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Signature::Ed25519(ref __self_0),) => {
                        Signature::Ed25519(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Signature::Rsa3072(ref __self_0),) => {
                        Signature::Rsa3072(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Signature::Ecdsa384(ref __self_0),) => {
                        Signature::Ecdsa384(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Signature::EcdsaSecp256k1(ref __self_0),) => {
                        Signature::EcdsaSecp256k1(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Signature {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Signature {
            #[inline]
            fn eq(&self, other: &Signature) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Signature::Contract(ref __self_0),
                                &Signature::Contract(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Signature::Ed25519(ref __self_0),
                                &Signature::Ed25519(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Signature::Rsa3072(ref __self_0),
                                &Signature::Rsa3072(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Signature::Ecdsa384(ref __self_0),
                                &Signature::Ecdsa384(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Signature::EcdsaSecp256k1(ref __self_0),
                                &Signature::EcdsaSecp256k1(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Signature) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Signature::Contract(ref __self_0),
                                &Signature::Contract(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Signature::Ed25519(ref __self_0),
                                &Signature::Ed25519(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Signature::Rsa3072(ref __self_0),
                                &Signature::Rsa3072(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Signature::Ecdsa384(ref __self_0),
                                &Signature::Ecdsa384(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Signature::EcdsaSecp256k1(ref __self_0),
                                &Signature::EcdsaSecp256k1(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Signature {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Signature::Contract(ref value) => {
                        ::prost::encoding::bytes::encode(2u32, &*value, buf);
                    }
                    Signature::Ed25519(ref value) => {
                        ::prost::encoding::bytes::encode(3u32, &*value, buf);
                    }
                    Signature::Rsa3072(ref value) => {
                        ::prost::encoding::bytes::encode(4u32, &*value, buf);
                    }
                    Signature::Ecdsa384(ref value) => {
                        ::prost::encoding::bytes::encode(5u32, &*value, buf);
                    }
                    Signature::EcdsaSecp256k1(ref value) => {
                        ::prost::encoding::bytes::encode(6u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Signature>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    2u32 => match field {
                        ::core::option::Option::Some(Signature::Contract(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Signature::Contract(owned_value))
                            })
                        }
                    },
                    3u32 => match field {
                        ::core::option::Option::Some(Signature::Ed25519(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Signature::Ed25519(owned_value))
                            })
                        }
                    },
                    4u32 => match field {
                        ::core::option::Option::Some(Signature::Rsa3072(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Signature::Rsa3072(owned_value))
                            })
                        }
                    },
                    5u32 => match field {
                        ::core::option::Option::Some(Signature::Ecdsa384(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field =
                                    ::core::option::Option::Some(Signature::Ecdsa384(owned_value))
                            })
                        }
                    },
                    6u32 => match field {
                        ::core::option::Option::Some(Signature::EcdsaSecp256k1(ref mut value)) => {
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map(|_| {
                                *field = ::core::option::Option::Some(Signature::EcdsaSecp256k1(
                                    owned_value,
                                ))
                            })
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Signature tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Signature::Contract(ref value) => {
                        ::prost::encoding::bytes::encoded_len(2u32, &*value)
                    }
                    Signature::Ed25519(ref value) => {
                        ::prost::encoding::bytes::encoded_len(3u32, &*value)
                    }
                    Signature::Rsa3072(ref value) => {
                        ::prost::encoding::bytes::encoded_len(4u32, &*value)
                    }
                    Signature::Ecdsa384(ref value) => {
                        ::prost::encoding::bytes::encoded_len(5u32, &*value)
                    }
                    Signature::EcdsaSecp256k1(ref value) => {
                        ::prost::encoding::bytes::encoded_len(6u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Signature {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Signature::Contract(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Contract").field(&wrapper).finish()
                    }
                    Signature::Ed25519(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Ed25519").field(&wrapper).finish()
                    }
                    Signature::Rsa3072(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Rsa3072").field(&wrapper).finish()
                    }
                    Signature::Ecdsa384(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Ecdsa384").field(&wrapper).finish()
                    }
                    Signature::EcdsaSecp256k1(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("EcdsaSecp256k1").field(&wrapper).finish()
                    }
                }
            }
        }
        impl ::core::marker::StructuralEq for Signature {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Signature {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                    let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                    let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                    let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                    let _: ::core::cmp::AssertParamIsEq<::prost::alloc::vec::Vec<u8>>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Signature {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&Signature::Contract(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Signature::Ed25519(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Signature::Rsa3072(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Signature::Ecdsa384(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    (&Signature::EcdsaSecp256k1(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &::core::intrinsics::discriminant_value(self),
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                }
            }
        }
    }
    /// A set of signatures corresponding to every unique public key used to sign a given transaction. If
    /// one public key matches more than one prefixes on the signature map, the transaction containing
    /// the map will fail immediately with the response code KEY_PREFIX_MISMATCH.
    pub struct SignatureMap {
        /// Each signature pair corresponds to a unique Key required to sign the transaction.
        #[prost(message, repeated, tag = "1")]
        pub sig_pair: ::prost::alloc::vec::Vec<SignaturePair>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SignatureMap {
        #[inline]
        fn clone(&self) -> SignatureMap {
            match *self {
                SignatureMap {
                    sig_pair: ref __self_0_0,
                } => SignatureMap {
                    sig_pair: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for SignatureMap {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for SignatureMap {
        #[inline]
        fn eq(&self, other: &SignatureMap) -> bool {
            match *other {
                SignatureMap {
                    sig_pair: ref __self_1_0,
                } => match *self {
                    SignatureMap {
                        sig_pair: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &SignatureMap) -> bool {
            match *other {
                SignatureMap {
                    sig_pair: ref __self_1_0,
                } => match *self {
                    SignatureMap {
                        sig_pair: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for SignatureMap {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.sig_pair {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "SignatureMap";
            match tag {
                1u32 => {
                    let mut value = &mut self.sig_pair;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "sig_pair");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.sig_pair)
        }
        fn clear(&mut self) {
            self.sig_pair.clear();
        }
    }
    impl ::core::default::Default for SignatureMap {
        fn default() -> Self {
            SignatureMap {
                sig_pair: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for SignatureMap {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("SignatureMap");
            let builder = {
                let wrapper = &self.sig_pair;
                builder.field("sig_pair", &wrapper)
            };
            builder.finish()
        }
    }
    /// A set of prices the nodes use in determining transaction and query fees, and constants involved
    /// in fee calculations.  Nodes multiply the amount of resources consumed by a transaction or query
    /// by the corresponding price to calculate the appropriate fee. Units are one-thousandth of a
    /// tinyCent.
    pub struct FeeComponents {
        /// A minimum, the calculated fee must be greater than this value
        #[prost(int64, tag = "1")]
        pub min: i64,
        /// A maximum, the calculated fee must be less than this value
        #[prost(int64, tag = "2")]
        pub max: i64,
        /// A constant contribution to the fee
        #[prost(int64, tag = "3")]
        pub constant: i64,
        /// The price of bandwidth consumed by a transaction, measured in bytes
        #[prost(int64, tag = "4")]
        pub bpt: i64,
        /// The price per signature verification for a transaction
        #[prost(int64, tag = "5")]
        pub vpt: i64,
        /// The price of RAM consumed by a transaction, measured in byte-hours
        #[prost(int64, tag = "6")]
        pub rbh: i64,
        /// The price of storage consumed by a transaction, measured in byte-hours
        #[prost(int64, tag = "7")]
        pub sbh: i64,
        /// The price of computation for a smart contract transaction, measured in gas
        #[prost(int64, tag = "8")]
        pub gas: i64,
        /// The price per hbar transferred for a transfer
        #[prost(int64, tag = "9")]
        pub tv: i64,
        /// The price of bandwidth for data retrieved from memory for a response, measured in bytes
        #[prost(int64, tag = "10")]
        pub bpr: i64,
        /// The price of bandwidth for data retrieved from disk for a response, measured in bytes
        #[prost(int64, tag = "11")]
        pub sbpr: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FeeComponents {
        #[inline]
        fn clone(&self) -> FeeComponents {
            {
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                let _: ::core::clone::AssertParamIsClone<i64>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FeeComponents {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FeeComponents {
        #[inline]
        fn eq(&self, other: &FeeComponents) -> bool {
            match *other {
                FeeComponents {
                    min: ref __self_1_0,
                    max: ref __self_1_1,
                    constant: ref __self_1_2,
                    bpt: ref __self_1_3,
                    vpt: ref __self_1_4,
                    rbh: ref __self_1_5,
                    sbh: ref __self_1_6,
                    gas: ref __self_1_7,
                    tv: ref __self_1_8,
                    bpr: ref __self_1_9,
                    sbpr: ref __self_1_10,
                } => match *self {
                    FeeComponents {
                        min: ref __self_0_0,
                        max: ref __self_0_1,
                        constant: ref __self_0_2,
                        bpt: ref __self_0_3,
                        vpt: ref __self_0_4,
                        rbh: ref __self_0_5,
                        sbh: ref __self_0_6,
                        gas: ref __self_0_7,
                        tv: ref __self_0_8,
                        bpr: ref __self_0_9,
                        sbpr: ref __self_0_10,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FeeComponents) -> bool {
            match *other {
                FeeComponents {
                    min: ref __self_1_0,
                    max: ref __self_1_1,
                    constant: ref __self_1_2,
                    bpt: ref __self_1_3,
                    vpt: ref __self_1_4,
                    rbh: ref __self_1_5,
                    sbh: ref __self_1_6,
                    gas: ref __self_1_7,
                    tv: ref __self_1_8,
                    bpr: ref __self_1_9,
                    sbpr: ref __self_1_10,
                } => match *self {
                    FeeComponents {
                        min: ref __self_0_0,
                        max: ref __self_0_1,
                        constant: ref __self_0_2,
                        bpt: ref __self_0_3,
                        vpt: ref __self_0_4,
                        rbh: ref __self_0_5,
                        sbh: ref __self_0_6,
                        gas: ref __self_0_7,
                        tv: ref __self_0_8,
                        bpr: ref __self_0_9,
                        sbpr: ref __self_0_10,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                    }
                },
            }
        }
    }
    impl ::prost::Message for FeeComponents {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.min != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.min, buf);
            }
            if self.max != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.max, buf);
            }
            if self.constant != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.constant, buf);
            }
            if self.bpt != 0i64 {
                ::prost::encoding::int64::encode(4u32, &self.bpt, buf);
            }
            if self.vpt != 0i64 {
                ::prost::encoding::int64::encode(5u32, &self.vpt, buf);
            }
            if self.rbh != 0i64 {
                ::prost::encoding::int64::encode(6u32, &self.rbh, buf);
            }
            if self.sbh != 0i64 {
                ::prost::encoding::int64::encode(7u32, &self.sbh, buf);
            }
            if self.gas != 0i64 {
                ::prost::encoding::int64::encode(8u32, &self.gas, buf);
            }
            if self.tv != 0i64 {
                ::prost::encoding::int64::encode(9u32, &self.tv, buf);
            }
            if self.bpr != 0i64 {
                ::prost::encoding::int64::encode(10u32, &self.bpr, buf);
            }
            if self.sbpr != 0i64 {
                ::prost::encoding::int64::encode(11u32, &self.sbpr, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FeeComponents";
            match tag {
                1u32 => {
                    let mut value = &mut self.min;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "min");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.max;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "max");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.constant;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "constant");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.bpt;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "bpt");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.vpt;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "vpt");
                            error
                        },
                    )
                }
                6u32 => {
                    let mut value = &mut self.rbh;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "rbh");
                            error
                        },
                    )
                }
                7u32 => {
                    let mut value = &mut self.sbh;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "sbh");
                            error
                        },
                    )
                }
                8u32 => {
                    let mut value = &mut self.gas;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "gas");
                            error
                        },
                    )
                }
                9u32 => {
                    let mut value = &mut self.tv;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "tv");
                            error
                        },
                    )
                }
                10u32 => {
                    let mut value = &mut self.bpr;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "bpr");
                            error
                        },
                    )
                }
                11u32 => {
                    let mut value = &mut self.sbpr;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "sbpr");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.min != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.min)
            } else {
                0
            } + if self.max != 0i64 {
                ::prost::encoding::int64::encoded_len(2u32, &self.max)
            } else {
                0
            } + if self.constant != 0i64 {
                ::prost::encoding::int64::encoded_len(3u32, &self.constant)
            } else {
                0
            } + if self.bpt != 0i64 {
                ::prost::encoding::int64::encoded_len(4u32, &self.bpt)
            } else {
                0
            } + if self.vpt != 0i64 {
                ::prost::encoding::int64::encoded_len(5u32, &self.vpt)
            } else {
                0
            } + if self.rbh != 0i64 {
                ::prost::encoding::int64::encoded_len(6u32, &self.rbh)
            } else {
                0
            } + if self.sbh != 0i64 {
                ::prost::encoding::int64::encoded_len(7u32, &self.sbh)
            } else {
                0
            } + if self.gas != 0i64 {
                ::prost::encoding::int64::encoded_len(8u32, &self.gas)
            } else {
                0
            } + if self.tv != 0i64 {
                ::prost::encoding::int64::encoded_len(9u32, &self.tv)
            } else {
                0
            } + if self.bpr != 0i64 {
                ::prost::encoding::int64::encoded_len(10u32, &self.bpr)
            } else {
                0
            } + if self.sbpr != 0i64 {
                ::prost::encoding::int64::encoded_len(11u32, &self.sbpr)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.min = 0i64;
            self.max = 0i64;
            self.constant = 0i64;
            self.bpt = 0i64;
            self.vpt = 0i64;
            self.rbh = 0i64;
            self.sbh = 0i64;
            self.gas = 0i64;
            self.tv = 0i64;
            self.bpr = 0i64;
            self.sbpr = 0i64;
        }
    }
    impl ::core::default::Default for FeeComponents {
        fn default() -> Self {
            FeeComponents {
                min: 0i64,
                max: 0i64,
                constant: 0i64,
                bpt: 0i64,
                vpt: 0i64,
                rbh: 0i64,
                sbh: 0i64,
                gas: 0i64,
                tv: 0i64,
                bpr: 0i64,
                sbpr: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for FeeComponents {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FeeComponents");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.min)
                };
                builder.field("min", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.max)
                };
                builder.field("max", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.constant)
                };
                builder.field("constant", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.bpt)
                };
                builder.field("bpt", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.vpt)
                };
                builder.field("vpt", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.rbh)
                };
                builder.field("rbh", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.sbh)
                };
                builder.field("sbh", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.gas)
                };
                builder.field("gas", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.tv)
                };
                builder.field("tv", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.bpr)
                };
                builder.field("bpr", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.sbpr)
                };
                builder.field("sbpr", &wrapper)
            };
            builder.finish()
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for FeeComponents {}
    impl ::core::marker::StructuralEq for FeeComponents {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for FeeComponents {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for FeeComponents {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                FeeComponents {
                    min: ref __self_0_0,
                    max: ref __self_0_1,
                    constant: ref __self_0_2,
                    bpt: ref __self_0_3,
                    vpt: ref __self_0_4,
                    rbh: ref __self_0_5,
                    sbh: ref __self_0_6,
                    gas: ref __self_0_7,
                    tv: ref __self_0_8,
                    bpr: ref __self_0_9,
                    sbpr: ref __self_0_10,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state);
                    ::core::hash::Hash::hash(&(*__self_0_3), state);
                    ::core::hash::Hash::hash(&(*__self_0_4), state);
                    ::core::hash::Hash::hash(&(*__self_0_5), state);
                    ::core::hash::Hash::hash(&(*__self_0_6), state);
                    ::core::hash::Hash::hash(&(*__self_0_7), state);
                    ::core::hash::Hash::hash(&(*__self_0_8), state);
                    ::core::hash::Hash::hash(&(*__self_0_9), state);
                    ::core::hash::Hash::hash(&(*__self_0_10), state)
                }
            }
        }
    }
    /// The fees for a specific transaction or query based on the fee data.
    pub struct TransactionFeeSchedule {
        /// A particular transaction or query
        #[prost(enumeration = "HederaFunctionality", tag = "1")]
        pub hedera_functionality: i32,
        /// Resource price coefficients
        #[deprecated]
        #[prost(message, optional, tag = "2")]
        pub fee_data: ::core::option::Option<FeeData>,
        /// Resource price coefficients. Supports subtype price definition.
        #[prost(message, repeated, tag = "3")]
        pub fees: ::prost::alloc::vec::Vec<FeeData>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionFeeSchedule {
        #[inline]
        fn clone(&self) -> TransactionFeeSchedule {
            match *self {
                TransactionFeeSchedule {
                    hedera_functionality: ref __self_0_0,
                    fee_data: ref __self_0_1,
                    fees: ref __self_0_2,
                } => TransactionFeeSchedule {
                    hedera_functionality: ::core::clone::Clone::clone(&(*__self_0_0)),
                    fee_data: ::core::clone::Clone::clone(&(*__self_0_1)),
                    fees: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionFeeSchedule {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionFeeSchedule {
        #[inline]
        fn eq(&self, other: &TransactionFeeSchedule) -> bool {
            match *other {
                TransactionFeeSchedule {
                    hedera_functionality: ref __self_1_0,
                    fee_data: ref __self_1_1,
                    fees: ref __self_1_2,
                } => match *self {
                    TransactionFeeSchedule {
                        hedera_functionality: ref __self_0_0,
                        fee_data: ref __self_0_1,
                        fees: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionFeeSchedule) -> bool {
            match *other {
                TransactionFeeSchedule {
                    hedera_functionality: ref __self_1_0,
                    fee_data: ref __self_1_1,
                    fees: ref __self_1_2,
                } => match *self {
                    TransactionFeeSchedule {
                        hedera_functionality: ref __self_0_0,
                        fee_data: ref __self_0_1,
                        fees: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TransactionFeeSchedule {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.hedera_functionality != HederaFunctionality::default() as i32 {
                ::prost::encoding::int32::encode(1u32, &self.hedera_functionality, buf);
            }
            if let Some(ref msg) = self.fee_data {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            for msg in &self.fees {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionFeeSchedule";
            match tag {
                1u32 => {
                    let mut value = &mut self.hedera_functionality;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "hedera_functionality");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.fee_data;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "fee_data");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.fees;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "fees");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.hedera_functionality != HederaFunctionality::default() as i32 {
                ::prost::encoding::int32::encoded_len(1u32, &self.hedera_functionality)
            } else {
                0
            } + self
                .fee_data
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(3u32, &self.fees)
        }
        fn clear(&mut self) {
            self.hedera_functionality = HederaFunctionality::default() as i32;
            self.fee_data = ::core::option::Option::None;
            self.fees.clear();
        }
    }
    impl ::core::default::Default for TransactionFeeSchedule {
        fn default() -> Self {
            TransactionFeeSchedule {
                hedera_functionality: HederaFunctionality::default() as i32,
                fee_data: ::core::default::Default::default(),
                fees: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TransactionFeeSchedule {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionFeeSchedule");
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match HederaFunctionality::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.hedera_functionality)
                };
                builder.field("hedera_functionality", &wrapper)
            };
            let builder = {
                let wrapper = &self.fee_data;
                builder.field("fee_data", &wrapper)
            };
            let builder = {
                let wrapper = &self.fees;
                builder.field("fees", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl TransactionFeeSchedule {
        ///Returns the enum value of `hedera_functionality`, or the default if the field is set to an invalid enum value.
        pub fn hedera_functionality(&self) -> HederaFunctionality {
            HederaFunctionality::from_i32(self.hedera_functionality)
                .unwrap_or(HederaFunctionality::default())
        }
        ///Sets `hedera_functionality` to the provided enum value.
        pub fn set_hedera_functionality(&mut self, value: HederaFunctionality) {
            self.hedera_functionality = value as i32;
        }
    }
    /// The total fee charged for a transaction. It is composed of three components – a node fee that
    /// compensates the specific node that submitted the transaction, a network fee that compensates the
    /// network for assigning the transaction a consensus timestamp, and a service fee that compensates
    /// the network for the ongoing maintenance of the consequences of the transaction.
    pub struct FeeData {
        /// Fee paid to the submitting node
        #[prost(message, optional, tag = "1")]
        pub nodedata: ::core::option::Option<FeeComponents>,
        /// Fee paid to the network for processing a transaction into consensus
        #[prost(message, optional, tag = "2")]
        pub networkdata: ::core::option::Option<FeeComponents>,
        /// Fee paid to the network for providing the service associated with the
        /// transaction; for instance, storing a file
        #[prost(message, optional, tag = "3")]
        pub servicedata: ::core::option::Option<FeeComponents>,
        /// SubType distinguishing between different types of FeeData, correlating
        /// to the same HederaFunctionality
        #[prost(enumeration = "SubType", tag = "4")]
        pub sub_type: i32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FeeData {
        #[inline]
        fn clone(&self) -> FeeData {
            {
                let _: ::core::clone::AssertParamIsClone<::core::option::Option<FeeComponents>>;
                let _: ::core::clone::AssertParamIsClone<::core::option::Option<FeeComponents>>;
                let _: ::core::clone::AssertParamIsClone<::core::option::Option<FeeComponents>>;
                let _: ::core::clone::AssertParamIsClone<i32>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FeeData {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FeeData {
        #[inline]
        fn eq(&self, other: &FeeData) -> bool {
            match *other {
                FeeData {
                    nodedata: ref __self_1_0,
                    networkdata: ref __self_1_1,
                    servicedata: ref __self_1_2,
                    sub_type: ref __self_1_3,
                } => match *self {
                    FeeData {
                        nodedata: ref __self_0_0,
                        networkdata: ref __self_0_1,
                        servicedata: ref __self_0_2,
                        sub_type: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FeeData) -> bool {
            match *other {
                FeeData {
                    nodedata: ref __self_1_0,
                    networkdata: ref __self_1_1,
                    servicedata: ref __self_1_2,
                    sub_type: ref __self_1_3,
                } => match *self {
                    FeeData {
                        nodedata: ref __self_0_0,
                        networkdata: ref __self_0_1,
                        servicedata: ref __self_0_2,
                        sub_type: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for FeeData {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.nodedata {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.networkdata {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.servicedata {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if self.sub_type != SubType::default() as i32 {
                ::prost::encoding::int32::encode(4u32, &self.sub_type, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FeeData";
            match tag {
                1u32 => {
                    let mut value = &mut self.nodedata;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "nodedata");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.networkdata;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "networkdata");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.servicedata;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "servicedata");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.sub_type;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "sub_type");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .nodedata
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .networkdata
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .servicedata
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + if self.sub_type != SubType::default() as i32 {
                    ::prost::encoding::int32::encoded_len(4u32, &self.sub_type)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.nodedata = ::core::option::Option::None;
            self.networkdata = ::core::option::Option::None;
            self.servicedata = ::core::option::Option::None;
            self.sub_type = SubType::default() as i32;
        }
    }
    impl ::core::default::Default for FeeData {
        fn default() -> Self {
            FeeData {
                nodedata: ::core::default::Default::default(),
                networkdata: ::core::default::Default::default(),
                servicedata: ::core::default::Default::default(),
                sub_type: SubType::default() as i32,
            }
        }
    }
    impl ::core::fmt::Debug for FeeData {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FeeData");
            let builder = {
                let wrapper = &self.nodedata;
                builder.field("nodedata", &wrapper)
            };
            let builder = {
                let wrapper = &self.networkdata;
                builder.field("networkdata", &wrapper)
            };
            let builder = {
                let wrapper = &self.servicedata;
                builder.field("servicedata", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match SubType::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.sub_type)
                };
                builder.field("sub_type", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl FeeData {
        ///Returns the enum value of `sub_type`, or the default if the field is set to an invalid enum value.
        pub fn sub_type(&self) -> SubType {
            SubType::from_i32(self.sub_type).unwrap_or(SubType::default())
        }
        ///Sets `sub_type` to the provided enum value.
        pub fn set_sub_type(&mut self, value: SubType) {
            self.sub_type = value as i32;
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for FeeData {}
    impl ::core::marker::StructuralEq for FeeData {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for FeeData {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<FeeComponents>>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<FeeComponents>>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<FeeComponents>>;
                let _: ::core::cmp::AssertParamIsEq<i32>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for FeeData {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                FeeData {
                    nodedata: ref __self_0_0,
                    networkdata: ref __self_0_1,
                    servicedata: ref __self_0_2,
                    sub_type: ref __self_0_3,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state);
                    ::core::hash::Hash::hash(&(*__self_0_3), state)
                }
            }
        }
    }
    /// A list of resource prices fee for different transactions and queries and the time period at which
    /// this fee schedule will expire. Nodes use the prices to determine the fees for all transactions
    /// based on how much of those resources each transaction uses.
    pub struct FeeSchedule {
        /// List of price coefficients for network resources
        #[prost(message, repeated, tag = "1")]
        pub transaction_fee_schedule: ::prost::alloc::vec::Vec<TransactionFeeSchedule>,
        /// FeeSchedule expiry time
        #[prost(message, optional, tag = "2")]
        pub expiry_time: ::core::option::Option<TimestampSeconds>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FeeSchedule {
        #[inline]
        fn clone(&self) -> FeeSchedule {
            match *self {
                FeeSchedule {
                    transaction_fee_schedule: ref __self_0_0,
                    expiry_time: ref __self_0_1,
                } => FeeSchedule {
                    transaction_fee_schedule: ::core::clone::Clone::clone(&(*__self_0_0)),
                    expiry_time: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FeeSchedule {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FeeSchedule {
        #[inline]
        fn eq(&self, other: &FeeSchedule) -> bool {
            match *other {
                FeeSchedule {
                    transaction_fee_schedule: ref __self_1_0,
                    expiry_time: ref __self_1_1,
                } => match *self {
                    FeeSchedule {
                        transaction_fee_schedule: ref __self_0_0,
                        expiry_time: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FeeSchedule) -> bool {
            match *other {
                FeeSchedule {
                    transaction_fee_schedule: ref __self_1_0,
                    expiry_time: ref __self_1_1,
                } => match *self {
                    FeeSchedule {
                        transaction_fee_schedule: ref __self_0_0,
                        expiry_time: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for FeeSchedule {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.transaction_fee_schedule {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.expiry_time {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FeeSchedule";
            match tag {
                1u32 => {
                    let mut value = &mut self.transaction_fee_schedule;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "transaction_fee_schedule");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.expiry_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiry_time");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(
                1u32,
                &self.transaction_fee_schedule,
            ) + self
                .expiry_time
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.transaction_fee_schedule.clear();
            self.expiry_time = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for FeeSchedule {
        fn default() -> Self {
            FeeSchedule {
                transaction_fee_schedule: ::core::default::Default::default(),
                expiry_time: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for FeeSchedule {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FeeSchedule");
            let builder = {
                let wrapper = &self.transaction_fee_schedule;
                builder.field("transaction_fee_schedule", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiry_time;
                builder.field("expiry_time", &wrapper)
            };
            builder.finish()
        }
    }
    /// This contains two Fee Schedules with expiry timestamp.
    pub struct CurrentAndNextFeeSchedule {
        /// Contains current Fee Schedule
        #[prost(message, optional, tag = "1")]
        pub current_fee_schedule: ::core::option::Option<FeeSchedule>,
        /// Contains next Fee Schedule
        #[prost(message, optional, tag = "2")]
        pub next_fee_schedule: ::core::option::Option<FeeSchedule>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CurrentAndNextFeeSchedule {
        #[inline]
        fn clone(&self) -> CurrentAndNextFeeSchedule {
            match *self {
                CurrentAndNextFeeSchedule {
                    current_fee_schedule: ref __self_0_0,
                    next_fee_schedule: ref __self_0_1,
                } => CurrentAndNextFeeSchedule {
                    current_fee_schedule: ::core::clone::Clone::clone(&(*__self_0_0)),
                    next_fee_schedule: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CurrentAndNextFeeSchedule {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CurrentAndNextFeeSchedule {
        #[inline]
        fn eq(&self, other: &CurrentAndNextFeeSchedule) -> bool {
            match *other {
                CurrentAndNextFeeSchedule {
                    current_fee_schedule: ref __self_1_0,
                    next_fee_schedule: ref __self_1_1,
                } => match *self {
                    CurrentAndNextFeeSchedule {
                        current_fee_schedule: ref __self_0_0,
                        next_fee_schedule: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CurrentAndNextFeeSchedule) -> bool {
            match *other {
                CurrentAndNextFeeSchedule {
                    current_fee_schedule: ref __self_1_0,
                    next_fee_schedule: ref __self_1_1,
                } => match *self {
                    CurrentAndNextFeeSchedule {
                        current_fee_schedule: ref __self_0_0,
                        next_fee_schedule: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CurrentAndNextFeeSchedule {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.current_fee_schedule {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.next_fee_schedule {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CurrentAndNextFeeSchedule";
            match tag {
                1u32 => {
                    let mut value = &mut self.current_fee_schedule;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "current_fee_schedule");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.next_fee_schedule;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "next_fee_schedule");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .current_fee_schedule
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .next_fee_schedule
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.current_fee_schedule = ::core::option::Option::None;
            self.next_fee_schedule = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CurrentAndNextFeeSchedule {
        fn default() -> Self {
            CurrentAndNextFeeSchedule {
                current_fee_schedule: ::core::default::Default::default(),
                next_fee_schedule: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CurrentAndNextFeeSchedule {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CurrentAndNextFeeSchedule");
            let builder = {
                let wrapper = &self.current_fee_schedule;
                builder.field("current_fee_schedule", &wrapper)
            };
            let builder = {
                let wrapper = &self.next_fee_schedule;
                builder.field("next_fee_schedule", &wrapper)
            };
            builder.finish()
        }
    }
    /// Contains the IP address and the port representing a service endpoint of a Node in a network. Used
    /// to reach the Hedera API and submit transactions to the network.
    pub struct ServiceEndpoint {
        /// The 32-bit IPv4 address of the node encoded in left to right order (e.g.  127.0.0.1 has 127
        /// as its first byte)
        #[prost(bytes = "vec", tag = "1")]
        pub ip_address_v4: ::prost::alloc::vec::Vec<u8>,
        /// The port of the node
        #[prost(int32, tag = "2")]
        pub port: i32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ServiceEndpoint {
        #[inline]
        fn clone(&self) -> ServiceEndpoint {
            match *self {
                ServiceEndpoint {
                    ip_address_v4: ref __self_0_0,
                    port: ref __self_0_1,
                } => ServiceEndpoint {
                    ip_address_v4: ::core::clone::Clone::clone(&(*__self_0_0)),
                    port: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ServiceEndpoint {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ServiceEndpoint {
        #[inline]
        fn eq(&self, other: &ServiceEndpoint) -> bool {
            match *other {
                ServiceEndpoint {
                    ip_address_v4: ref __self_1_0,
                    port: ref __self_1_1,
                } => match *self {
                    ServiceEndpoint {
                        ip_address_v4: ref __self_0_0,
                        port: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ServiceEndpoint) -> bool {
            match *other {
                ServiceEndpoint {
                    ip_address_v4: ref __self_1_0,
                    port: ref __self_1_1,
                } => match *self {
                    ServiceEndpoint {
                        ip_address_v4: ref __self_0_0,
                        port: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ServiceEndpoint {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.ip_address_v4 != b"" as &[u8] {
                ::prost::encoding::bytes::encode(1u32, &self.ip_address_v4, buf);
            }
            if self.port != 0i32 {
                ::prost::encoding::int32::encode(2u32, &self.port, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ServiceEndpoint";
            match tag {
                1u32 => {
                    let mut value = &mut self.ip_address_v4;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "ip_address_v4");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.port;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "port");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.ip_address_v4 != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(1u32, &self.ip_address_v4)
            } else {
                0
            } + if self.port != 0i32 {
                ::prost::encoding::int32::encoded_len(2u32, &self.port)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.ip_address_v4.clear();
            self.port = 0i32;
        }
    }
    impl ::core::default::Default for ServiceEndpoint {
        fn default() -> Self {
            ServiceEndpoint {
                ip_address_v4: ::core::default::Default::default(),
                port: 0i32,
            }
        }
    }
    impl ::core::fmt::Debug for ServiceEndpoint {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ServiceEndpoint");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.ip_address_v4)
                };
                builder.field("ip_address_v4", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.port)
                };
                builder.field("port", &wrapper)
            };
            builder.finish()
        }
    }
    /// The data about a node, including its service endpoints and the Hedera account to be paid for
    /// services provided by the node (that is, queries answered and transactions submitted.)
    ///
    /// If the <tt>serviceEndpoint</tt> list is not set, or empty, then the endpoint given by the
    /// (deprecated) <tt>ipAddress</tt> and <tt>portno</tt> fields should be used.
    ///
    /// All fields are populated in the 0.0.102 address book file while only fields that start with # are
    /// populated in the 0.0.101 address book file.
    pub struct NodeAddress {
        /// The IP address of the Node with separator & octets encoded in UTF-8.  Usage is deprecated,
        /// ServiceEndpoint is preferred to retrieve a node's list of IP addresses and ports
        #[deprecated]
        #[prost(bytes = "vec", tag = "1")]
        pub ip_address: ::prost::alloc::vec::Vec<u8>,
        /// The port number of the grpc server for the node.  Usage is deprecated, ServiceEndpoint is
        /// preferred to retrieve a node's list of IP addresses and ports
        #[deprecated]
        #[prost(int32, tag = "2")]
        pub portno: i32,
        /// Usage is deprecated, nodeAccountId is preferred to retrieve a node's account ID
        #[deprecated]
        #[prost(bytes = "vec", tag = "3")]
        pub memo: ::prost::alloc::vec::Vec<u8>,
        /// The node's X509 RSA public key used to sign stream files (e.g., record stream
        /// files). Precisely, this field is a string of hexadecimal characters which,
        /// translated to binary, are the public key's DER encoding.  
        #[prost(string, tag = "4")]
        pub rsa_pub_key: ::prost::alloc::string::String,
        /// # A non-sequential identifier for the node
        #[prost(int64, tag = "5")]
        pub node_id: i64,
        /// # The account to be paid for queries and transactions sent to this node
        #[prost(message, optional, tag = "6")]
        pub node_account_id: ::core::option::Option<AccountId>,
        /// # Hash of the node's TLS certificate. Precisely, this field is a string of
        /// hexadecimal characters which, translated to binary, are the SHA-384 hash of
        /// the UTF-8 NFKD encoding of the node's TLS cert in PEM format. Its value can be
        /// used to verify the node's certificate it presents during TLS negotiations.
        #[prost(bytes = "vec", tag = "7")]
        pub node_cert_hash: ::prost::alloc::vec::Vec<u8>,
        /// # A node's service IP addresses and ports
        #[prost(message, repeated, tag = "8")]
        pub service_endpoint: ::prost::alloc::vec::Vec<ServiceEndpoint>,
        /// A description of the node, with UTF-8 encoding up to 100 bytes
        #[prost(string, tag = "9")]
        pub description: ::prost::alloc::string::String,
        /// \[Deprecated\] The amount of tinybars staked to the node
        #[deprecated]
        #[prost(int64, tag = "10")]
        pub stake: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NodeAddress {
        #[inline]
        fn clone(&self) -> NodeAddress {
            match *self {
                NodeAddress {
                    ip_address: ref __self_0_0,
                    portno: ref __self_0_1,
                    memo: ref __self_0_2,
                    rsa_pub_key: ref __self_0_3,
                    node_id: ref __self_0_4,
                    node_account_id: ref __self_0_5,
                    node_cert_hash: ref __self_0_6,
                    service_endpoint: ref __self_0_7,
                    description: ref __self_0_8,
                    stake: ref __self_0_9,
                } => NodeAddress {
                    ip_address: ::core::clone::Clone::clone(&(*__self_0_0)),
                    portno: ::core::clone::Clone::clone(&(*__self_0_1)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_2)),
                    rsa_pub_key: ::core::clone::Clone::clone(&(*__self_0_3)),
                    node_id: ::core::clone::Clone::clone(&(*__self_0_4)),
                    node_account_id: ::core::clone::Clone::clone(&(*__self_0_5)),
                    node_cert_hash: ::core::clone::Clone::clone(&(*__self_0_6)),
                    service_endpoint: ::core::clone::Clone::clone(&(*__self_0_7)),
                    description: ::core::clone::Clone::clone(&(*__self_0_8)),
                    stake: ::core::clone::Clone::clone(&(*__self_0_9)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for NodeAddress {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for NodeAddress {
        #[inline]
        fn eq(&self, other: &NodeAddress) -> bool {
            match *other {
                NodeAddress {
                    ip_address: ref __self_1_0,
                    portno: ref __self_1_1,
                    memo: ref __self_1_2,
                    rsa_pub_key: ref __self_1_3,
                    node_id: ref __self_1_4,
                    node_account_id: ref __self_1_5,
                    node_cert_hash: ref __self_1_6,
                    service_endpoint: ref __self_1_7,
                    description: ref __self_1_8,
                    stake: ref __self_1_9,
                } => match *self {
                    NodeAddress {
                        ip_address: ref __self_0_0,
                        portno: ref __self_0_1,
                        memo: ref __self_0_2,
                        rsa_pub_key: ref __self_0_3,
                        node_id: ref __self_0_4,
                        node_account_id: ref __self_0_5,
                        node_cert_hash: ref __self_0_6,
                        service_endpoint: ref __self_0_7,
                        description: ref __self_0_8,
                        stake: ref __self_0_9,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NodeAddress) -> bool {
            match *other {
                NodeAddress {
                    ip_address: ref __self_1_0,
                    portno: ref __self_1_1,
                    memo: ref __self_1_2,
                    rsa_pub_key: ref __self_1_3,
                    node_id: ref __self_1_4,
                    node_account_id: ref __self_1_5,
                    node_cert_hash: ref __self_1_6,
                    service_endpoint: ref __self_1_7,
                    description: ref __self_1_8,
                    stake: ref __self_1_9,
                } => match *self {
                    NodeAddress {
                        ip_address: ref __self_0_0,
                        portno: ref __self_0_1,
                        memo: ref __self_0_2,
                        rsa_pub_key: ref __self_0_3,
                        node_id: ref __self_0_4,
                        node_account_id: ref __self_0_5,
                        node_cert_hash: ref __self_0_6,
                        service_endpoint: ref __self_0_7,
                        description: ref __self_0_8,
                        stake: ref __self_0_9,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                    }
                },
            }
        }
    }
    impl ::prost::Message for NodeAddress {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.ip_address != b"" as &[u8] {
                ::prost::encoding::bytes::encode(1u32, &self.ip_address, buf);
            }
            if self.portno != 0i32 {
                ::prost::encoding::int32::encode(2u32, &self.portno, buf);
            }
            if self.memo != b"" as &[u8] {
                ::prost::encoding::bytes::encode(3u32, &self.memo, buf);
            }
            if self.rsa_pub_key != "" {
                ::prost::encoding::string::encode(4u32, &self.rsa_pub_key, buf);
            }
            if self.node_id != 0i64 {
                ::prost::encoding::int64::encode(5u32, &self.node_id, buf);
            }
            if let Some(ref msg) = self.node_account_id {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            if self.node_cert_hash != b"" as &[u8] {
                ::prost::encoding::bytes::encode(7u32, &self.node_cert_hash, buf);
            }
            for msg in &self.service_endpoint {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
            if self.description != "" {
                ::prost::encoding::string::encode(9u32, &self.description, buf);
            }
            if self.stake != 0i64 {
                ::prost::encoding::int64::encode(10u32, &self.stake, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "NodeAddress";
            match tag {
                1u32 => {
                    let mut value = &mut self.ip_address;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "ip_address");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.portno;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "portno");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.rsa_pub_key;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "rsa_pub_key");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.node_id;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "node_id");
                            error
                        },
                    )
                }
                6u32 => {
                    let mut value = &mut self.node_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "node_account_id");
                        error
                    })
                }
                7u32 => {
                    let mut value = &mut self.node_cert_hash;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "node_cert_hash");
                            error
                        },
                    )
                }
                8u32 => {
                    let mut value = &mut self.service_endpoint;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "service_endpoint");
                            error
                        },
                    )
                }
                9u32 => {
                    let mut value = &mut self.description;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "description");
                            error
                        },
                    )
                }
                10u32 => {
                    let mut value = &mut self.stake;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "stake");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.ip_address != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(1u32, &self.ip_address)
            } else {
                0
            } + if self.portno != 0i32 {
                ::prost::encoding::int32::encoded_len(2u32, &self.portno)
            } else {
                0
            } + if self.memo != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(3u32, &self.memo)
            } else {
                0
            } + if self.rsa_pub_key != "" {
                ::prost::encoding::string::encoded_len(4u32, &self.rsa_pub_key)
            } else {
                0
            } + if self.node_id != 0i64 {
                ::prost::encoding::int64::encoded_len(5u32, &self.node_id)
            } else {
                0
            } + self
                .node_account_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                + if self.node_cert_hash != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(7u32, &self.node_cert_hash)
                } else {
                    0
                }
                + ::prost::encoding::message::encoded_len_repeated(8u32, &self.service_endpoint)
                + if self.description != "" {
                    ::prost::encoding::string::encoded_len(9u32, &self.description)
                } else {
                    0
                }
                + if self.stake != 0i64 {
                    ::prost::encoding::int64::encoded_len(10u32, &self.stake)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.ip_address.clear();
            self.portno = 0i32;
            self.memo.clear();
            self.rsa_pub_key.clear();
            self.node_id = 0i64;
            self.node_account_id = ::core::option::Option::None;
            self.node_cert_hash.clear();
            self.service_endpoint.clear();
            self.description.clear();
            self.stake = 0i64;
        }
    }
    impl ::core::default::Default for NodeAddress {
        fn default() -> Self {
            NodeAddress {
                ip_address: ::core::default::Default::default(),
                portno: 0i32,
                memo: ::core::default::Default::default(),
                rsa_pub_key: ::prost::alloc::string::String::new(),
                node_id: 0i64,
                node_account_id: ::core::default::Default::default(),
                node_cert_hash: ::core::default::Default::default(),
                service_endpoint: ::core::default::Default::default(),
                description: ::prost::alloc::string::String::new(),
                stake: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for NodeAddress {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NodeAddress");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.ip_address)
                };
                builder.field("ip_address", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.portno)
                };
                builder.field("portno", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.rsa_pub_key)
                };
                builder.field("rsa_pub_key", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.node_id)
                };
                builder.field("node_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.node_account_id;
                builder.field("node_account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.node_cert_hash)
                };
                builder.field("node_cert_hash", &wrapper)
            };
            let builder = {
                let wrapper = &self.service_endpoint;
                builder.field("service_endpoint", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.description)
                };
                builder.field("description", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.stake)
                };
                builder.field("stake", &wrapper)
            };
            builder.finish()
        }
    }
    /// A list of nodes and their metadata that contains all details of the nodes for the network.  Used
    /// to parse the contents of system files <tt>0.0.101</tt> and <tt>0.0.102</tt>.
    pub struct NodeAddressBook {
        /// Metadata of all nodes in the network
        #[prost(message, repeated, tag = "1")]
        pub node_address: ::prost::alloc::vec::Vec<NodeAddress>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NodeAddressBook {
        #[inline]
        fn clone(&self) -> NodeAddressBook {
            match *self {
                NodeAddressBook {
                    node_address: ref __self_0_0,
                } => NodeAddressBook {
                    node_address: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for NodeAddressBook {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for NodeAddressBook {
        #[inline]
        fn eq(&self, other: &NodeAddressBook) -> bool {
            match *other {
                NodeAddressBook {
                    node_address: ref __self_1_0,
                } => match *self {
                    NodeAddressBook {
                        node_address: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NodeAddressBook) -> bool {
            match *other {
                NodeAddressBook {
                    node_address: ref __self_1_0,
                } => match *self {
                    NodeAddressBook {
                        node_address: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for NodeAddressBook {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.node_address {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "NodeAddressBook";
            match tag {
                1u32 => {
                    let mut value = &mut self.node_address;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "node_address");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.node_address)
        }
        fn clear(&mut self) {
            self.node_address.clear();
        }
    }
    impl ::core::default::Default for NodeAddressBook {
        fn default() -> Self {
            NodeAddressBook {
                node_address: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for NodeAddressBook {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NodeAddressBook");
            let builder = {
                let wrapper = &self.node_address;
                builder.field("node_address", &wrapper)
            };
            builder.finish()
        }
    }
    /// Hedera follows semantic versioning (<https://semver.org/>) for both the HAPI protobufs and the
    /// Services software.  This type allows the <tt>getVersionInfo</tt> query in the
    /// <tt>NetworkService</tt> to return the deployed versions of both protobufs and software on the
    /// node answering the query.
    pub struct SemanticVersion {
        /// Increases with incompatible API changes
        #[prost(int32, tag = "1")]
        pub major: i32,
        /// Increases with backwards-compatible new functionality
        #[prost(int32, tag = "2")]
        pub minor: i32,
        /// Increases with backwards-compatible bug fixes
        #[prost(int32, tag = "3")]
        pub patch: i32,
        /// A pre-release version MAY be denoted by appending a hyphen and a series of dot separated
        /// identifiers (<https://semver.org/#spec-item-9>); so given a semver 0.14.0-alpha.1+21AF26D3,
        /// this field would contain 'alpha.1'
        #[prost(string, tag = "4")]
        pub pre: ::prost::alloc::string::String,
        /// Build metadata MAY be denoted by appending a plus sign and a series of dot separated
        /// identifiers immediately following the patch or pre-release version
        /// (<https://semver.org/#spec-item-10>); so given a semver 0.14.0-alpha.1+21AF26D3, this field
        /// would contain '21AF26D3'
        #[prost(string, tag = "5")]
        pub build: ::prost::alloc::string::String,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SemanticVersion {
        #[inline]
        fn clone(&self) -> SemanticVersion {
            match *self {
                SemanticVersion {
                    major: ref __self_0_0,
                    minor: ref __self_0_1,
                    patch: ref __self_0_2,
                    pre: ref __self_0_3,
                    build: ref __self_0_4,
                } => SemanticVersion {
                    major: ::core::clone::Clone::clone(&(*__self_0_0)),
                    minor: ::core::clone::Clone::clone(&(*__self_0_1)),
                    patch: ::core::clone::Clone::clone(&(*__self_0_2)),
                    pre: ::core::clone::Clone::clone(&(*__self_0_3)),
                    build: ::core::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for SemanticVersion {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for SemanticVersion {
        #[inline]
        fn eq(&self, other: &SemanticVersion) -> bool {
            match *other {
                SemanticVersion {
                    major: ref __self_1_0,
                    minor: ref __self_1_1,
                    patch: ref __self_1_2,
                    pre: ref __self_1_3,
                    build: ref __self_1_4,
                } => match *self {
                    SemanticVersion {
                        major: ref __self_0_0,
                        minor: ref __self_0_1,
                        patch: ref __self_0_2,
                        pre: ref __self_0_3,
                        build: ref __self_0_4,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &SemanticVersion) -> bool {
            match *other {
                SemanticVersion {
                    major: ref __self_1_0,
                    minor: ref __self_1_1,
                    patch: ref __self_1_2,
                    pre: ref __self_1_3,
                    build: ref __self_1_4,
                } => match *self {
                    SemanticVersion {
                        major: ref __self_0_0,
                        minor: ref __self_0_1,
                        patch: ref __self_0_2,
                        pre: ref __self_0_3,
                        build: ref __self_0_4,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                    }
                },
            }
        }
    }
    impl ::prost::Message for SemanticVersion {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.major != 0i32 {
                ::prost::encoding::int32::encode(1u32, &self.major, buf);
            }
            if self.minor != 0i32 {
                ::prost::encoding::int32::encode(2u32, &self.minor, buf);
            }
            if self.patch != 0i32 {
                ::prost::encoding::int32::encode(3u32, &self.patch, buf);
            }
            if self.pre != "" {
                ::prost::encoding::string::encode(4u32, &self.pre, buf);
            }
            if self.build != "" {
                ::prost::encoding::string::encode(5u32, &self.build, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "SemanticVersion";
            match tag {
                1u32 => {
                    let mut value = &mut self.major;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "major");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.minor;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "minor");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.patch;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "patch");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.pre;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "pre");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.build;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "build");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.major != 0i32 {
                ::prost::encoding::int32::encoded_len(1u32, &self.major)
            } else {
                0
            } + if self.minor != 0i32 {
                ::prost::encoding::int32::encoded_len(2u32, &self.minor)
            } else {
                0
            } + if self.patch != 0i32 {
                ::prost::encoding::int32::encoded_len(3u32, &self.patch)
            } else {
                0
            } + if self.pre != "" {
                ::prost::encoding::string::encoded_len(4u32, &self.pre)
            } else {
                0
            } + if self.build != "" {
                ::prost::encoding::string::encoded_len(5u32, &self.build)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.major = 0i32;
            self.minor = 0i32;
            self.patch = 0i32;
            self.pre.clear();
            self.build.clear();
        }
    }
    impl ::core::default::Default for SemanticVersion {
        fn default() -> Self {
            SemanticVersion {
                major: 0i32,
                minor: 0i32,
                patch: 0i32,
                pre: ::prost::alloc::string::String::new(),
                build: ::prost::alloc::string::String::new(),
            }
        }
    }
    impl ::core::fmt::Debug for SemanticVersion {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("SemanticVersion");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.major)
                };
                builder.field("major", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.minor)
                };
                builder.field("minor", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.patch)
                };
                builder.field("patch", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.pre)
                };
                builder.field("pre", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.build)
                };
                builder.field("build", &wrapper)
            };
            builder.finish()
        }
    }
    pub struct Setting {
        /// name of the property
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// value of the property
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
        /// any data associated with property
        #[prost(bytes = "vec", tag = "3")]
        pub data: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Setting {
        #[inline]
        fn clone(&self) -> Setting {
            match *self {
                Setting {
                    name: ref __self_0_0,
                    value: ref __self_0_1,
                    data: ref __self_0_2,
                } => Setting {
                    name: ::core::clone::Clone::clone(&(*__self_0_0)),
                    value: ::core::clone::Clone::clone(&(*__self_0_1)),
                    data: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Setting {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Setting {
        #[inline]
        fn eq(&self, other: &Setting) -> bool {
            match *other {
                Setting {
                    name: ref __self_1_0,
                    value: ref __self_1_1,
                    data: ref __self_1_2,
                } => match *self {
                    Setting {
                        name: ref __self_0_0,
                        value: ref __self_0_1,
                        data: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Setting) -> bool {
            match *other {
                Setting {
                    name: ref __self_1_0,
                    value: ref __self_1_1,
                    data: ref __self_1_2,
                } => match *self {
                    Setting {
                        name: ref __self_0_0,
                        value: ref __self_0_1,
                        data: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for Setting {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.name != "" {
                ::prost::encoding::string::encode(1u32, &self.name, buf);
            }
            if self.value != "" {
                ::prost::encoding::string::encode(2u32, &self.value, buf);
            }
            if self.data != b"" as &[u8] {
                ::prost::encoding::bytes::encode(3u32, &self.data, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Setting";
            match tag {
                1u32 => {
                    let mut value = &mut self.name;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "name");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.value;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "value");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.data;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "data");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.name != "" {
                ::prost::encoding::string::encoded_len(1u32, &self.name)
            } else {
                0
            } + if self.value != "" {
                ::prost::encoding::string::encoded_len(2u32, &self.value)
            } else {
                0
            } + if self.data != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(3u32, &self.data)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.name.clear();
            self.value.clear();
            self.data.clear();
        }
    }
    impl ::core::default::Default for Setting {
        fn default() -> Self {
            Setting {
                name: ::prost::alloc::string::String::new(),
                value: ::prost::alloc::string::String::new(),
                data: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for Setting {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Setting");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.name)
                };
                builder.field("name", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.value)
                };
                builder.field("value", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.data)
                };
                builder.field("data", &wrapper)
            };
            builder.finish()
        }
    }
    pub struct ServicesConfigurationList {
        /// list of name value pairs of the application properties
        #[prost(message, repeated, tag = "1")]
        pub name_value: ::prost::alloc::vec::Vec<Setting>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ServicesConfigurationList {
        #[inline]
        fn clone(&self) -> ServicesConfigurationList {
            match *self {
                ServicesConfigurationList {
                    name_value: ref __self_0_0,
                } => ServicesConfigurationList {
                    name_value: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ServicesConfigurationList {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ServicesConfigurationList {
        #[inline]
        fn eq(&self, other: &ServicesConfigurationList) -> bool {
            match *other {
                ServicesConfigurationList {
                    name_value: ref __self_1_0,
                } => match *self {
                    ServicesConfigurationList {
                        name_value: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ServicesConfigurationList) -> bool {
            match *other {
                ServicesConfigurationList {
                    name_value: ref __self_1_0,
                } => match *self {
                    ServicesConfigurationList {
                        name_value: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for ServicesConfigurationList {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.name_value {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ServicesConfigurationList";
            match tag {
                1u32 => {
                    let mut value = &mut self.name_value;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "name_value");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.name_value)
        }
        fn clear(&mut self) {
            self.name_value.clear();
        }
    }
    impl ::core::default::Default for ServicesConfigurationList {
        fn default() -> Self {
            ServicesConfigurationList {
                name_value: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ServicesConfigurationList {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ServicesConfigurationList");
            let builder = {
                let wrapper = &self.name_value;
                builder.field("name_value", &wrapper)
            };
            builder.finish()
        }
    }
    /// Token's information related to the given Account
    pub struct TokenRelationship {
        /// The ID of the token
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<TokenId>,
        /// The Symbol of the token
        #[prost(string, tag = "2")]
        pub symbol: ::prost::alloc::string::String,
        /// For token of type FUNGIBLE_COMMON - the balance that the Account holds in the smallest
        /// denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account
        #[prost(uint64, tag = "3")]
        pub balance: u64,
        /// The KYC status of the account (KycNotApplicable, Granted or Revoked). If the token does not
        /// have KYC key, KycNotApplicable is returned
        #[prost(enumeration = "TokenKycStatus", tag = "4")]
        pub kyc_status: i32,
        /// The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen). If the token does
        /// not have Freeze key, FreezeNotApplicable is returned
        #[prost(enumeration = "TokenFreezeStatus", tag = "5")]
        pub freeze_status: i32,
        /// Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
        #[prost(uint32, tag = "6")]
        pub decimals: u32,
        /// Specifies if the relationship is created implicitly. False : explicitly associated, True :
        /// implicitly associated.
        #[prost(bool, tag = "7")]
        pub automatic_association: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenRelationship {
        #[inline]
        fn clone(&self) -> TokenRelationship {
            match *self {
                TokenRelationship {
                    token_id: ref __self_0_0,
                    symbol: ref __self_0_1,
                    balance: ref __self_0_2,
                    kyc_status: ref __self_0_3,
                    freeze_status: ref __self_0_4,
                    decimals: ref __self_0_5,
                    automatic_association: ref __self_0_6,
                } => TokenRelationship {
                    token_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    symbol: ::core::clone::Clone::clone(&(*__self_0_1)),
                    balance: ::core::clone::Clone::clone(&(*__self_0_2)),
                    kyc_status: ::core::clone::Clone::clone(&(*__self_0_3)),
                    freeze_status: ::core::clone::Clone::clone(&(*__self_0_4)),
                    decimals: ::core::clone::Clone::clone(&(*__self_0_5)),
                    automatic_association: ::core::clone::Clone::clone(&(*__self_0_6)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenRelationship {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenRelationship {
        #[inline]
        fn eq(&self, other: &TokenRelationship) -> bool {
            match *other {
                TokenRelationship {
                    token_id: ref __self_1_0,
                    symbol: ref __self_1_1,
                    balance: ref __self_1_2,
                    kyc_status: ref __self_1_3,
                    freeze_status: ref __self_1_4,
                    decimals: ref __self_1_5,
                    automatic_association: ref __self_1_6,
                } => match *self {
                    TokenRelationship {
                        token_id: ref __self_0_0,
                        symbol: ref __self_0_1,
                        balance: ref __self_0_2,
                        kyc_status: ref __self_0_3,
                        freeze_status: ref __self_0_4,
                        decimals: ref __self_0_5,
                        automatic_association: ref __self_0_6,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenRelationship) -> bool {
            match *other {
                TokenRelationship {
                    token_id: ref __self_1_0,
                    symbol: ref __self_1_1,
                    balance: ref __self_1_2,
                    kyc_status: ref __self_1_3,
                    freeze_status: ref __self_1_4,
                    decimals: ref __self_1_5,
                    automatic_association: ref __self_1_6,
                } => match *self {
                    TokenRelationship {
                        token_id: ref __self_0_0,
                        symbol: ref __self_0_1,
                        balance: ref __self_0_2,
                        kyc_status: ref __self_0_3,
                        freeze_status: ref __self_0_4,
                        decimals: ref __self_0_5,
                        automatic_association: ref __self_0_6,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenRelationship {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.symbol != "" {
                ::prost::encoding::string::encode(2u32, &self.symbol, buf);
            }
            if self.balance != 0u64 {
                ::prost::encoding::uint64::encode(3u32, &self.balance, buf);
            }
            if self.kyc_status != TokenKycStatus::default() as i32 {
                ::prost::encoding::int32::encode(4u32, &self.kyc_status, buf);
            }
            if self.freeze_status != TokenFreezeStatus::default() as i32 {
                ::prost::encoding::int32::encode(5u32, &self.freeze_status, buf);
            }
            if self.decimals != 0u32 {
                ::prost::encoding::uint32::encode(6u32, &self.decimals, buf);
            }
            if self.automatic_association != false {
                ::prost::encoding::bool::encode(7u32, &self.automatic_association, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenRelationship";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.symbol;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "symbol");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.balance;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "balance");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.kyc_status;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "kyc_status");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.freeze_status;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "freeze_status");
                            error
                        },
                    )
                }
                6u32 => {
                    let mut value = &mut self.decimals;
                    ::prost::encoding::uint32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "decimals");
                            error
                        },
                    )
                }
                7u32 => {
                    let mut value = &mut self.automatic_association;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "automatic_association");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.symbol != "" {
                    ::prost::encoding::string::encoded_len(2u32, &self.symbol)
                } else {
                    0
                }
                + if self.balance != 0u64 {
                    ::prost::encoding::uint64::encoded_len(3u32, &self.balance)
                } else {
                    0
                }
                + if self.kyc_status != TokenKycStatus::default() as i32 {
                    ::prost::encoding::int32::encoded_len(4u32, &self.kyc_status)
                } else {
                    0
                }
                + if self.freeze_status != TokenFreezeStatus::default() as i32 {
                    ::prost::encoding::int32::encoded_len(5u32, &self.freeze_status)
                } else {
                    0
                }
                + if self.decimals != 0u32 {
                    ::prost::encoding::uint32::encoded_len(6u32, &self.decimals)
                } else {
                    0
                }
                + if self.automatic_association != false {
                    ::prost::encoding::bool::encoded_len(7u32, &self.automatic_association)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.token_id = ::core::option::Option::None;
            self.symbol.clear();
            self.balance = 0u64;
            self.kyc_status = TokenKycStatus::default() as i32;
            self.freeze_status = TokenFreezeStatus::default() as i32;
            self.decimals = 0u32;
            self.automatic_association = false;
        }
    }
    impl ::core::default::Default for TokenRelationship {
        fn default() -> Self {
            TokenRelationship {
                token_id: ::core::default::Default::default(),
                symbol: ::prost::alloc::string::String::new(),
                balance: 0u64,
                kyc_status: TokenKycStatus::default() as i32,
                freeze_status: TokenFreezeStatus::default() as i32,
                decimals: 0u32,
                automatic_association: false,
            }
        }
    }
    impl ::core::fmt::Debug for TokenRelationship {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenRelationship");
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.symbol)
                };
                builder.field("symbol", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.balance)
                };
                builder.field("balance", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match TokenKycStatus::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.kyc_status)
                };
                builder.field("kyc_status", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match TokenFreezeStatus::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.freeze_status)
                };
                builder.field("freeze_status", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.decimals)
                };
                builder.field("decimals", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.automatic_association)
                };
                builder.field("automatic_association", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl TokenRelationship {
        ///Returns the enum value of `kyc_status`, or the default if the field is set to an invalid enum value.
        pub fn kyc_status(&self) -> TokenKycStatus {
            TokenKycStatus::from_i32(self.kyc_status).unwrap_or(TokenKycStatus::default())
        }
        ///Sets `kyc_status` to the provided enum value.
        pub fn set_kyc_status(&mut self, value: TokenKycStatus) {
            self.kyc_status = value as i32;
        }
        ///Returns the enum value of `freeze_status`, or the default if the field is set to an invalid enum value.
        pub fn freeze_status(&self) -> TokenFreezeStatus {
            TokenFreezeStatus::from_i32(self.freeze_status).unwrap_or(TokenFreezeStatus::default())
        }
        ///Sets `freeze_status` to the provided enum value.
        pub fn set_freeze_status(&mut self, value: TokenFreezeStatus) {
            self.freeze_status = value as i32;
        }
    }
    /// A number of <i>transferable units</i> of a certain token.
    ///
    /// The transferable unit of a token is its smallest denomination, as given by the token's
    /// <tt>decimals</tt> property---each minted token contains <tt>10<sup>decimals</sup></tt>
    /// transferable units. For example, we could think of the cent as the transferable unit of the US
    /// dollar (<tt>decimals=2</tt>); and the tinybar as the transferable unit of hbar
    /// (<tt>decimals=8</tt>).
    ///
    /// Transferable units are not directly comparable across different tokens.
    pub struct TokenBalance {
        /// A unique token id
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<TokenId>,
        /// Number of transferable units of the identified token. For token of type FUNGIBLE_COMMON -
        /// balance in the smallest denomination. For token of type NON_FUNGIBLE_UNIQUE - the number of
        /// NFTs held by the account
        #[prost(uint64, tag = "2")]
        pub balance: u64,
        /// Tokens divide into <tt>10<sup>decimals</sup></tt> pieces
        #[prost(uint32, tag = "3")]
        pub decimals: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenBalance {
        #[inline]
        fn clone(&self) -> TokenBalance {
            {
                let _: ::core::clone::AssertParamIsClone<::core::option::Option<TokenId>>;
                let _: ::core::clone::AssertParamIsClone<u64>;
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenBalance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenBalance {
        #[inline]
        fn eq(&self, other: &TokenBalance) -> bool {
            match *other {
                TokenBalance {
                    token_id: ref __self_1_0,
                    balance: ref __self_1_1,
                    decimals: ref __self_1_2,
                } => match *self {
                    TokenBalance {
                        token_id: ref __self_0_0,
                        balance: ref __self_0_1,
                        decimals: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenBalance) -> bool {
            match *other {
                TokenBalance {
                    token_id: ref __self_1_0,
                    balance: ref __self_1_1,
                    decimals: ref __self_1_2,
                } => match *self {
                    TokenBalance {
                        token_id: ref __self_0_0,
                        balance: ref __self_0_1,
                        decimals: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenBalance {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.balance != 0u64 {
                ::prost::encoding::uint64::encode(2u32, &self.balance, buf);
            }
            if self.decimals != 0u32 {
                ::prost::encoding::uint32::encode(3u32, &self.decimals, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenBalance";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.balance;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "balance");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.decimals;
                    ::prost::encoding::uint32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "decimals");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.balance != 0u64 {
                    ::prost::encoding::uint64::encoded_len(2u32, &self.balance)
                } else {
                    0
                }
                + if self.decimals != 0u32 {
                    ::prost::encoding::uint32::encoded_len(3u32, &self.decimals)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.token_id = ::core::option::Option::None;
            self.balance = 0u64;
            self.decimals = 0u32;
        }
    }
    impl ::core::default::Default for TokenBalance {
        fn default() -> Self {
            TokenBalance {
                token_id: ::core::default::Default::default(),
                balance: 0u64,
                decimals: 0u32,
            }
        }
    }
    impl ::core::fmt::Debug for TokenBalance {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenBalance");
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.balance)
                };
                builder.field("balance", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.decimals)
                };
                builder.field("decimals", &wrapper)
            };
            builder.finish()
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TokenBalance {}
    impl ::core::marker::StructuralEq for TokenBalance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenBalance {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<TokenId>>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<u32>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for TokenBalance {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                TokenBalance {
                    token_id: ref __self_0_0,
                    balance: ref __self_0_1,
                    decimals: ref __self_0_2,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state)
                }
            }
        }
    }
    /// A sequence of token balances
    pub struct TokenBalances {
        #[prost(message, repeated, tag = "1")]
        pub token_balances: ::prost::alloc::vec::Vec<TokenBalance>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenBalances {
        #[inline]
        fn clone(&self) -> TokenBalances {
            match *self {
                TokenBalances {
                    token_balances: ref __self_0_0,
                } => TokenBalances {
                    token_balances: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenBalances {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenBalances {
        #[inline]
        fn eq(&self, other: &TokenBalances) -> bool {
            match *other {
                TokenBalances {
                    token_balances: ref __self_1_0,
                } => match *self {
                    TokenBalances {
                        token_balances: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenBalances) -> bool {
            match *other {
                TokenBalances {
                    token_balances: ref __self_1_0,
                } => match *self {
                    TokenBalances {
                        token_balances: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for TokenBalances {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.token_balances {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenBalances";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_balances;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "token_balances");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.token_balances)
        }
        fn clear(&mut self) {
            self.token_balances.clear();
        }
    }
    impl ::core::default::Default for TokenBalances {
        fn default() -> Self {
            TokenBalances {
                token_balances: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenBalances {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenBalances");
            let builder = {
                let wrapper = &self.token_balances;
                builder.field("token_balances", &wrapper)
            };
            builder.finish()
        }
    }
    /// A token - account association
    pub struct TokenAssociation {
        /// The token involved in the association
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<TokenId>,
        /// The account involved in the association
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenAssociation {
        #[inline]
        fn clone(&self) -> TokenAssociation {
            match *self {
                TokenAssociation {
                    token_id: ref __self_0_0,
                    account_id: ref __self_0_1,
                } => TokenAssociation {
                    token_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenAssociation {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenAssociation {
        #[inline]
        fn eq(&self, other: &TokenAssociation) -> bool {
            match *other {
                TokenAssociation {
                    token_id: ref __self_1_0,
                    account_id: ref __self_1_1,
                } => match *self {
                    TokenAssociation {
                        token_id: ref __self_0_0,
                        account_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenAssociation) -> bool {
            match *other {
                TokenAssociation {
                    token_id: ref __self_1_0,
                    account_id: ref __self_1_1,
                } => match *self {
                    TokenAssociation {
                        token_id: ref __self_0_0,
                        account_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenAssociation {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenAssociation";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.token_id = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenAssociation {
        fn default() -> Self {
            TokenAssociation {
                token_id: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenAssociation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenAssociation");
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for TokenAssociation {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenAssociation {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<TokenId>>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<AccountId>>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for TokenAssociation {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                TokenAssociation {
                    token_id: ref __self_0_0,
                    account_id: ref __self_0_1,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state)
                }
            }
        }
    }
    /// Staking metadata for an account or a contract returned in CryptoGetInfo or ContractGetInfo queries
    pub struct StakingInfo {
        /// If true, this account or contract declined to receive a staking reward.
        #[prost(bool, tag = "1")]
        pub decline_reward: bool,
        /// The staking period during which either the staking settings for this account or contract changed (such as starting
        /// staking or changing staked_node_id) or the most recent reward was earned, whichever is later. If this account or contract
        /// is not currently staked to a node, then this field is not set.
        #[prost(message, optional, tag = "2")]
        pub stake_period_start: ::core::option::Option<Timestamp>,
        /// The amount in tinybars that will be received in the next reward situation.
        #[prost(int64, tag = "3")]
        pub pending_reward: i64,
        /// The total of balance of all accounts staked to this account or contract.
        #[prost(int64, tag = "4")]
        pub staked_to_me: i64,
        /// ID of the account or node to which this account or contract is staking.
        #[prost(oneof = "staking_info::StakedId", tags = "5, 6")]
        pub staked_id: ::core::option::Option<staking_info::StakedId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StakingInfo {
        #[inline]
        fn clone(&self) -> StakingInfo {
            match *self {
                StakingInfo {
                    decline_reward: ref __self_0_0,
                    stake_period_start: ref __self_0_1,
                    pending_reward: ref __self_0_2,
                    staked_to_me: ref __self_0_3,
                    staked_id: ref __self_0_4,
                } => StakingInfo {
                    decline_reward: ::core::clone::Clone::clone(&(*__self_0_0)),
                    stake_period_start: ::core::clone::Clone::clone(&(*__self_0_1)),
                    pending_reward: ::core::clone::Clone::clone(&(*__self_0_2)),
                    staked_to_me: ::core::clone::Clone::clone(&(*__self_0_3)),
                    staked_id: ::core::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for StakingInfo {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StakingInfo {
        #[inline]
        fn eq(&self, other: &StakingInfo) -> bool {
            match *other {
                StakingInfo {
                    decline_reward: ref __self_1_0,
                    stake_period_start: ref __self_1_1,
                    pending_reward: ref __self_1_2,
                    staked_to_me: ref __self_1_3,
                    staked_id: ref __self_1_4,
                } => match *self {
                    StakingInfo {
                        decline_reward: ref __self_0_0,
                        stake_period_start: ref __self_0_1,
                        pending_reward: ref __self_0_2,
                        staked_to_me: ref __self_0_3,
                        staked_id: ref __self_0_4,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &StakingInfo) -> bool {
            match *other {
                StakingInfo {
                    decline_reward: ref __self_1_0,
                    stake_period_start: ref __self_1_1,
                    pending_reward: ref __self_1_2,
                    staked_to_me: ref __self_1_3,
                    staked_id: ref __self_1_4,
                } => match *self {
                    StakingInfo {
                        decline_reward: ref __self_0_0,
                        stake_period_start: ref __self_0_1,
                        pending_reward: ref __self_0_2,
                        staked_to_me: ref __self_0_3,
                        staked_id: ref __self_0_4,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                    }
                },
            }
        }
    }
    impl ::prost::Message for StakingInfo {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.decline_reward != false {
                ::prost::encoding::bool::encode(1u32, &self.decline_reward, buf);
            }
            if let Some(ref msg) = self.stake_period_start {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.pending_reward != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.pending_reward, buf);
            }
            if self.staked_to_me != 0i64 {
                ::prost::encoding::int64::encode(4u32, &self.staked_to_me, buf);
            }
            if let Some(ref oneof) = self.staked_id {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "StakingInfo";
            match tag {
                1u32 => {
                    let mut value = &mut self.decline_reward;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "decline_reward");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.stake_period_start;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "stake_period_start");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.pending_reward;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "pending_reward");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.staked_to_me;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "staked_to_me");
                            error
                        },
                    )
                }
                5u32 | 6u32 => {
                    let mut value = &mut self.staked_id;
                    staking_info::StakedId::merge(value, tag, wire_type, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "staked_id");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.decline_reward != false {
                ::prost::encoding::bool::encoded_len(1u32, &self.decline_reward)
            } else {
                0
            } + self
                .stake_period_start
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.pending_reward != 0i64 {
                    ::prost::encoding::int64::encoded_len(3u32, &self.pending_reward)
                } else {
                    0
                }
                + if self.staked_to_me != 0i64 {
                    ::prost::encoding::int64::encoded_len(4u32, &self.staked_to_me)
                } else {
                    0
                }
                + self
                    .staked_id
                    .as_ref()
                    .map_or(0, staking_info::StakedId::encoded_len)
        }
        fn clear(&mut self) {
            self.decline_reward = false;
            self.stake_period_start = ::core::option::Option::None;
            self.pending_reward = 0i64;
            self.staked_to_me = 0i64;
            self.staked_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for StakingInfo {
        fn default() -> Self {
            StakingInfo {
                decline_reward: false,
                stake_period_start: ::core::default::Default::default(),
                pending_reward: 0i64,
                staked_to_me: 0i64,
                staked_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for StakingInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("StakingInfo");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.decline_reward)
                };
                builder.field("decline_reward", &wrapper)
            };
            let builder = {
                let wrapper = &self.stake_period_start;
                builder.field("stake_period_start", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.pending_reward)
                };
                builder.field("pending_reward", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.staked_to_me)
                };
                builder.field("staked_to_me", &wrapper)
            };
            let builder = {
                let wrapper = &self.staked_id;
                builder.field("staked_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `StakingInfo`.
    pub mod staking_info {
        /// ID of the account or node to which this account or contract is staking.
        pub enum StakedId {
            /// The account to which this account or contract is staking.
            #[prost(message, tag = "5")]
            StakedAccountId(super::AccountId),
            /// The ID of the node this account or contract is staked to.
            #[prost(int64, tag = "6")]
            StakedNodeId(i64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StakedId {
            #[inline]
            fn clone(&self) -> StakedId {
                match (&*self,) {
                    (&StakedId::StakedAccountId(ref __self_0),) => {
                        StakedId::StakedAccountId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&StakedId::StakedNodeId(ref __self_0),) => {
                        StakedId::StakedNodeId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for StakedId {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for StakedId {
            #[inline]
            fn eq(&self, other: &StakedId) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StakedId::StakedAccountId(ref __self_0),
                                &StakedId::StakedAccountId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &StakedId::StakedNodeId(ref __self_0),
                                &StakedId::StakedNodeId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &StakedId) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StakedId::StakedAccountId(ref __self_0),
                                &StakedId::StakedAccountId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &StakedId::StakedNodeId(ref __self_0),
                                &StakedId::StakedNodeId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl StakedId {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        ::prost::encoding::message::encode(5u32, &*value, buf);
                    }
                    StakedId::StakedNodeId(ref value) => {
                        ::prost::encoding::int64::encode(6u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<StakedId>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    5u32 => match field {
                        ::core::option::Option::Some(StakedId::StakedAccountId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        StakedId::StakedAccountId(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    6u32 => match field {
                        ::core::option::Option::Some(StakedId::StakedNodeId(ref mut value)) => {
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map(|_| {
                                *field = ::core::option::Option::Some(StakedId::StakedNodeId(
                                    owned_value,
                                ))
                            })
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid StakedId tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        ::prost::encoding::message::encoded_len(5u32, &*value)
                    }
                    StakedId::StakedNodeId(ref value) => {
                        ::prost::encoding::int64::encoded_len(6u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for StakedId {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("StakedAccountId").field(&wrapper).finish()
                    }
                    StakedId::StakedNodeId(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("StakedNodeId").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// Possible Token Types (IWA Compatibility).
    /// Apart from fungible and non-fungible, Tokens can have either a common or unique representation.
    /// This distinction might seem subtle, but it is important when considering how tokens can be traced
    /// and if they can have isolated and unique properties.
    #[repr(i32)]
    pub enum TokenType {
        /// Interchangeable value with one another, where any quantity of them has the same value as
        /// another equal quantity if they are in the same class.  Share a single set of properties, not
        /// distinct from one another. Simply represented as a balance or quantity to a given Hedera
        /// account.
        FungibleCommon = 0,
        /// Unique, not interchangeable with other tokens of the same type as they typically have
        /// different values.  Individually traced and can carry unique properties (e.g. serial number).
        NonFungibleUnique = 1,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenType {
        #[inline]
        fn clone(&self) -> TokenType {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TokenType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TokenType::FungibleCommon,) => {
                    ::core::fmt::Formatter::write_str(f, "FungibleCommon")
                }
                (&TokenType::NonFungibleUnique,) => {
                    ::core::fmt::Formatter::write_str(f, "NonFungibleUnique")
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenType {
        #[inline]
        fn eq(&self, other: &TokenType) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for TokenType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for TokenType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TokenType {
        #[inline]
        fn partial_cmp(&self, other: &TokenType) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for TokenType {
        #[inline]
        fn cmp(&self, other: &TokenType) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    impl TokenType {
        ///Returns `true` if `value` is a variant of `TokenType`.
        pub fn is_valid(value: i32) -> bool {
            match value {
                0 => true,
                1 => true,
                _ => false,
            }
        }
        ///Converts an `i32` to a `TokenType`, or `None` if `value` is not a valid variant.
        pub fn from_i32(value: i32) -> ::core::option::Option<TokenType> {
            match value {
                0 => ::core::option::Option::Some(TokenType::FungibleCommon),
                1 => ::core::option::Option::Some(TokenType::NonFungibleUnique),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for TokenType {
        fn default() -> TokenType {
            TokenType::FungibleCommon
        }
    }
    impl ::core::convert::From<TokenType> for i32 {
        fn from(value: TokenType) -> i32 {
            value as i32
        }
    }
    /// Allows a set of resource prices to be scoped to a certain type of a HAPI operation.
    ///
    /// For example, the resource prices for a TokenMint operation are different between minting fungible
    /// and non-fungible tokens. This enum allows us to "mark" a set of prices as applying to one or the
    /// other.
    ///
    /// Similarly, the resource prices for a basic TokenCreate without a custom fee schedule yield a
    /// total price of $1. The resource prices for a TokenCreate with a custom fee schedule are different
    /// and yield a total base price of $2.
    #[repr(i32)]
    pub enum SubType {
        /// The resource prices have no special scope
        Default = 0,
        /// The resource prices are scoped to an operation on a fungible common token
        TokenFungibleCommon = 1,
        /// The resource prices are scoped to an operation on a non-fungible unique token
        TokenNonFungibleUnique = 2,
        /// The resource prices are scoped to an operation on a fungible common
        /// token with a custom fee schedule
        TokenFungibleCommonWithCustomFees = 3,
        /// The resource prices are scoped to an operation on a non-fungible unique
        /// token with a custom fee schedule
        TokenNonFungibleUniqueWithCustomFees = 4,
        /// The resource prices are scoped to a ScheduleCreate containing a ContractCall.
        ScheduleCreateContractCall = 5,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SubType {
        #[inline]
        fn clone(&self) -> SubType {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for SubType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for SubType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&SubType::Default,) => ::core::fmt::Formatter::write_str(f, "Default"),
                (&SubType::TokenFungibleCommon,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenFungibleCommon")
                }
                (&SubType::TokenNonFungibleUnique,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenNonFungibleUnique")
                }
                (&SubType::TokenFungibleCommonWithCustomFees,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenFungibleCommonWithCustomFees")
                }
                (&SubType::TokenNonFungibleUniqueWithCustomFees,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenNonFungibleUniqueWithCustomFees")
                }
                (&SubType::ScheduleCreateContractCall,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduleCreateContractCall")
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for SubType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for SubType {
        #[inline]
        fn eq(&self, other: &SubType) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for SubType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for SubType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for SubType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for SubType {
        #[inline]
        fn partial_cmp(&self, other: &SubType) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for SubType {
        #[inline]
        fn cmp(&self, other: &SubType) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    impl SubType {
        ///Returns `true` if `value` is a variant of `SubType`.
        pub fn is_valid(value: i32) -> bool {
            match value {
                0 => true,
                1 => true,
                2 => true,
                3 => true,
                4 => true,
                5 => true,
                _ => false,
            }
        }
        ///Converts an `i32` to a `SubType`, or `None` if `value` is not a valid variant.
        pub fn from_i32(value: i32) -> ::core::option::Option<SubType> {
            match value {
                0 => ::core::option::Option::Some(SubType::Default),
                1 => ::core::option::Option::Some(SubType::TokenFungibleCommon),
                2 => ::core::option::Option::Some(SubType::TokenNonFungibleUnique),
                3 => ::core::option::Option::Some(SubType::TokenFungibleCommonWithCustomFees),
                4 => ::core::option::Option::Some(SubType::TokenNonFungibleUniqueWithCustomFees),
                5 => ::core::option::Option::Some(SubType::ScheduleCreateContractCall),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for SubType {
        fn default() -> SubType {
            SubType::Default
        }
    }
    impl ::core::convert::From<SubType> for i32 {
        fn from(value: SubType) -> i32 {
            value as i32
        }
    }
    /// Possible Token Supply Types (IWA Compatibility).
    /// Indicates how many tokens can have during its lifetime.
    #[repr(i32)]
    pub enum TokenSupplyType {
        /// Indicates that tokens of that type have an upper bound of Long.MAX_VALUE.
        Infinite = 0,
        /// Indicates that tokens of that type have an upper bound of maxSupply,
        /// provided on token creation.
        Finite = 1,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenSupplyType {
        #[inline]
        fn clone(&self) -> TokenSupplyType {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TokenSupplyType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenSupplyType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TokenSupplyType::Infinite,) => ::core::fmt::Formatter::write_str(f, "Infinite"),
                (&TokenSupplyType::Finite,) => ::core::fmt::Formatter::write_str(f, "Finite"),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenSupplyType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenSupplyType {
        #[inline]
        fn eq(&self, other: &TokenSupplyType) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for TokenSupplyType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenSupplyType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for TokenSupplyType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TokenSupplyType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TokenSupplyType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for TokenSupplyType {
        #[inline]
        fn cmp(&self, other: &TokenSupplyType) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    impl TokenSupplyType {
        ///Returns `true` if `value` is a variant of `TokenSupplyType`.
        pub fn is_valid(value: i32) -> bool {
            match value {
                0 => true,
                1 => true,
                _ => false,
            }
        }
        ///Converts an `i32` to a `TokenSupplyType`, or `None` if `value` is not a valid variant.
        pub fn from_i32(value: i32) -> ::core::option::Option<TokenSupplyType> {
            match value {
                0 => ::core::option::Option::Some(TokenSupplyType::Infinite),
                1 => ::core::option::Option::Some(TokenSupplyType::Finite),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for TokenSupplyType {
        fn default() -> TokenSupplyType {
            TokenSupplyType::Infinite
        }
    }
    impl ::core::convert::From<TokenSupplyType> for i32 {
        fn from(value: TokenSupplyType) -> i32 {
            value as i32
        }
    }
    /// Possible Freeze statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in
    /// TokenRelationship
    #[repr(i32)]
    pub enum TokenFreezeStatus {
        FreezeNotApplicable = 0,
        Frozen = 1,
        Unfrozen = 2,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenFreezeStatus {
        #[inline]
        fn clone(&self) -> TokenFreezeStatus {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TokenFreezeStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenFreezeStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TokenFreezeStatus::FreezeNotApplicable,) => {
                    ::core::fmt::Formatter::write_str(f, "FreezeNotApplicable")
                }
                (&TokenFreezeStatus::Frozen,) => ::core::fmt::Formatter::write_str(f, "Frozen"),
                (&TokenFreezeStatus::Unfrozen,) => ::core::fmt::Formatter::write_str(f, "Unfrozen"),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenFreezeStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenFreezeStatus {
        #[inline]
        fn eq(&self, other: &TokenFreezeStatus) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for TokenFreezeStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenFreezeStatus {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for TokenFreezeStatus {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TokenFreezeStatus {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TokenFreezeStatus,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for TokenFreezeStatus {
        #[inline]
        fn cmp(&self, other: &TokenFreezeStatus) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    impl TokenFreezeStatus {
        ///Returns `true` if `value` is a variant of `TokenFreezeStatus`.
        pub fn is_valid(value: i32) -> bool {
            match value {
                0 => true,
                1 => true,
                2 => true,
                _ => false,
            }
        }
        ///Converts an `i32` to a `TokenFreezeStatus`, or `None` if `value` is not a valid variant.
        pub fn from_i32(value: i32) -> ::core::option::Option<TokenFreezeStatus> {
            match value {
                0 => ::core::option::Option::Some(TokenFreezeStatus::FreezeNotApplicable),
                1 => ::core::option::Option::Some(TokenFreezeStatus::Frozen),
                2 => ::core::option::Option::Some(TokenFreezeStatus::Unfrozen),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for TokenFreezeStatus {
        fn default() -> TokenFreezeStatus {
            TokenFreezeStatus::FreezeNotApplicable
        }
    }
    impl ::core::convert::From<TokenFreezeStatus> for i32 {
        fn from(value: TokenFreezeStatus) -> i32 {
            value as i32
        }
    }
    /// Possible KYC statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in TokenRelationship
    #[repr(i32)]
    pub enum TokenKycStatus {
        KycNotApplicable = 0,
        Granted = 1,
        Revoked = 2,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenKycStatus {
        #[inline]
        fn clone(&self) -> TokenKycStatus {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TokenKycStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenKycStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TokenKycStatus::KycNotApplicable,) => {
                    ::core::fmt::Formatter::write_str(f, "KycNotApplicable")
                }
                (&TokenKycStatus::Granted,) => ::core::fmt::Formatter::write_str(f, "Granted"),
                (&TokenKycStatus::Revoked,) => ::core::fmt::Formatter::write_str(f, "Revoked"),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenKycStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenKycStatus {
        #[inline]
        fn eq(&self, other: &TokenKycStatus) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for TokenKycStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenKycStatus {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for TokenKycStatus {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TokenKycStatus {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TokenKycStatus,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for TokenKycStatus {
        #[inline]
        fn cmp(&self, other: &TokenKycStatus) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    impl TokenKycStatus {
        ///Returns `true` if `value` is a variant of `TokenKycStatus`.
        pub fn is_valid(value: i32) -> bool {
            match value {
                0 => true,
                1 => true,
                2 => true,
                _ => false,
            }
        }
        ///Converts an `i32` to a `TokenKycStatus`, or `None` if `value` is not a valid variant.
        pub fn from_i32(value: i32) -> ::core::option::Option<TokenKycStatus> {
            match value {
                0 => ::core::option::Option::Some(TokenKycStatus::KycNotApplicable),
                1 => ::core::option::Option::Some(TokenKycStatus::Granted),
                2 => ::core::option::Option::Some(TokenKycStatus::Revoked),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for TokenKycStatus {
        fn default() -> TokenKycStatus {
            TokenKycStatus::KycNotApplicable
        }
    }
    impl ::core::convert::From<TokenKycStatus> for i32 {
        fn from(value: TokenKycStatus) -> i32 {
            value as i32
        }
    }
    /// Possible Pause statuses returned on TokenGetInfoQuery
    #[repr(i32)]
    pub enum TokenPauseStatus {
        /// Indicates that a Token has no pauseKey
        PauseNotApplicable = 0,
        /// Indicates that a Token is Paused
        Paused = 1,
        /// Indicates that a Token is Unpaused.
        Unpaused = 2,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenPauseStatus {
        #[inline]
        fn clone(&self) -> TokenPauseStatus {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TokenPauseStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenPauseStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TokenPauseStatus::PauseNotApplicable,) => {
                    ::core::fmt::Formatter::write_str(f, "PauseNotApplicable")
                }
                (&TokenPauseStatus::Paused,) => ::core::fmt::Formatter::write_str(f, "Paused"),
                (&TokenPauseStatus::Unpaused,) => ::core::fmt::Formatter::write_str(f, "Unpaused"),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenPauseStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenPauseStatus {
        #[inline]
        fn eq(&self, other: &TokenPauseStatus) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for TokenPauseStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenPauseStatus {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for TokenPauseStatus {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for TokenPauseStatus {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TokenPauseStatus,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for TokenPauseStatus {
        #[inline]
        fn cmp(&self, other: &TokenPauseStatus) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    impl TokenPauseStatus {
        ///Returns `true` if `value` is a variant of `TokenPauseStatus`.
        pub fn is_valid(value: i32) -> bool {
            match value {
                0 => true,
                1 => true,
                2 => true,
                _ => false,
            }
        }
        ///Converts an `i32` to a `TokenPauseStatus`, or `None` if `value` is not a valid variant.
        pub fn from_i32(value: i32) -> ::core::option::Option<TokenPauseStatus> {
            match value {
                0 => ::core::option::Option::Some(TokenPauseStatus::PauseNotApplicable),
                1 => ::core::option::Option::Some(TokenPauseStatus::Paused),
                2 => ::core::option::Option::Some(TokenPauseStatus::Unpaused),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for TokenPauseStatus {
        fn default() -> TokenPauseStatus {
            TokenPauseStatus::PauseNotApplicable
        }
    }
    impl ::core::convert::From<TokenPauseStatus> for i32 {
        fn from(value: TokenPauseStatus) -> i32 {
            value as i32
        }
    }
    /// The transactions and queries supported by Hedera Hashgraph.
    #[repr(i32)]
    pub enum HederaFunctionality {
        /// UNSPECIFIED - Need to keep first value as unspecified because first element is ignored and
        /// not parsed (0 is ignored by parser)
        None = 0,
        /// crypto transfer
        CryptoTransfer = 1,
        /// crypto update account
        CryptoUpdate = 2,
        /// crypto delete account
        CryptoDelete = 3,
        /// Add a livehash to a crypto account
        CryptoAddLiveHash = 4,
        /// Delete a livehash from a crypto account
        CryptoDeleteLiveHash = 5,
        /// Smart Contract Call
        ContractCall = 6,
        /// Smart Contract Create Contract
        ContractCreate = 7,
        /// Smart Contract update contract
        ContractUpdate = 8,
        /// File Operation create file
        FileCreate = 9,
        /// File Operation append file
        FileAppend = 10,
        /// File Operation update file
        FileUpdate = 11,
        /// File Operation delete file
        FileDelete = 12,
        /// crypto get account balance
        CryptoGetAccountBalance = 13,
        /// crypto get account record
        CryptoGetAccountRecords = 14,
        /// Crypto get info
        CryptoGetInfo = 15,
        /// Smart Contract Call
        ContractCallLocal = 16,
        /// Smart Contract get info
        ContractGetInfo = 17,
        /// Smart Contract, get the runtime code
        ContractGetBytecode = 18,
        /// Smart Contract, get by solidity ID
        GetBySolidityId = 19,
        /// Smart Contract, get by key
        GetByKey = 20,
        /// Get a live hash from a crypto account
        CryptoGetLiveHash = 21,
        /// Crypto, get the stakers for the node
        CryptoGetStakers = 22,
        /// File Operations get file contents
        FileGetContents = 23,
        /// File Operations get the info of the file
        FileGetInfo = 24,
        /// Crypto get the transaction records
        TransactionGetRecord = 25,
        /// Contract get the transaction records
        ContractGetRecords = 26,
        /// crypto create account
        CryptoCreate = 27,
        /// system delete file
        SystemDelete = 28,
        /// system undelete file
        SystemUndelete = 29,
        /// delete contract
        ContractDelete = 30,
        /// freeze
        Freeze = 31,
        /// Create Tx Record
        CreateTransactionRecord = 32,
        /// Crypto Auto Renew
        CryptoAccountAutoRenew = 33,
        /// Contract Auto Renew
        ContractAutoRenew = 34,
        /// Get Version
        GetVersionInfo = 35,
        /// Transaction Get Receipt
        TransactionGetReceipt = 36,
        /// Create Topic
        ConsensusCreateTopic = 50,
        /// Update Topic
        ConsensusUpdateTopic = 51,
        /// Delete Topic
        ConsensusDeleteTopic = 52,
        /// Get Topic information
        ConsensusGetTopicInfo = 53,
        /// Submit message to topic
        ConsensusSubmitMessage = 54,
        UncheckedSubmit = 55,
        /// Create Token
        TokenCreate = 56,
        /// Get Token information
        TokenGetInfo = 58,
        /// Freeze Account
        TokenFreezeAccount = 59,
        /// Unfreeze Account
        TokenUnfreezeAccount = 60,
        /// Grant KYC to Account
        TokenGrantKycToAccount = 61,
        /// Revoke KYC from Account
        TokenRevokeKycFromAccount = 62,
        /// Delete Token
        TokenDelete = 63,
        /// Update Token
        TokenUpdate = 64,
        /// Mint tokens to treasury
        TokenMint = 65,
        /// Burn tokens from treasury
        TokenBurn = 66,
        /// Wipe token amount from Account holder
        TokenAccountWipe = 67,
        /// Associate tokens to an account
        TokenAssociateToAccount = 68,
        /// Dissociate tokens from an account
        TokenDissociateFromAccount = 69,
        /// Create Scheduled Transaction
        ScheduleCreate = 70,
        /// Delete Scheduled Transaction
        ScheduleDelete = 71,
        /// Sign Scheduled Transaction
        ScheduleSign = 72,
        /// Get Scheduled Transaction Information
        ScheduleGetInfo = 73,
        /// Get Token Account Nft Information
        TokenGetAccountNftInfos = 74,
        /// Get Token Nft Information
        TokenGetNftInfo = 75,
        /// Get Token Nft List Information
        TokenGetNftInfos = 76,
        /// Update a token's custom fee schedule, if permissible
        TokenFeeScheduleUpdate = 77,
        /// Get execution time(s) by TransactionID, if available
        NetworkGetExecutionTime = 78,
        /// Pause the Token
        TokenPause = 79,
        /// Unpause the Token
        TokenUnpause = 80,
        /// Approve allowance for a spender relative to the owner account
        CryptoApproveAllowance = 81,
        /// Deletes granted allowances on owner account
        CryptoDeleteAllowance = 82,
        /// Gets all the information about an account, including balance and allowances. This does not get the list of
        /// account records.
        GetAccountDetails = 83,
        /// Ethereum Transaction
        EthereumTransaction = 84,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for HederaFunctionality {
        #[inline]
        fn clone(&self) -> HederaFunctionality {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for HederaFunctionality {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for HederaFunctionality {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&HederaFunctionality::None,) => ::core::fmt::Formatter::write_str(f, "None"),
                (&HederaFunctionality::CryptoTransfer,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoTransfer")
                }
                (&HederaFunctionality::CryptoUpdate,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoUpdate")
                }
                (&HederaFunctionality::CryptoDelete,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoDelete")
                }
                (&HederaFunctionality::CryptoAddLiveHash,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoAddLiveHash")
                }
                (&HederaFunctionality::CryptoDeleteLiveHash,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoDeleteLiveHash")
                }
                (&HederaFunctionality::ContractCall,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractCall")
                }
                (&HederaFunctionality::ContractCreate,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractCreate")
                }
                (&HederaFunctionality::ContractUpdate,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractUpdate")
                }
                (&HederaFunctionality::FileCreate,) => {
                    ::core::fmt::Formatter::write_str(f, "FileCreate")
                }
                (&HederaFunctionality::FileAppend,) => {
                    ::core::fmt::Formatter::write_str(f, "FileAppend")
                }
                (&HederaFunctionality::FileUpdate,) => {
                    ::core::fmt::Formatter::write_str(f, "FileUpdate")
                }
                (&HederaFunctionality::FileDelete,) => {
                    ::core::fmt::Formatter::write_str(f, "FileDelete")
                }
                (&HederaFunctionality::CryptoGetAccountBalance,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoGetAccountBalance")
                }
                (&HederaFunctionality::CryptoGetAccountRecords,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoGetAccountRecords")
                }
                (&HederaFunctionality::CryptoGetInfo,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoGetInfo")
                }
                (&HederaFunctionality::ContractCallLocal,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractCallLocal")
                }
                (&HederaFunctionality::ContractGetInfo,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractGetInfo")
                }
                (&HederaFunctionality::ContractGetBytecode,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractGetBytecode")
                }
                (&HederaFunctionality::GetBySolidityId,) => {
                    ::core::fmt::Formatter::write_str(f, "GetBySolidityId")
                }
                (&HederaFunctionality::GetByKey,) => {
                    ::core::fmt::Formatter::write_str(f, "GetByKey")
                }
                (&HederaFunctionality::CryptoGetLiveHash,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoGetLiveHash")
                }
                (&HederaFunctionality::CryptoGetStakers,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoGetStakers")
                }
                (&HederaFunctionality::FileGetContents,) => {
                    ::core::fmt::Formatter::write_str(f, "FileGetContents")
                }
                (&HederaFunctionality::FileGetInfo,) => {
                    ::core::fmt::Formatter::write_str(f, "FileGetInfo")
                }
                (&HederaFunctionality::TransactionGetRecord,) => {
                    ::core::fmt::Formatter::write_str(f, "TransactionGetRecord")
                }
                (&HederaFunctionality::ContractGetRecords,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractGetRecords")
                }
                (&HederaFunctionality::CryptoCreate,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoCreate")
                }
                (&HederaFunctionality::SystemDelete,) => {
                    ::core::fmt::Formatter::write_str(f, "SystemDelete")
                }
                (&HederaFunctionality::SystemUndelete,) => {
                    ::core::fmt::Formatter::write_str(f, "SystemUndelete")
                }
                (&HederaFunctionality::ContractDelete,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractDelete")
                }
                (&HederaFunctionality::Freeze,) => ::core::fmt::Formatter::write_str(f, "Freeze"),
                (&HederaFunctionality::CreateTransactionRecord,) => {
                    ::core::fmt::Formatter::write_str(f, "CreateTransactionRecord")
                }
                (&HederaFunctionality::CryptoAccountAutoRenew,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoAccountAutoRenew")
                }
                (&HederaFunctionality::ContractAutoRenew,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractAutoRenew")
                }
                (&HederaFunctionality::GetVersionInfo,) => {
                    ::core::fmt::Formatter::write_str(f, "GetVersionInfo")
                }
                (&HederaFunctionality::TransactionGetReceipt,) => {
                    ::core::fmt::Formatter::write_str(f, "TransactionGetReceipt")
                }
                (&HederaFunctionality::ConsensusCreateTopic,) => {
                    ::core::fmt::Formatter::write_str(f, "ConsensusCreateTopic")
                }
                (&HederaFunctionality::ConsensusUpdateTopic,) => {
                    ::core::fmt::Formatter::write_str(f, "ConsensusUpdateTopic")
                }
                (&HederaFunctionality::ConsensusDeleteTopic,) => {
                    ::core::fmt::Formatter::write_str(f, "ConsensusDeleteTopic")
                }
                (&HederaFunctionality::ConsensusGetTopicInfo,) => {
                    ::core::fmt::Formatter::write_str(f, "ConsensusGetTopicInfo")
                }
                (&HederaFunctionality::ConsensusSubmitMessage,) => {
                    ::core::fmt::Formatter::write_str(f, "ConsensusSubmitMessage")
                }
                (&HederaFunctionality::UncheckedSubmit,) => {
                    ::core::fmt::Formatter::write_str(f, "UncheckedSubmit")
                }
                (&HederaFunctionality::TokenCreate,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenCreate")
                }
                (&HederaFunctionality::TokenGetInfo,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenGetInfo")
                }
                (&HederaFunctionality::TokenFreezeAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenFreezeAccount")
                }
                (&HederaFunctionality::TokenUnfreezeAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenUnfreezeAccount")
                }
                (&HederaFunctionality::TokenGrantKycToAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenGrantKycToAccount")
                }
                (&HederaFunctionality::TokenRevokeKycFromAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenRevokeKycFromAccount")
                }
                (&HederaFunctionality::TokenDelete,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenDelete")
                }
                (&HederaFunctionality::TokenUpdate,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenUpdate")
                }
                (&HederaFunctionality::TokenMint,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenMint")
                }
                (&HederaFunctionality::TokenBurn,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenBurn")
                }
                (&HederaFunctionality::TokenAccountWipe,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenAccountWipe")
                }
                (&HederaFunctionality::TokenAssociateToAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenAssociateToAccount")
                }
                (&HederaFunctionality::TokenDissociateFromAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenDissociateFromAccount")
                }
                (&HederaFunctionality::ScheduleCreate,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduleCreate")
                }
                (&HederaFunctionality::ScheduleDelete,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduleDelete")
                }
                (&HederaFunctionality::ScheduleSign,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduleSign")
                }
                (&HederaFunctionality::ScheduleGetInfo,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduleGetInfo")
                }
                (&HederaFunctionality::TokenGetAccountNftInfos,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenGetAccountNftInfos")
                }
                (&HederaFunctionality::TokenGetNftInfo,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenGetNftInfo")
                }
                (&HederaFunctionality::TokenGetNftInfos,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenGetNftInfos")
                }
                (&HederaFunctionality::TokenFeeScheduleUpdate,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenFeeScheduleUpdate")
                }
                (&HederaFunctionality::NetworkGetExecutionTime,) => {
                    ::core::fmt::Formatter::write_str(f, "NetworkGetExecutionTime")
                }
                (&HederaFunctionality::TokenPause,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenPause")
                }
                (&HederaFunctionality::TokenUnpause,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenUnpause")
                }
                (&HederaFunctionality::CryptoApproveAllowance,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoApproveAllowance")
                }
                (&HederaFunctionality::CryptoDeleteAllowance,) => {
                    ::core::fmt::Formatter::write_str(f, "CryptoDeleteAllowance")
                }
                (&HederaFunctionality::GetAccountDetails,) => {
                    ::core::fmt::Formatter::write_str(f, "GetAccountDetails")
                }
                (&HederaFunctionality::EthereumTransaction,) => {
                    ::core::fmt::Formatter::write_str(f, "EthereumTransaction")
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for HederaFunctionality {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for HederaFunctionality {
        #[inline]
        fn eq(&self, other: &HederaFunctionality) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for HederaFunctionality {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for HederaFunctionality {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for HederaFunctionality {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for HederaFunctionality {
        #[inline]
        fn partial_cmp(
            &self,
            other: &HederaFunctionality,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for HederaFunctionality {
        #[inline]
        fn cmp(&self, other: &HederaFunctionality) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    impl HederaFunctionality {
        ///Returns `true` if `value` is a variant of `HederaFunctionality`.
        pub fn is_valid(value: i32) -> bool {
            match value {
                0 => true,
                1 => true,
                2 => true,
                3 => true,
                4 => true,
                5 => true,
                6 => true,
                7 => true,
                8 => true,
                9 => true,
                10 => true,
                11 => true,
                12 => true,
                13 => true,
                14 => true,
                15 => true,
                16 => true,
                17 => true,
                18 => true,
                19 => true,
                20 => true,
                21 => true,
                22 => true,
                23 => true,
                24 => true,
                25 => true,
                26 => true,
                27 => true,
                28 => true,
                29 => true,
                30 => true,
                31 => true,
                32 => true,
                33 => true,
                34 => true,
                35 => true,
                36 => true,
                50 => true,
                51 => true,
                52 => true,
                53 => true,
                54 => true,
                55 => true,
                56 => true,
                58 => true,
                59 => true,
                60 => true,
                61 => true,
                62 => true,
                63 => true,
                64 => true,
                65 => true,
                66 => true,
                67 => true,
                68 => true,
                69 => true,
                70 => true,
                71 => true,
                72 => true,
                73 => true,
                74 => true,
                75 => true,
                76 => true,
                77 => true,
                78 => true,
                79 => true,
                80 => true,
                81 => true,
                82 => true,
                83 => true,
                84 => true,
                _ => false,
            }
        }
        ///Converts an `i32` to a `HederaFunctionality`, or `None` if `value` is not a valid variant.
        pub fn from_i32(value: i32) -> ::core::option::Option<HederaFunctionality> {
            match value {
                0 => ::core::option::Option::Some(HederaFunctionality::None),
                1 => ::core::option::Option::Some(HederaFunctionality::CryptoTransfer),
                2 => ::core::option::Option::Some(HederaFunctionality::CryptoUpdate),
                3 => ::core::option::Option::Some(HederaFunctionality::CryptoDelete),
                4 => ::core::option::Option::Some(HederaFunctionality::CryptoAddLiveHash),
                5 => ::core::option::Option::Some(HederaFunctionality::CryptoDeleteLiveHash),
                6 => ::core::option::Option::Some(HederaFunctionality::ContractCall),
                7 => ::core::option::Option::Some(HederaFunctionality::ContractCreate),
                8 => ::core::option::Option::Some(HederaFunctionality::ContractUpdate),
                9 => ::core::option::Option::Some(HederaFunctionality::FileCreate),
                10 => ::core::option::Option::Some(HederaFunctionality::FileAppend),
                11 => ::core::option::Option::Some(HederaFunctionality::FileUpdate),
                12 => ::core::option::Option::Some(HederaFunctionality::FileDelete),
                13 => ::core::option::Option::Some(HederaFunctionality::CryptoGetAccountBalance),
                14 => ::core::option::Option::Some(HederaFunctionality::CryptoGetAccountRecords),
                15 => ::core::option::Option::Some(HederaFunctionality::CryptoGetInfo),
                16 => ::core::option::Option::Some(HederaFunctionality::ContractCallLocal),
                17 => ::core::option::Option::Some(HederaFunctionality::ContractGetInfo),
                18 => ::core::option::Option::Some(HederaFunctionality::ContractGetBytecode),
                19 => ::core::option::Option::Some(HederaFunctionality::GetBySolidityId),
                20 => ::core::option::Option::Some(HederaFunctionality::GetByKey),
                21 => ::core::option::Option::Some(HederaFunctionality::CryptoGetLiveHash),
                22 => ::core::option::Option::Some(HederaFunctionality::CryptoGetStakers),
                23 => ::core::option::Option::Some(HederaFunctionality::FileGetContents),
                24 => ::core::option::Option::Some(HederaFunctionality::FileGetInfo),
                25 => ::core::option::Option::Some(HederaFunctionality::TransactionGetRecord),
                26 => ::core::option::Option::Some(HederaFunctionality::ContractGetRecords),
                27 => ::core::option::Option::Some(HederaFunctionality::CryptoCreate),
                28 => ::core::option::Option::Some(HederaFunctionality::SystemDelete),
                29 => ::core::option::Option::Some(HederaFunctionality::SystemUndelete),
                30 => ::core::option::Option::Some(HederaFunctionality::ContractDelete),
                31 => ::core::option::Option::Some(HederaFunctionality::Freeze),
                32 => ::core::option::Option::Some(HederaFunctionality::CreateTransactionRecord),
                33 => ::core::option::Option::Some(HederaFunctionality::CryptoAccountAutoRenew),
                34 => ::core::option::Option::Some(HederaFunctionality::ContractAutoRenew),
                35 => ::core::option::Option::Some(HederaFunctionality::GetVersionInfo),
                36 => ::core::option::Option::Some(HederaFunctionality::TransactionGetReceipt),
                50 => ::core::option::Option::Some(HederaFunctionality::ConsensusCreateTopic),
                51 => ::core::option::Option::Some(HederaFunctionality::ConsensusUpdateTopic),
                52 => ::core::option::Option::Some(HederaFunctionality::ConsensusDeleteTopic),
                53 => ::core::option::Option::Some(HederaFunctionality::ConsensusGetTopicInfo),
                54 => ::core::option::Option::Some(HederaFunctionality::ConsensusSubmitMessage),
                55 => ::core::option::Option::Some(HederaFunctionality::UncheckedSubmit),
                56 => ::core::option::Option::Some(HederaFunctionality::TokenCreate),
                58 => ::core::option::Option::Some(HederaFunctionality::TokenGetInfo),
                59 => ::core::option::Option::Some(HederaFunctionality::TokenFreezeAccount),
                60 => ::core::option::Option::Some(HederaFunctionality::TokenUnfreezeAccount),
                61 => ::core::option::Option::Some(HederaFunctionality::TokenGrantKycToAccount),
                62 => ::core::option::Option::Some(HederaFunctionality::TokenRevokeKycFromAccount),
                63 => ::core::option::Option::Some(HederaFunctionality::TokenDelete),
                64 => ::core::option::Option::Some(HederaFunctionality::TokenUpdate),
                65 => ::core::option::Option::Some(HederaFunctionality::TokenMint),
                66 => ::core::option::Option::Some(HederaFunctionality::TokenBurn),
                67 => ::core::option::Option::Some(HederaFunctionality::TokenAccountWipe),
                68 => ::core::option::Option::Some(HederaFunctionality::TokenAssociateToAccount),
                69 => ::core::option::Option::Some(HederaFunctionality::TokenDissociateFromAccount),
                70 => ::core::option::Option::Some(HederaFunctionality::ScheduleCreate),
                71 => ::core::option::Option::Some(HederaFunctionality::ScheduleDelete),
                72 => ::core::option::Option::Some(HederaFunctionality::ScheduleSign),
                73 => ::core::option::Option::Some(HederaFunctionality::ScheduleGetInfo),
                74 => ::core::option::Option::Some(HederaFunctionality::TokenGetAccountNftInfos),
                75 => ::core::option::Option::Some(HederaFunctionality::TokenGetNftInfo),
                76 => ::core::option::Option::Some(HederaFunctionality::TokenGetNftInfos),
                77 => ::core::option::Option::Some(HederaFunctionality::TokenFeeScheduleUpdate),
                78 => ::core::option::Option::Some(HederaFunctionality::NetworkGetExecutionTime),
                79 => ::core::option::Option::Some(HederaFunctionality::TokenPause),
                80 => ::core::option::Option::Some(HederaFunctionality::TokenUnpause),
                81 => ::core::option::Option::Some(HederaFunctionality::CryptoApproveAllowance),
                82 => ::core::option::Option::Some(HederaFunctionality::CryptoDeleteAllowance),
                83 => ::core::option::Option::Some(HederaFunctionality::GetAccountDetails),
                84 => ::core::option::Option::Some(HederaFunctionality::EthereumTransaction),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for HederaFunctionality {
        fn default() -> HederaFunctionality {
            HederaFunctionality::None
        }
    }
    impl ::core::convert::From<HederaFunctionality> for i32 {
        fn from(value: HederaFunctionality) -> i32 {
            value as i32
        }
    }
    /// A length of time in seconds.
    pub struct Duration {
        /// The number of seconds
        #[prost(int64, tag = "1")]
        pub seconds: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Duration {
        #[inline]
        fn clone(&self) -> Duration {
            {
                let _: ::core::clone::AssertParamIsClone<i64>;
                *self
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Duration {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Duration {
        #[inline]
        fn eq(&self, other: &Duration) -> bool {
            match *other {
                Duration {
                    seconds: ref __self_1_0,
                } => match *self {
                    Duration {
                        seconds: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Duration) -> bool {
            match *other {
                Duration {
                    seconds: ref __self_1_0,
                } => match *self {
                    Duration {
                        seconds: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for Duration {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.seconds != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.seconds, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Duration";
            match tag {
                1u32 => {
                    let mut value = &mut self.seconds;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "seconds");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.seconds != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.seconds)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.seconds = 0i64;
        }
    }
    impl ::core::default::Default for Duration {
        fn default() -> Self {
            Duration { seconds: 0i64 }
        }
    }
    impl ::core::fmt::Debug for Duration {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Duration");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.seconds)
                };
                builder.field("seconds", &wrapper)
            };
            builder.finish()
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Duration {}
    impl ::core::marker::StructuralEq for Duration {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Duration {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for Duration {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                Duration {
                    seconds: ref __self_0_0,
                } => ::core::hash::Hash::hash(&(*__self_0_0), state),
            }
        }
    }
    /// Delete a file or smart contract - can only be done with a Hedera administrative multisignature.
    /// When it is deleted, it immediately disappears from the system as seen by the user, but is still
    /// stored internally until the expiration time, at which time it is truly and permanently deleted.
    /// Until that time, it can be undeleted by the Hedera administrative multisignature. When a smart
    /// contract is deleted, the cryptocurrency account within it continues to exist, and is not affected
    /// by the expiration time here.
    pub struct SystemDeleteTransactionBody {
        /// The timestamp in seconds at which the "deleted" file should truly be permanently deleted
        #[prost(message, optional, tag = "3")]
        pub expiration_time: ::core::option::Option<TimestampSeconds>,
        #[prost(oneof = "system_delete_transaction_body::Id", tags = "1, 2")]
        pub id: ::core::option::Option<system_delete_transaction_body::Id>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SystemDeleteTransactionBody {
        #[inline]
        fn clone(&self) -> SystemDeleteTransactionBody {
            match *self {
                SystemDeleteTransactionBody {
                    expiration_time: ref __self_0_0,
                    id: ref __self_0_1,
                } => SystemDeleteTransactionBody {
                    expiration_time: ::core::clone::Clone::clone(&(*__self_0_0)),
                    id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for SystemDeleteTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for SystemDeleteTransactionBody {
        #[inline]
        fn eq(&self, other: &SystemDeleteTransactionBody) -> bool {
            match *other {
                SystemDeleteTransactionBody {
                    expiration_time: ref __self_1_0,
                    id: ref __self_1_1,
                } => match *self {
                    SystemDeleteTransactionBody {
                        expiration_time: ref __self_0_0,
                        id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &SystemDeleteTransactionBody) -> bool {
            match *other {
                SystemDeleteTransactionBody {
                    expiration_time: ref __self_1_0,
                    id: ref __self_1_1,
                } => match *self {
                    SystemDeleteTransactionBody {
                        expiration_time: ref __self_0_0,
                        id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for SystemDeleteTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.id {
                oneof.encode(buf)
            }
            if let Some(ref msg) = self.expiration_time {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "SystemDeleteTransactionBody";
            match tag {
                1u32 | 2u32 => {
                    let mut value = &mut self.id;
                    system_delete_transaction_body::Id::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "id");
                            error
                        })
                }
                3u32 => {
                    let mut value = &mut self.expiration_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiration_time");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .id
                .as_ref()
                .map_or(0, system_delete_transaction_body::Id::encoded_len)
                + self
                    .expiration_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
        }
        fn clear(&mut self) {
            self.id = ::core::option::Option::None;
            self.expiration_time = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for SystemDeleteTransactionBody {
        fn default() -> Self {
            SystemDeleteTransactionBody {
                id: ::core::default::Default::default(),
                expiration_time: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for SystemDeleteTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("SystemDeleteTransactionBody");
            let builder = {
                let wrapper = &self.expiration_time;
                builder.field("expiration_time", &wrapper)
            };
            let builder = {
                let wrapper = &self.id;
                builder.field("id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `SystemDeleteTransactionBody`.
    pub mod system_delete_transaction_body {
        pub enum Id {
            /// The file ID of the file to delete, in the format used in transactions
            #[prost(message, tag = "1")]
            FileId(super::FileId),
            /// The contract ID instance to delete, in the format used in transactions
            #[prost(message, tag = "2")]
            ContractId(super::ContractId),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Id {
            #[inline]
            fn clone(&self) -> Id {
                match (&*self,) {
                    (&Id::FileId(ref __self_0),) => {
                        Id::FileId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Id::ContractId(ref __self_0),) => {
                        Id::ContractId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Id {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Id {
            #[inline]
            fn eq(&self, other: &Id) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Id::FileId(ref __self_0), &Id::FileId(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Id::ContractId(ref __self_0), &Id::ContractId(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Id) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Id::FileId(ref __self_0), &Id::FileId(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Id::ContractId(ref __self_0), &Id::ContractId(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Id {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Id::FileId(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                    Id::ContractId(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Id>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => match field {
                        ::core::option::Option::Some(Id::FileId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| *field = ::core::option::Option::Some(Id::FileId(owned_value)),
                            )
                        }
                    },
                    2u32 => match field {
                        ::core::option::Option::Some(Id::ContractId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Id::ContractId(owned_value))
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Id tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Id::FileId(ref value) => ::prost::encoding::message::encoded_len(1u32, &*value),
                    Id::ContractId(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Id {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Id::FileId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileId").field(&wrapper).finish()
                    }
                    Id::ContractId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractId").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// Undelete a file or smart contract that was deleted by SystemDelete; requires a Hedera
    /// administrative multisignature.
    pub struct SystemUndeleteTransactionBody {
        #[prost(oneof = "system_undelete_transaction_body::Id", tags = "1, 2")]
        pub id: ::core::option::Option<system_undelete_transaction_body::Id>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SystemUndeleteTransactionBody {
        #[inline]
        fn clone(&self) -> SystemUndeleteTransactionBody {
            match *self {
                SystemUndeleteTransactionBody { id: ref __self_0_0 } => {
                    SystemUndeleteTransactionBody {
                        id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    }
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for SystemUndeleteTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for SystemUndeleteTransactionBody {
        #[inline]
        fn eq(&self, other: &SystemUndeleteTransactionBody) -> bool {
            match *other {
                SystemUndeleteTransactionBody { id: ref __self_1_0 } => match *self {
                    SystemUndeleteTransactionBody { id: ref __self_0_0 } => {
                        (*__self_0_0) == (*__self_1_0)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &SystemUndeleteTransactionBody) -> bool {
            match *other {
                SystemUndeleteTransactionBody { id: ref __self_1_0 } => match *self {
                    SystemUndeleteTransactionBody { id: ref __self_0_0 } => {
                        (*__self_0_0) != (*__self_1_0)
                    }
                },
            }
        }
    }
    impl ::prost::Message for SystemUndeleteTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.id {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "SystemUndeleteTransactionBody";
            match tag {
                1u32 | 2u32 => {
                    let mut value = &mut self.id;
                    system_undelete_transaction_body::Id::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "id");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .id
                .as_ref()
                .map_or(0, system_undelete_transaction_body::Id::encoded_len)
        }
        fn clear(&mut self) {
            self.id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for SystemUndeleteTransactionBody {
        fn default() -> Self {
            SystemUndeleteTransactionBody {
                id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for SystemUndeleteTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("SystemUndeleteTransactionBody");
            let builder = {
                let wrapper = &self.id;
                builder.field("id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `SystemUndeleteTransactionBody`.
    pub mod system_undelete_transaction_body {
        pub enum Id {
            /// The file ID to undelete, in the format used in transactions
            #[prost(message, tag = "1")]
            FileId(super::FileId),
            /// The contract ID instance to undelete, in the format used in transactions
            #[prost(message, tag = "2")]
            ContractId(super::ContractId),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Id {
            #[inline]
            fn clone(&self) -> Id {
                match (&*self,) {
                    (&Id::FileId(ref __self_0),) => {
                        Id::FileId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Id::ContractId(ref __self_0),) => {
                        Id::ContractId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Id {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Id {
            #[inline]
            fn eq(&self, other: &Id) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Id::FileId(ref __self_0), &Id::FileId(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Id::ContractId(ref __self_0), &Id::ContractId(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Id) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Id::FileId(ref __self_0), &Id::FileId(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Id::ContractId(ref __self_0), &Id::ContractId(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Id {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Id::FileId(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                    Id::ContractId(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Id>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => match field {
                        ::core::option::Option::Some(Id::FileId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| *field = ::core::option::Option::Some(Id::FileId(owned_value)),
                            )
                        }
                    },
                    2u32 => match field {
                        ::core::option::Option::Some(Id::ContractId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Id::ContractId(owned_value))
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Id tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Id::FileId(ref value) => ::prost::encoding::message::encoded_len(1u32, &*value),
                    Id::ContractId(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Id {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Id::FileId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileId").field(&wrapper).finish()
                    }
                    Id::ContractId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractId").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// The type of network freeze or upgrade operation to be performed. This type dictates which
    /// fields are required.
    #[repr(i32)]
    pub enum FreezeType {
        /// An (invalid) default value for this enum, to ensure the client explicitly sets
        /// the intended type of freeze transaction.
        UnknownFreezeType = 0,
        /// Freezes the network at the specified time. The start_time field must be provided and
        /// must reference a future time. Any values specified for the update_file and file_hash
        /// fields will be ignored. This transaction does not perform any network changes or
        /// upgrades and requires manual intervention to restart the network.
        FreezeOnly = 1,
        /// A non-freezing operation that initiates network wide preparation in advance of a
        /// scheduled freeze upgrade. The update_file and file_hash fields must be provided and
        /// valid. The start_time field may be omitted and any value present will be ignored.
        PrepareUpgrade = 2,
        /// Freezes the network at the specified time and performs the previously prepared
        /// automatic upgrade across the entire network.
        FreezeUpgrade = 3,
        /// Aborts a pending network freeze operation.
        FreezeAbort = 4,
        /// Performs an immediate upgrade on auxilary services and containers providing
        /// telemetry/metrics. Does not impact network operations.
        TelemetryUpgrade = 5,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FreezeType {
        #[inline]
        fn clone(&self) -> FreezeType {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for FreezeType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for FreezeType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&FreezeType::UnknownFreezeType,) => {
                    ::core::fmt::Formatter::write_str(f, "UnknownFreezeType")
                }
                (&FreezeType::FreezeOnly,) => ::core::fmt::Formatter::write_str(f, "FreezeOnly"),
                (&FreezeType::PrepareUpgrade,) => {
                    ::core::fmt::Formatter::write_str(f, "PrepareUpgrade")
                }
                (&FreezeType::FreezeUpgrade,) => {
                    ::core::fmt::Formatter::write_str(f, "FreezeUpgrade")
                }
                (&FreezeType::FreezeAbort,) => ::core::fmt::Formatter::write_str(f, "FreezeAbort"),
                (&FreezeType::TelemetryUpgrade,) => {
                    ::core::fmt::Formatter::write_str(f, "TelemetryUpgrade")
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FreezeType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FreezeType {
        #[inline]
        fn eq(&self, other: &FreezeType) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for FreezeType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for FreezeType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for FreezeType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for FreezeType {
        #[inline]
        fn partial_cmp(&self, other: &FreezeType) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for FreezeType {
        #[inline]
        fn cmp(&self, other: &FreezeType) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    impl FreezeType {
        ///Returns `true` if `value` is a variant of `FreezeType`.
        pub fn is_valid(value: i32) -> bool {
            match value {
                0 => true,
                1 => true,
                2 => true,
                3 => true,
                4 => true,
                5 => true,
                _ => false,
            }
        }
        ///Converts an `i32` to a `FreezeType`, or `None` if `value` is not a valid variant.
        pub fn from_i32(value: i32) -> ::core::option::Option<FreezeType> {
            match value {
                0 => ::core::option::Option::Some(FreezeType::UnknownFreezeType),
                1 => ::core::option::Option::Some(FreezeType::FreezeOnly),
                2 => ::core::option::Option::Some(FreezeType::PrepareUpgrade),
                3 => ::core::option::Option::Some(FreezeType::FreezeUpgrade),
                4 => ::core::option::Option::Some(FreezeType::FreezeAbort),
                5 => ::core::option::Option::Some(FreezeType::TelemetryUpgrade),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for FreezeType {
        fn default() -> FreezeType {
            FreezeType::UnknownFreezeType
        }
    }
    impl ::core::convert::From<FreezeType> for i32 {
        fn from(value: FreezeType) -> i32 {
            value as i32
        }
    }
    /// At consensus, sets the consensus time at which the platform should stop creating events and
    /// accepting transactions, and enter a maintenance window.
    pub struct FreezeTransactionBody {
        /// !! DEPRECATED and REJECTED by nodes
        /// The start hour (in UTC time), a value between 0 and 23
        #[deprecated]
        #[prost(int32, tag = "1")]
        pub start_hour: i32,
        /// !! DEPRECATED and REJECTED by nodes
        /// The start minute (in UTC time), a value between 0 and 59
        #[deprecated]
        #[prost(int32, tag = "2")]
        pub start_min: i32,
        /// !! DEPRECATED and REJECTED by nodes
        /// The end hour (in UTC time), a value between 0 and 23
        #[deprecated]
        #[prost(int32, tag = "3")]
        pub end_hour: i32,
        /// !! DEPRECATED and REJECTED by nodes
        /// The end minute (in UTC time), a value between 0 and 59
        #[deprecated]
        #[prost(int32, tag = "4")]
        pub end_min: i32,
        /// If set, the file whose contents should be used for a network software update during the
        /// maintenance window.
        #[prost(message, optional, tag = "5")]
        pub update_file: ::core::option::Option<FileId>,
        /// If set, the expected hash of the contents of the update file (used to verify the update).
        #[prost(bytes = "vec", tag = "6")]
        pub file_hash: ::prost::alloc::vec::Vec<u8>,
        /// The consensus time at which the maintenance window should begin.
        #[prost(message, optional, tag = "7")]
        pub start_time: ::core::option::Option<Timestamp>,
        /// The type of network freeze or upgrade operation to perform.
        #[prost(enumeration = "FreezeType", tag = "8")]
        pub freeze_type: i32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FreezeTransactionBody {
        #[inline]
        fn clone(&self) -> FreezeTransactionBody {
            match *self {
                FreezeTransactionBody {
                    start_hour: ref __self_0_0,
                    start_min: ref __self_0_1,
                    end_hour: ref __self_0_2,
                    end_min: ref __self_0_3,
                    update_file: ref __self_0_4,
                    file_hash: ref __self_0_5,
                    start_time: ref __self_0_6,
                    freeze_type: ref __self_0_7,
                } => FreezeTransactionBody {
                    start_hour: ::core::clone::Clone::clone(&(*__self_0_0)),
                    start_min: ::core::clone::Clone::clone(&(*__self_0_1)),
                    end_hour: ::core::clone::Clone::clone(&(*__self_0_2)),
                    end_min: ::core::clone::Clone::clone(&(*__self_0_3)),
                    update_file: ::core::clone::Clone::clone(&(*__self_0_4)),
                    file_hash: ::core::clone::Clone::clone(&(*__self_0_5)),
                    start_time: ::core::clone::Clone::clone(&(*__self_0_6)),
                    freeze_type: ::core::clone::Clone::clone(&(*__self_0_7)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FreezeTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FreezeTransactionBody {
        #[inline]
        fn eq(&self, other: &FreezeTransactionBody) -> bool {
            match *other {
                FreezeTransactionBody {
                    start_hour: ref __self_1_0,
                    start_min: ref __self_1_1,
                    end_hour: ref __self_1_2,
                    end_min: ref __self_1_3,
                    update_file: ref __self_1_4,
                    file_hash: ref __self_1_5,
                    start_time: ref __self_1_6,
                    freeze_type: ref __self_1_7,
                } => match *self {
                    FreezeTransactionBody {
                        start_hour: ref __self_0_0,
                        start_min: ref __self_0_1,
                        end_hour: ref __self_0_2,
                        end_min: ref __self_0_3,
                        update_file: ref __self_0_4,
                        file_hash: ref __self_0_5,
                        start_time: ref __self_0_6,
                        freeze_type: ref __self_0_7,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FreezeTransactionBody) -> bool {
            match *other {
                FreezeTransactionBody {
                    start_hour: ref __self_1_0,
                    start_min: ref __self_1_1,
                    end_hour: ref __self_1_2,
                    end_min: ref __self_1_3,
                    update_file: ref __self_1_4,
                    file_hash: ref __self_1_5,
                    start_time: ref __self_1_6,
                    freeze_type: ref __self_1_7,
                } => match *self {
                    FreezeTransactionBody {
                        start_hour: ref __self_0_0,
                        start_min: ref __self_0_1,
                        end_hour: ref __self_0_2,
                        end_min: ref __self_0_3,
                        update_file: ref __self_0_4,
                        file_hash: ref __self_0_5,
                        start_time: ref __self_0_6,
                        freeze_type: ref __self_0_7,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                    }
                },
            }
        }
    }
    impl ::prost::Message for FreezeTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.start_hour != 0i32 {
                ::prost::encoding::int32::encode(1u32, &self.start_hour, buf);
            }
            if self.start_min != 0i32 {
                ::prost::encoding::int32::encode(2u32, &self.start_min, buf);
            }
            if self.end_hour != 0i32 {
                ::prost::encoding::int32::encode(3u32, &self.end_hour, buf);
            }
            if self.end_min != 0i32 {
                ::prost::encoding::int32::encode(4u32, &self.end_min, buf);
            }
            if let Some(ref msg) = self.update_file {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
            if self.file_hash != b"" as &[u8] {
                ::prost::encoding::bytes::encode(6u32, &self.file_hash, buf);
            }
            if let Some(ref msg) = self.start_time {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            if self.freeze_type != FreezeType::default() as i32 {
                ::prost::encoding::int32::encode(8u32, &self.freeze_type, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FreezeTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.start_hour;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "start_hour");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.start_min;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "start_min");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.end_hour;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "end_hour");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.end_min;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "end_min");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.update_file;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "update_file");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.file_hash;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "file_hash");
                            error
                        },
                    )
                }
                7u32 => {
                    let mut value = &mut self.start_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "start_time");
                        error
                    })
                }
                8u32 => {
                    let mut value = &mut self.freeze_type;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "freeze_type");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.start_hour != 0i32 {
                ::prost::encoding::int32::encoded_len(1u32, &self.start_hour)
            } else {
                0
            } + if self.start_min != 0i32 {
                ::prost::encoding::int32::encoded_len(2u32, &self.start_min)
            } else {
                0
            } + if self.end_hour != 0i32 {
                ::prost::encoding::int32::encoded_len(3u32, &self.end_hour)
            } else {
                0
            } + if self.end_min != 0i32 {
                ::prost::encoding::int32::encoded_len(4u32, &self.end_min)
            } else {
                0
            } + self
                .update_file
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                + if self.file_hash != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(6u32, &self.file_hash)
                } else {
                    0
                }
                + self
                    .start_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                + if self.freeze_type != FreezeType::default() as i32 {
                    ::prost::encoding::int32::encoded_len(8u32, &self.freeze_type)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.start_hour = 0i32;
            self.start_min = 0i32;
            self.end_hour = 0i32;
            self.end_min = 0i32;
            self.update_file = ::core::option::Option::None;
            self.file_hash.clear();
            self.start_time = ::core::option::Option::None;
            self.freeze_type = FreezeType::default() as i32;
        }
    }
    impl ::core::default::Default for FreezeTransactionBody {
        fn default() -> Self {
            FreezeTransactionBody {
                start_hour: 0i32,
                start_min: 0i32,
                end_hour: 0i32,
                end_min: 0i32,
                update_file: ::core::default::Default::default(),
                file_hash: ::core::default::Default::default(),
                start_time: ::core::default::Default::default(),
                freeze_type: FreezeType::default() as i32,
            }
        }
    }
    impl ::core::fmt::Debug for FreezeTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FreezeTransactionBody");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.start_hour)
                };
                builder.field("start_hour", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.start_min)
                };
                builder.field("start_min", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.end_hour)
                };
                builder.field("end_hour", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.end_min)
                };
                builder.field("end_min", &wrapper)
            };
            let builder = {
                let wrapper = &self.update_file;
                builder.field("update_file", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.file_hash)
                };
                builder.field("file_hash", &wrapper)
            };
            let builder = {
                let wrapper = &self.start_time;
                builder.field("start_time", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match FreezeType::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.freeze_type)
                };
                builder.field("freeze_type", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl FreezeTransactionBody {
        ///Returns the enum value of `freeze_type`, or the default if the field is set to an invalid enum value.
        pub fn freeze_type(&self) -> FreezeType {
            FreezeType::from_i32(self.freeze_type).unwrap_or(FreezeType::default())
        }
        ///Sets `freeze_type` to the provided enum value.
        pub fn set_freeze_type(&mut self, value: FreezeType) {
            self.freeze_type = value as i32;
        }
    }
    /// Call a function of the given smart contract instance, giving it functionParameters as its inputs.
    /// The call can use at maximum the given amount of gas – the paying account will not be charged for
    /// any unspent gas.
    ///
    /// If this function results in data being stored, an amount of gas is calculated that reflects this
    /// storage burden.
    ///
    /// The amount of gas used, as well as other attributes of the transaction, e.g. size, number of
    /// signatures to be verified, determine the fee for the transaction – which is charged to the paying
    /// account.
    pub struct ContractCallTransactionBody {
        /// The contract to call
        #[prost(message, optional, tag = "1")]
        pub contract_id: ::core::option::Option<ContractId>,
        /// the maximum amount of gas to use for the call
        #[prost(int64, tag = "2")]
        pub gas: i64,
        /// number of tinybars sent (the function must be payable if this is nonzero)
        #[prost(int64, tag = "3")]
        pub amount: i64,
        /// which function to call, and the parameters to pass to the function
        #[prost(bytes = "vec", tag = "4")]
        pub function_parameters: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractCallTransactionBody {
        #[inline]
        fn clone(&self) -> ContractCallTransactionBody {
            match *self {
                ContractCallTransactionBody {
                    contract_id: ref __self_0_0,
                    gas: ref __self_0_1,
                    amount: ref __self_0_2,
                    function_parameters: ref __self_0_3,
                } => ContractCallTransactionBody {
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    gas: ::core::clone::Clone::clone(&(*__self_0_1)),
                    amount: ::core::clone::Clone::clone(&(*__self_0_2)),
                    function_parameters: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractCallTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractCallTransactionBody {
        #[inline]
        fn eq(&self, other: &ContractCallTransactionBody) -> bool {
            match *other {
                ContractCallTransactionBody {
                    contract_id: ref __self_1_0,
                    gas: ref __self_1_1,
                    amount: ref __self_1_2,
                    function_parameters: ref __self_1_3,
                } => match *self {
                    ContractCallTransactionBody {
                        contract_id: ref __self_0_0,
                        gas: ref __self_0_1,
                        amount: ref __self_0_2,
                        function_parameters: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractCallTransactionBody) -> bool {
            match *other {
                ContractCallTransactionBody {
                    contract_id: ref __self_1_0,
                    gas: ref __self_1_1,
                    amount: ref __self_1_2,
                    function_parameters: ref __self_1_3,
                } => match *self {
                    ContractCallTransactionBody {
                        contract_id: ref __self_0_0,
                        gas: ref __self_0_1,
                        amount: ref __self_0_2,
                        function_parameters: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ContractCallTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.gas != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.gas, buf);
            }
            if self.amount != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.amount, buf);
            }
            if self.function_parameters != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.function_parameters, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractCallTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.gas;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "gas");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.function_parameters;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "function_parameters");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .contract_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.gas != 0i64 {
                    ::prost::encoding::int64::encoded_len(2u32, &self.gas)
                } else {
                    0
                }
                + if self.amount != 0i64 {
                    ::prost::encoding::int64::encoded_len(3u32, &self.amount)
                } else {
                    0
                }
                + if self.function_parameters != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(4u32, &self.function_parameters)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.contract_id = ::core::option::Option::None;
            self.gas = 0i64;
            self.amount = 0i64;
            self.function_parameters.clear();
        }
    }
    impl ::core::default::Default for ContractCallTransactionBody {
        fn default() -> Self {
            ContractCallTransactionBody {
                contract_id: ::core::default::Default::default(),
                gas: 0i64,
                amount: 0i64,
                function_parameters: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractCallTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractCallTransactionBody");
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.gas)
                };
                builder.field("gas", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.function_parameters)
                };
                builder.field("function_parameters", &wrapper)
            };
            builder.finish()
        }
    }
    /// Start a new smart contract instance. After the instance is created, the ContractID for it is in
    /// the receipt, and can be retrieved by the Record or with a GetByKey query. The instance will run
    /// the bytecode, either stored in a previously created file or in the transaction body itself for
    /// small contracts.
    ///
    ///
    /// The constructor will be executed using the given amount of gas, and any unspent gas will be
    /// refunded to the paying account. Constructor inputs come from the given constructorParameters.
    ///  - The instance will exist for autoRenewPeriod seconds. When that is reached, it will renew
    ///    itself for another autoRenewPeriod seconds by charging its associated cryptocurrency account
    ///    (which it creates here). If it has insufficient cryptocurrency to extend that long, it will
    ///    extend as long as it can. If its balance is zero, the instance will be deleted.
    ///
    ///  - A smart contract instance normally enforces rules, so "the code is law". For example, an
    ///    ERC-20 contract prevents a transfer from being undone without a signature by the recipient of
    ///    the transfer. This is always enforced if the contract instance was created with the adminKeys
    ///    being null. But for some uses, it might be desirable to create something like an ERC-20
    ///    contract that has a specific group of trusted individuals who can act as a "supreme court"
    ///    with the ability to override the normal operation, when a sufficient number of them agree to
    ///    do so. If adminKeys is not null, then they can sign a transaction that can change the state of
    ///    the smart contract in arbitrary ways, such as to reverse a transaction that violates some
    ///    standard of behavior that is not covered by the code itself. The admin keys can also be used
    ///    to change the autoRenewPeriod, and change the adminKeys field itself. The API currently does
    ///    not implement this ability. But it does allow the adminKeys field to be set and queried, and
    ///    will in the future implement such admin abilities for any instance that has a non-null
    ///    adminKeys.
    ///
    ///  - If this constructor stores information, it is charged gas to store it. There is a fee in hbars
    ///    to maintain that storage until the expiration time, and that fee is added as part of the
    ///    transaction fee.
    ///
    ///  - An entity (account, file, or smart contract instance) must be created in a particular realm.
    ///    If the realmID is left null, then a new realm will be created with the given admin key. If a
    ///    new realm has a null adminKey, then anyone can create/modify/delete entities in that realm.
    ///    But if an admin key is given, then any transaction to create/modify/delete an entity in that
    ///    realm must be signed by that key, though anyone can still call functions on smart contract
    ///    instances that exist in that realm. A realm ceases to exist when everything within it has
    ///    expired and no longer exists.
    ///
    ///  - The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in
    ///    shard 0 and realm 0, with a null key. Future versions of the API will support multiple realms
    ///    and multiple shards.
    ///
    ///  - The optional memo field can contain a string whose length is up to 100 bytes. That is the size
    ///    after Unicode NFD then UTF-8 conversion. This field can be used to describe the smart contract.
    ///    It could also be used for other purposes. One recommended purpose is to hold a hexadecimal
    ///    string that is the SHA-384 hash of a PDF file containing a human-readable legal contract. Then,
    ///    if the admin keys are the public keys of human arbitrators, they can use that legal document to
    ///    guide their decisions during a binding arbitration tribunal, convened to consider any changes
    ///    to the smart contract in the future. The memo field can only be changed using the admin keys.
    ///    If there are no admin keys, then it cannot be changed after the smart contract is created.
    ///
    /// <b>Signing requirements:</b> If an admin key is set, it must sign the transaction. If an
    /// auto-renew account is set, its key must sign the transaction.
    pub struct ContractCreateTransactionBody {
        /// the state of the instance and its fields can be modified arbitrarily if this key signs a
        /// transaction to modify it. If this is null, then such modifications are not possible, and
        /// there is no administrator that can override the normal operation of this smart contract
        /// instance. Note that if it is created with no admin keys, then there is no administrator to
        /// authorize changing the admin keys, so there can never be any admin keys for that instance.
        #[prost(message, optional, tag = "3")]
        pub admin_key: ::core::option::Option<Key>,
        /// gas to run the constructor
        #[prost(int64, tag = "4")]
        pub gas: i64,
        /// initial number of tinybars to put into the cryptocurrency account associated with and owned
        /// by the smart contract
        #[prost(int64, tag = "5")]
        pub initial_balance: i64,
        /// \[Deprecated\] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
        /// invalid account, or is an account that isn't a node, then this account is automatically proxy
        /// staked to a node chosen by the network, but without earning payments. If the proxyAccountID
        /// account refuses to accept proxy staking , or if it is not currently running a node, then it
        /// will behave as if  proxyAccountID was null.
        #[deprecated]
        #[prost(message, optional, tag = "6")]
        pub proxy_account_id: ::core::option::Option<AccountId>,
        /// the instance will charge its account every this many seconds to renew for this long
        #[prost(message, optional, tag = "8")]
        pub auto_renew_period: ::core::option::Option<Duration>,
        /// parameters to pass to the constructor
        #[prost(bytes = "vec", tag = "9")]
        pub constructor_parameters: ::prost::alloc::vec::Vec<u8>,
        /// shard in which to create this
        #[prost(message, optional, tag = "10")]
        pub shard_id: ::core::option::Option<ShardId>,
        /// realm in which to create this (leave this null to create a new realm)
        #[prost(message, optional, tag = "11")]
        pub realm_id: ::core::option::Option<RealmId>,
        /// if realmID is null, then this the admin key for the new realm that will be created
        #[prost(message, optional, tag = "12")]
        pub new_realm_admin_key: ::core::option::Option<Key>,
        /// the memo that was submitted as part of the contract (max 100 bytes)
        #[prost(string, tag = "13")]
        pub memo: ::prost::alloc::string::String,
        /// The maximum number of tokens that this contract can be automatically associated
        /// with (i.e., receive air-drops from).
        #[prost(int32, tag = "14")]
        pub max_automatic_token_associations: i32,
        /// An account to charge for auto-renewal of this contract. If not set, or set to an
        /// account with zero hbar balance, the contract's own hbar balance will be used to
        /// cover auto-renewal fees.
        #[prost(message, optional, tag = "15")]
        pub auto_renew_account_id: ::core::option::Option<AccountId>,
        /// If true, the contract declines receiving a staking reward. The default value is false.
        #[prost(bool, tag = "19")]
        pub decline_reward: bool,
        /// There are two ways to specify the initcode of a ContractCreateTransction. If the initcode is
        /// large (> 5K) then it must be stored in a file as hex encoded ascii. If it is small then it may
        /// either be stored as a hex encoded file or as a binary encoded field as part of the transaciton.
        ///
        #[prost(
            oneof = "contract_create_transaction_body::InitcodeSource",
            tags = "1, 16"
        )]
        pub initcode_source:
            ::core::option::Option<contract_create_transaction_body::InitcodeSource>,
        /// ID of the new account or node to which this contract is staking.
        #[prost(oneof = "contract_create_transaction_body::StakedId", tags = "17, 18")]
        pub staked_id: ::core::option::Option<contract_create_transaction_body::StakedId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractCreateTransactionBody {
        #[inline]
        fn clone(&self) -> ContractCreateTransactionBody {
            match *self {
                ContractCreateTransactionBody {
                    admin_key: ref __self_0_0,
                    gas: ref __self_0_1,
                    initial_balance: ref __self_0_2,
                    proxy_account_id: ref __self_0_3,
                    auto_renew_period: ref __self_0_4,
                    constructor_parameters: ref __self_0_5,
                    shard_id: ref __self_0_6,
                    realm_id: ref __self_0_7,
                    new_realm_admin_key: ref __self_0_8,
                    memo: ref __self_0_9,
                    max_automatic_token_associations: ref __self_0_10,
                    auto_renew_account_id: ref __self_0_11,
                    decline_reward: ref __self_0_12,
                    initcode_source: ref __self_0_13,
                    staked_id: ref __self_0_14,
                } => ContractCreateTransactionBody {
                    admin_key: ::core::clone::Clone::clone(&(*__self_0_0)),
                    gas: ::core::clone::Clone::clone(&(*__self_0_1)),
                    initial_balance: ::core::clone::Clone::clone(&(*__self_0_2)),
                    proxy_account_id: ::core::clone::Clone::clone(&(*__self_0_3)),
                    auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_4)),
                    constructor_parameters: ::core::clone::Clone::clone(&(*__self_0_5)),
                    shard_id: ::core::clone::Clone::clone(&(*__self_0_6)),
                    realm_id: ::core::clone::Clone::clone(&(*__self_0_7)),
                    new_realm_admin_key: ::core::clone::Clone::clone(&(*__self_0_8)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_9)),
                    max_automatic_token_associations: ::core::clone::Clone::clone(&(*__self_0_10)),
                    auto_renew_account_id: ::core::clone::Clone::clone(&(*__self_0_11)),
                    decline_reward: ::core::clone::Clone::clone(&(*__self_0_12)),
                    initcode_source: ::core::clone::Clone::clone(&(*__self_0_13)),
                    staked_id: ::core::clone::Clone::clone(&(*__self_0_14)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractCreateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractCreateTransactionBody {
        #[inline]
        fn eq(&self, other: &ContractCreateTransactionBody) -> bool {
            match *other {
                ContractCreateTransactionBody {
                    admin_key: ref __self_1_0,
                    gas: ref __self_1_1,
                    initial_balance: ref __self_1_2,
                    proxy_account_id: ref __self_1_3,
                    auto_renew_period: ref __self_1_4,
                    constructor_parameters: ref __self_1_5,
                    shard_id: ref __self_1_6,
                    realm_id: ref __self_1_7,
                    new_realm_admin_key: ref __self_1_8,
                    memo: ref __self_1_9,
                    max_automatic_token_associations: ref __self_1_10,
                    auto_renew_account_id: ref __self_1_11,
                    decline_reward: ref __self_1_12,
                    initcode_source: ref __self_1_13,
                    staked_id: ref __self_1_14,
                } => match *self {
                    ContractCreateTransactionBody {
                        admin_key: ref __self_0_0,
                        gas: ref __self_0_1,
                        initial_balance: ref __self_0_2,
                        proxy_account_id: ref __self_0_3,
                        auto_renew_period: ref __self_0_4,
                        constructor_parameters: ref __self_0_5,
                        shard_id: ref __self_0_6,
                        realm_id: ref __self_0_7,
                        new_realm_admin_key: ref __self_0_8,
                        memo: ref __self_0_9,
                        max_automatic_token_associations: ref __self_0_10,
                        auto_renew_account_id: ref __self_0_11,
                        decline_reward: ref __self_0_12,
                        initcode_source: ref __self_0_13,
                        staked_id: ref __self_0_14,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                            && (*__self_0_11) == (*__self_1_11)
                            && (*__self_0_12) == (*__self_1_12)
                            && (*__self_0_13) == (*__self_1_13)
                            && (*__self_0_14) == (*__self_1_14)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractCreateTransactionBody) -> bool {
            match *other {
                ContractCreateTransactionBody {
                    admin_key: ref __self_1_0,
                    gas: ref __self_1_1,
                    initial_balance: ref __self_1_2,
                    proxy_account_id: ref __self_1_3,
                    auto_renew_period: ref __self_1_4,
                    constructor_parameters: ref __self_1_5,
                    shard_id: ref __self_1_6,
                    realm_id: ref __self_1_7,
                    new_realm_admin_key: ref __self_1_8,
                    memo: ref __self_1_9,
                    max_automatic_token_associations: ref __self_1_10,
                    auto_renew_account_id: ref __self_1_11,
                    decline_reward: ref __self_1_12,
                    initcode_source: ref __self_1_13,
                    staked_id: ref __self_1_14,
                } => match *self {
                    ContractCreateTransactionBody {
                        admin_key: ref __self_0_0,
                        gas: ref __self_0_1,
                        initial_balance: ref __self_0_2,
                        proxy_account_id: ref __self_0_3,
                        auto_renew_period: ref __self_0_4,
                        constructor_parameters: ref __self_0_5,
                        shard_id: ref __self_0_6,
                        realm_id: ref __self_0_7,
                        new_realm_admin_key: ref __self_0_8,
                        memo: ref __self_0_9,
                        max_automatic_token_associations: ref __self_0_10,
                        auto_renew_account_id: ref __self_0_11,
                        decline_reward: ref __self_0_12,
                        initcode_source: ref __self_0_13,
                        staked_id: ref __self_0_14,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                            || (*__self_0_11) != (*__self_1_11)
                            || (*__self_0_12) != (*__self_1_12)
                            || (*__self_0_13) != (*__self_1_13)
                            || (*__self_0_14) != (*__self_1_14)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ContractCreateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.initcode_source {
                oneof.encode(buf)
            }
            if let Some(ref msg) = self.admin_key {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if self.gas != 0i64 {
                ::prost::encoding::int64::encode(4u32, &self.gas, buf);
            }
            if self.initial_balance != 0i64 {
                ::prost::encoding::int64::encode(5u32, &self.initial_balance, buf);
            }
            if let Some(ref msg) = self.proxy_account_id {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_period {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
            if self.constructor_parameters != b"" as &[u8] {
                ::prost::encoding::bytes::encode(9u32, &self.constructor_parameters, buf);
            }
            if let Some(ref msg) = self.shard_id {
                ::prost::encoding::message::encode(10u32, msg, buf);
            }
            if let Some(ref msg) = self.realm_id {
                ::prost::encoding::message::encode(11u32, msg, buf);
            }
            if let Some(ref msg) = self.new_realm_admin_key {
                ::prost::encoding::message::encode(12u32, msg, buf);
            }
            if self.memo != "" {
                ::prost::encoding::string::encode(13u32, &self.memo, buf);
            }
            if self.max_automatic_token_associations != 0i32 {
                ::prost::encoding::int32::encode(
                    14u32,
                    &self.max_automatic_token_associations,
                    buf,
                );
            }
            if let Some(ref msg) = self.auto_renew_account_id {
                ::prost::encoding::message::encode(15u32, msg, buf);
            }
            if let Some(ref oneof) = self.staked_id {
                oneof.encode(buf)
            }
            if self.decline_reward != false {
                ::prost::encoding::bool::encode(19u32, &self.decline_reward, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractCreateTransactionBody";
            match tag {
                1u32 | 16u32 => {
                    let mut value = &mut self.initcode_source;
                    contract_create_transaction_body::InitcodeSource::merge(
                        value, tag, wire_type, buf, ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "initcode_source");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "admin_key");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.gas;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "gas");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.initial_balance;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "initial_balance");
                            error
                        },
                    )
                }
                6u32 => {
                    let mut value = &mut self.proxy_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "proxy_account_id");
                        error
                    })
                }
                8u32 => {
                    let mut value = &mut self.auto_renew_period;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_period");
                        error
                    })
                }
                9u32 => {
                    let mut value = &mut self.constructor_parameters;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "constructor_parameters");
                            error
                        },
                    )
                }
                10u32 => {
                    let mut value = &mut self.shard_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "shard_id");
                        error
                    })
                }
                11u32 => {
                    let mut value = &mut self.realm_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "realm_id");
                        error
                    })
                }
                12u32 => {
                    let mut value = &mut self.new_realm_admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "new_realm_admin_key");
                        error
                    })
                }
                13u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                14u32 => {
                    let mut value = &mut self.max_automatic_token_associations;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "max_automatic_token_associations");
                            error
                        },
                    )
                }
                15u32 => {
                    let mut value = &mut self.auto_renew_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_account_id");
                        error
                    })
                }
                17u32 | 18u32 => {
                    let mut value = &mut self.staked_id;
                    contract_create_transaction_body::StakedId::merge(
                        value, tag, wire_type, buf, ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "staked_id");
                        error
                    })
                }
                19u32 => {
                    let mut value = &mut self.decline_reward;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "decline_reward");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.initcode_source.as_ref().map_or(
                0,
                contract_create_transaction_body::InitcodeSource::encoded_len,
            ) + self
                .admin_key
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + if self.gas != 0i64 {
                    ::prost::encoding::int64::encoded_len(4u32, &self.gas)
                } else {
                    0
                }
                + if self.initial_balance != 0i64 {
                    ::prost::encoding::int64::encoded_len(5u32, &self.initial_balance)
                } else {
                    0
                }
                + self
                    .proxy_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                + self
                    .auto_renew_period
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(8u32, msg))
                + if self.constructor_parameters != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(9u32, &self.constructor_parameters)
                } else {
                    0
                }
                + self
                    .shard_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(10u32, msg))
                + self
                    .realm_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(11u32, msg))
                + self
                    .new_realm_admin_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(12u32, msg))
                + if self.memo != "" {
                    ::prost::encoding::string::encoded_len(13u32, &self.memo)
                } else {
                    0
                }
                + if self.max_automatic_token_associations != 0i32 {
                    ::prost::encoding::int32::encoded_len(
                        14u32,
                        &self.max_automatic_token_associations,
                    )
                } else {
                    0
                }
                + self
                    .auto_renew_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(15u32, msg))
                + self
                    .staked_id
                    .as_ref()
                    .map_or(0, contract_create_transaction_body::StakedId::encoded_len)
                + if self.decline_reward != false {
                    ::prost::encoding::bool::encoded_len(19u32, &self.decline_reward)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.initcode_source = ::core::option::Option::None;
            self.admin_key = ::core::option::Option::None;
            self.gas = 0i64;
            self.initial_balance = 0i64;
            self.proxy_account_id = ::core::option::Option::None;
            self.auto_renew_period = ::core::option::Option::None;
            self.constructor_parameters.clear();
            self.shard_id = ::core::option::Option::None;
            self.realm_id = ::core::option::Option::None;
            self.new_realm_admin_key = ::core::option::Option::None;
            self.memo.clear();
            self.max_automatic_token_associations = 0i32;
            self.auto_renew_account_id = ::core::option::Option::None;
            self.staked_id = ::core::option::Option::None;
            self.decline_reward = false;
        }
    }
    impl ::core::default::Default for ContractCreateTransactionBody {
        fn default() -> Self {
            ContractCreateTransactionBody {
                initcode_source: ::core::default::Default::default(),
                admin_key: ::core::default::Default::default(),
                gas: 0i64,
                initial_balance: 0i64,
                proxy_account_id: ::core::default::Default::default(),
                auto_renew_period: ::core::default::Default::default(),
                constructor_parameters: ::core::default::Default::default(),
                shard_id: ::core::default::Default::default(),
                realm_id: ::core::default::Default::default(),
                new_realm_admin_key: ::core::default::Default::default(),
                memo: ::prost::alloc::string::String::new(),
                max_automatic_token_associations: 0i32,
                auto_renew_account_id: ::core::default::Default::default(),
                staked_id: ::core::default::Default::default(),
                decline_reward: false,
            }
        }
    }
    impl ::core::fmt::Debug for ContractCreateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractCreateTransactionBody");
            let builder = {
                let wrapper = &self.admin_key;
                builder.field("admin_key", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.gas)
                };
                builder.field("gas", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.initial_balance)
                };
                builder.field("initial_balance", &wrapper)
            };
            let builder = {
                let wrapper = &self.proxy_account_id;
                builder.field("proxy_account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_period;
                builder.field("auto_renew_period", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.constructor_parameters)
                };
                builder.field("constructor_parameters", &wrapper)
            };
            let builder = {
                let wrapper = &self.shard_id;
                builder.field("shard_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.realm_id;
                builder.field("realm_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.new_realm_admin_key;
                builder.field("new_realm_admin_key", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.max_automatic_token_associations)
                };
                builder.field("max_automatic_token_associations", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_account_id;
                builder.field("auto_renew_account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.decline_reward)
                };
                builder.field("decline_reward", &wrapper)
            };
            let builder = {
                let wrapper = &self.initcode_source;
                builder.field("initcode_source", &wrapper)
            };
            let builder = {
                let wrapper = &self.staked_id;
                builder.field("staked_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `ContractCreateTransactionBody`.
    pub mod contract_create_transaction_body {
        /// There are two ways to specify the initcode of a ContractCreateTransction. If the initcode is
        /// large (> 5K) then it must be stored in a file as hex encoded ascii. If it is small then it may
        /// either be stored as a hex encoded file or as a binary encoded field as part of the transaciton.
        ///
        pub enum InitcodeSource {
            /// The file containing the smart contract initcode. A copy will be made and held by the
            /// contract instance, and have the same expiration time as the instance.
            #[prost(message, tag = "1")]
            FileId(super::FileId),
            /// The bytes of the smart contract initcode. This is only useful if the smart contract init
            /// is less than the hedera transaction limit. In those cases fileID must be used.
            #[prost(bytes, tag = "16")]
            Initcode(::prost::alloc::vec::Vec<u8>),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for InitcodeSource {
            #[inline]
            fn clone(&self) -> InitcodeSource {
                match (&*self,) {
                    (&InitcodeSource::FileId(ref __self_0),) => {
                        InitcodeSource::FileId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&InitcodeSource::Initcode(ref __self_0),) => {
                        InitcodeSource::Initcode(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for InitcodeSource {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for InitcodeSource {
            #[inline]
            fn eq(&self, other: &InitcodeSource) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &InitcodeSource::FileId(ref __self_0),
                                &InitcodeSource::FileId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &InitcodeSource::Initcode(ref __self_0),
                                &InitcodeSource::Initcode(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &InitcodeSource) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &InitcodeSource::FileId(ref __self_0),
                                &InitcodeSource::FileId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &InitcodeSource::Initcode(ref __self_0),
                                &InitcodeSource::Initcode(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl InitcodeSource {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    InitcodeSource::FileId(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                    InitcodeSource::Initcode(ref value) => {
                        ::prost::encoding::bytes::encode(16u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<InitcodeSource>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag { 1u32 => { match field { :: core :: option :: Option :: Some (InitcodeSource :: FileId (ref mut value)) => { :: prost :: encoding :: message :: merge (wire_type , value , buf , ctx) } _ => { let mut owned_value = :: core :: default :: Default :: default () ; let value = & mut owned_value ; :: prost :: encoding :: message :: merge (wire_type , value , buf , ctx) . map (| _ | * field = :: core :: option :: Option :: Some (InitcodeSource :: FileId (owned_value))) } } } 16u32 => { match field { :: core :: option :: Option :: Some (InitcodeSource :: Initcode (ref mut value)) => { :: prost :: encoding :: bytes :: merge (wire_type , value , buf , ctx) } _ => { let mut owned_value = :: core :: default :: Default :: default () ; let value = & mut owned_value ; :: prost :: encoding :: bytes :: merge (wire_type , value , buf , ctx) . map (| _ | * field = :: core :: option :: Option :: Some (InitcodeSource :: Initcode (owned_value))) } } } _ => :: core :: panicking :: panic_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["internal error: entered unreachable code: invalid InitcodeSource tag: "] , & [:: core :: fmt :: ArgumentV1 :: new_display (& tag)])) , }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    InitcodeSource::FileId(ref value) => {
                        ::prost::encoding::message::encoded_len(1u32, &*value)
                    }
                    InitcodeSource::Initcode(ref value) => {
                        ::prost::encoding::bytes::encoded_len(16u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for InitcodeSource {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    InitcodeSource::FileId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileId").field(&wrapper).finish()
                    }
                    InitcodeSource::Initcode(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Initcode").field(&wrapper).finish()
                    }
                }
            }
        }
        /// ID of the new account or node to which this contract is staking.
        pub enum StakedId {
            /// ID of the account to which this contract is staking.
            #[prost(message, tag = "17")]
            StakedAccountId(super::AccountId),
            /// ID of the node this contract is staked to.
            #[prost(int64, tag = "18")]
            StakedNodeId(i64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StakedId {
            #[inline]
            fn clone(&self) -> StakedId {
                match (&*self,) {
                    (&StakedId::StakedAccountId(ref __self_0),) => {
                        StakedId::StakedAccountId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&StakedId::StakedNodeId(ref __self_0),) => {
                        StakedId::StakedNodeId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for StakedId {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for StakedId {
            #[inline]
            fn eq(&self, other: &StakedId) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StakedId::StakedAccountId(ref __self_0),
                                &StakedId::StakedAccountId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &StakedId::StakedNodeId(ref __self_0),
                                &StakedId::StakedNodeId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &StakedId) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StakedId::StakedAccountId(ref __self_0),
                                &StakedId::StakedAccountId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &StakedId::StakedNodeId(ref __self_0),
                                &StakedId::StakedNodeId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl StakedId {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        ::prost::encoding::message::encode(17u32, &*value, buf);
                    }
                    StakedId::StakedNodeId(ref value) => {
                        ::prost::encoding::int64::encode(18u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<StakedId>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    17u32 => match field {
                        ::core::option::Option::Some(StakedId::StakedAccountId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        StakedId::StakedAccountId(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    18u32 => match field {
                        ::core::option::Option::Some(StakedId::StakedNodeId(ref mut value)) => {
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map(|_| {
                                *field = ::core::option::Option::Some(StakedId::StakedNodeId(
                                    owned_value,
                                ))
                            })
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid StakedId tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        ::prost::encoding::message::encoded_len(17u32, &*value)
                    }
                    StakedId::StakedNodeId(ref value) => {
                        ::prost::encoding::int64::encoded_len(18u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for StakedId {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("StakedAccountId").field(&wrapper).finish()
                    }
                    StakedId::StakedNodeId(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("StakedNodeId").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// At consensus, updates the fields of a smart contract to the given values.
    ///
    /// If no value is given for a field, that field is left unchanged on the contract. For an immutable
    /// smart contract (that is, a contract created without an adminKey), only the expirationTime may be
    /// updated; setting any other field in this case will cause the transaction status to resolve to
    /// MODIFYING_IMMUTABLE_CONTRACT.
    ///
    /// --- Signing Requirements ---
    /// 1. Whether or not a contract has an admin key, its expiry can be extended with only the
    ///    transaction payer's signature.
    /// 2. Updating any other field of a mutable contract requires the admin key's signature.
    /// 3. If the update transaction includes a new admin key, this new key must also sign <b>unless</b>
    ///    it is exactly an empty <tt>KeyList</tt>. This special sentinel key removes the existing admin
    ///    key and causes the contract to become immutable. (Other <tt>Key</tt> structures without a
    ///    constituent <tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)
    /// 4. If the update transaction sets the AccountID auto_renew_account_id wrapper field to anything
    ///    other than the sentinel <tt>0.0.0</tt> value, then the key of the referenced account must sign.
    pub struct ContractUpdateTransactionBody {
        /// The id of the contract to be updated
        #[prost(message, optional, tag = "1")]
        pub contract_id: ::core::option::Option<ContractId>,
        /// The new expiry of the contract, no earlier than the current expiry (resolves to
        /// EXPIRATION_REDUCTION_NOT_ALLOWED otherwise)
        #[prost(message, optional, tag = "2")]
        pub expiration_time: ::core::option::Option<Timestamp>,
        /// The new key to control updates to the contract
        #[prost(message, optional, tag = "3")]
        pub admin_key: ::core::option::Option<Key>,
        /// \[Deprecated\] The new id of the account to which the contract is proxy staked
        #[deprecated]
        #[prost(message, optional, tag = "6")]
        pub proxy_account_id: ::core::option::Option<AccountId>,
        /// (NOT YET IMPLEMENTED) The new interval at which the contract will pay to extend its expiry
        /// (by the same interval)
        #[prost(message, optional, tag = "7")]
        pub auto_renew_period: ::core::option::Option<Duration>,
        /// This field is unused and will have no impact on the specified smart contract.
        #[deprecated]
        #[prost(message, optional, tag = "8")]
        pub file_id: ::core::option::Option<FileId>,
        /// If set, the new maximum number of tokens that this contract can be
        /// automatically associated with (i.e., receive air-drops from).
        #[prost(message, optional, tag = "11")]
        pub max_automatic_token_associations: ::core::option::Option<i32>,
        /// If set to the sentinel <tt>0.0.0</tt> AccountID, this field removes the contract's auto-renew
        /// account. Otherwise it updates the contract's auto-renew account to the referenced account.
        #[prost(message, optional, tag = "12")]
        pub auto_renew_account_id: ::core::option::Option<AccountId>,
        /// If true, the contract declines receiving a staking reward.
        #[prost(message, optional, tag = "15")]
        pub decline_reward: ::core::option::Option<bool>,
        /// The new contract memo, assumed to be Unicode encoded with UTF-8 (at most 100 bytes)
        #[prost(oneof = "contract_update_transaction_body::MemoField", tags = "9, 10")]
        pub memo_field: ::core::option::Option<contract_update_transaction_body::MemoField>,
        /// ID of the new account or node to which this contract is staking.
        #[prost(oneof = "contract_update_transaction_body::StakedId", tags = "13, 14")]
        pub staked_id: ::core::option::Option<contract_update_transaction_body::StakedId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractUpdateTransactionBody {
        #[inline]
        fn clone(&self) -> ContractUpdateTransactionBody {
            match *self {
                ContractUpdateTransactionBody {
                    contract_id: ref __self_0_0,
                    expiration_time: ref __self_0_1,
                    admin_key: ref __self_0_2,
                    proxy_account_id: ref __self_0_3,
                    auto_renew_period: ref __self_0_4,
                    file_id: ref __self_0_5,
                    max_automatic_token_associations: ref __self_0_6,
                    auto_renew_account_id: ref __self_0_7,
                    decline_reward: ref __self_0_8,
                    memo_field: ref __self_0_9,
                    staked_id: ref __self_0_10,
                } => ContractUpdateTransactionBody {
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    expiration_time: ::core::clone::Clone::clone(&(*__self_0_1)),
                    admin_key: ::core::clone::Clone::clone(&(*__self_0_2)),
                    proxy_account_id: ::core::clone::Clone::clone(&(*__self_0_3)),
                    auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_4)),
                    file_id: ::core::clone::Clone::clone(&(*__self_0_5)),
                    max_automatic_token_associations: ::core::clone::Clone::clone(&(*__self_0_6)),
                    auto_renew_account_id: ::core::clone::Clone::clone(&(*__self_0_7)),
                    decline_reward: ::core::clone::Clone::clone(&(*__self_0_8)),
                    memo_field: ::core::clone::Clone::clone(&(*__self_0_9)),
                    staked_id: ::core::clone::Clone::clone(&(*__self_0_10)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractUpdateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractUpdateTransactionBody {
        #[inline]
        fn eq(&self, other: &ContractUpdateTransactionBody) -> bool {
            match *other {
                ContractUpdateTransactionBody {
                    contract_id: ref __self_1_0,
                    expiration_time: ref __self_1_1,
                    admin_key: ref __self_1_2,
                    proxy_account_id: ref __self_1_3,
                    auto_renew_period: ref __self_1_4,
                    file_id: ref __self_1_5,
                    max_automatic_token_associations: ref __self_1_6,
                    auto_renew_account_id: ref __self_1_7,
                    decline_reward: ref __self_1_8,
                    memo_field: ref __self_1_9,
                    staked_id: ref __self_1_10,
                } => match *self {
                    ContractUpdateTransactionBody {
                        contract_id: ref __self_0_0,
                        expiration_time: ref __self_0_1,
                        admin_key: ref __self_0_2,
                        proxy_account_id: ref __self_0_3,
                        auto_renew_period: ref __self_0_4,
                        file_id: ref __self_0_5,
                        max_automatic_token_associations: ref __self_0_6,
                        auto_renew_account_id: ref __self_0_7,
                        decline_reward: ref __self_0_8,
                        memo_field: ref __self_0_9,
                        staked_id: ref __self_0_10,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractUpdateTransactionBody) -> bool {
            match *other {
                ContractUpdateTransactionBody {
                    contract_id: ref __self_1_0,
                    expiration_time: ref __self_1_1,
                    admin_key: ref __self_1_2,
                    proxy_account_id: ref __self_1_3,
                    auto_renew_period: ref __self_1_4,
                    file_id: ref __self_1_5,
                    max_automatic_token_associations: ref __self_1_6,
                    auto_renew_account_id: ref __self_1_7,
                    decline_reward: ref __self_1_8,
                    memo_field: ref __self_1_9,
                    staked_id: ref __self_1_10,
                } => match *self {
                    ContractUpdateTransactionBody {
                        contract_id: ref __self_0_0,
                        expiration_time: ref __self_0_1,
                        admin_key: ref __self_0_2,
                        proxy_account_id: ref __self_0_3,
                        auto_renew_period: ref __self_0_4,
                        file_id: ref __self_0_5,
                        max_automatic_token_associations: ref __self_0_6,
                        auto_renew_account_id: ref __self_0_7,
                        decline_reward: ref __self_0_8,
                        memo_field: ref __self_0_9,
                        staked_id: ref __self_0_10,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ContractUpdateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.expiration_time {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.admin_key {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.proxy_account_id {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_period {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            if let Some(ref msg) = self.file_id {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
            if let Some(ref oneof) = self.memo_field {
                oneof.encode(buf)
            }
            if let Some(ref msg) = self.max_automatic_token_associations {
                ::prost::encoding::message::encode(11u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_account_id {
                ::prost::encoding::message::encode(12u32, msg, buf);
            }
            if let Some(ref oneof) = self.staked_id {
                oneof.encode(buf)
            }
            if let Some(ref msg) = self.decline_reward {
                ::prost::encoding::message::encode(15u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractUpdateTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.expiration_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiration_time");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "admin_key");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.proxy_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "proxy_account_id");
                        error
                    })
                }
                7u32 => {
                    let mut value = &mut self.auto_renew_period;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_period");
                        error
                    })
                }
                8u32 => {
                    let mut value = &mut self.file_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "file_id");
                        error
                    })
                }
                9u32 | 10u32 => {
                    let mut value = &mut self.memo_field;
                    contract_update_transaction_body::MemoField::merge(
                        value, tag, wire_type, buf, ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "memo_field");
                        error
                    })
                }
                11u32 => {
                    let mut value = &mut self.max_automatic_token_associations;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "max_automatic_token_associations");
                        error
                    })
                }
                12u32 => {
                    let mut value = &mut self.auto_renew_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_account_id");
                        error
                    })
                }
                13u32 | 14u32 => {
                    let mut value = &mut self.staked_id;
                    contract_update_transaction_body::StakedId::merge(
                        value, tag, wire_type, buf, ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "staked_id");
                        error
                    })
                }
                15u32 => {
                    let mut value = &mut self.decline_reward;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "decline_reward");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .contract_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .expiration_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .admin_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .proxy_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                + self
                    .auto_renew_period
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                + self
                    .file_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(8u32, msg))
                + self
                    .memo_field
                    .as_ref()
                    .map_or(0, contract_update_transaction_body::MemoField::encoded_len)
                + self
                    .max_automatic_token_associations
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(11u32, msg))
                + self
                    .auto_renew_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(12u32, msg))
                + self
                    .staked_id
                    .as_ref()
                    .map_or(0, contract_update_transaction_body::StakedId::encoded_len)
                + self
                    .decline_reward
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(15u32, msg))
        }
        fn clear(&mut self) {
            self.contract_id = ::core::option::Option::None;
            self.expiration_time = ::core::option::Option::None;
            self.admin_key = ::core::option::Option::None;
            self.proxy_account_id = ::core::option::Option::None;
            self.auto_renew_period = ::core::option::Option::None;
            self.file_id = ::core::option::Option::None;
            self.memo_field = ::core::option::Option::None;
            self.max_automatic_token_associations = ::core::option::Option::None;
            self.auto_renew_account_id = ::core::option::Option::None;
            self.staked_id = ::core::option::Option::None;
            self.decline_reward = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ContractUpdateTransactionBody {
        fn default() -> Self {
            ContractUpdateTransactionBody {
                contract_id: ::core::default::Default::default(),
                expiration_time: ::core::default::Default::default(),
                admin_key: ::core::default::Default::default(),
                proxy_account_id: ::core::default::Default::default(),
                auto_renew_period: ::core::default::Default::default(),
                file_id: ::core::default::Default::default(),
                memo_field: ::core::default::Default::default(),
                max_automatic_token_associations: ::core::default::Default::default(),
                auto_renew_account_id: ::core::default::Default::default(),
                staked_id: ::core::default::Default::default(),
                decline_reward: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractUpdateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractUpdateTransactionBody");
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiration_time;
                builder.field("expiration_time", &wrapper)
            };
            let builder = {
                let wrapper = &self.admin_key;
                builder.field("admin_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.proxy_account_id;
                builder.field("proxy_account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_period;
                builder.field("auto_renew_period", &wrapper)
            };
            let builder = {
                let wrapper = &self.file_id;
                builder.field("file_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.max_automatic_token_associations;
                builder.field("max_automatic_token_associations", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_account_id;
                builder.field("auto_renew_account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.decline_reward;
                builder.field("decline_reward", &wrapper)
            };
            let builder = {
                let wrapper = &self.memo_field;
                builder.field("memo_field", &wrapper)
            };
            let builder = {
                let wrapper = &self.staked_id;
                builder.field("staked_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `ContractUpdateTransactionBody`.
    pub mod contract_update_transaction_body {
        /// The new contract memo, assumed to be Unicode encoded with UTF-8 (at most 100 bytes)
        pub enum MemoField {
            /// \[Deprecated\] If set with a non-zero length, the new memo to be associated with the account
            /// (UTF-8 encoding max 100 bytes)
            #[prost(string, tag = "9")]
            Memo(::prost::alloc::string::String),
            /// If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes)
            #[prost(message, tag = "10")]
            MemoWrapper(::prost::alloc::string::String),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MemoField {
            #[inline]
            fn clone(&self) -> MemoField {
                match (&*self,) {
                    (&MemoField::Memo(ref __self_0),) => {
                        MemoField::Memo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&MemoField::MemoWrapper(ref __self_0),) => {
                        MemoField::MemoWrapper(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for MemoField {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for MemoField {
            #[inline]
            fn eq(&self, other: &MemoField) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&MemoField::Memo(ref __self_0), &MemoField::Memo(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &MemoField::MemoWrapper(ref __self_0),
                                &MemoField::MemoWrapper(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &MemoField) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&MemoField::Memo(ref __self_0), &MemoField::Memo(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &MemoField::MemoWrapper(ref __self_0),
                                &MemoField::MemoWrapper(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl MemoField {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    MemoField::Memo(ref value) => {
                        ::prost::encoding::string::encode(9u32, &*value, buf);
                    }
                    MemoField::MemoWrapper(ref value) => {
                        ::prost::encoding::message::encode(10u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<MemoField>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    9u32 => match field {
                        ::core::option::Option::Some(MemoField::Memo(ref mut value)) => {
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::string::merge(wire_type, value, buf, ctx).map(|_| {
                                *field = ::core::option::Option::Some(MemoField::Memo(owned_value))
                            })
                        }
                    },
                    10u32 => match field {
                        ::core::option::Option::Some(MemoField::MemoWrapper(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(MemoField::MemoWrapper(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid MemoField tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    MemoField::Memo(ref value) => {
                        ::prost::encoding::string::encoded_len(9u32, &*value)
                    }
                    MemoField::MemoWrapper(ref value) => {
                        ::prost::encoding::message::encoded_len(10u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for MemoField {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    MemoField::Memo(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("Memo").field(&wrapper).finish()
                    }
                    MemoField::MemoWrapper(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("MemoWrapper").field(&wrapper).finish()
                    }
                }
            }
        }
        /// ID of the new account or node to which this contract is staking.
        pub enum StakedId {
            /// ID of the new account to which this contract is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
            /// this field removes the contract's staked account ID.
            #[prost(message, tag = "13")]
            StakedAccountId(super::AccountId),
            /// ID of the new node this contract is staked to. If set to the sentinel <tt>-1</tt>, this field
            /// removes the contract's staked node ID.
            #[prost(int64, tag = "14")]
            StakedNodeId(i64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StakedId {
            #[inline]
            fn clone(&self) -> StakedId {
                match (&*self,) {
                    (&StakedId::StakedAccountId(ref __self_0),) => {
                        StakedId::StakedAccountId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&StakedId::StakedNodeId(ref __self_0),) => {
                        StakedId::StakedNodeId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for StakedId {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for StakedId {
            #[inline]
            fn eq(&self, other: &StakedId) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StakedId::StakedAccountId(ref __self_0),
                                &StakedId::StakedAccountId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &StakedId::StakedNodeId(ref __self_0),
                                &StakedId::StakedNodeId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &StakedId) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StakedId::StakedAccountId(ref __self_0),
                                &StakedId::StakedAccountId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &StakedId::StakedNodeId(ref __self_0),
                                &StakedId::StakedNodeId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl StakedId {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        ::prost::encoding::message::encode(13u32, &*value, buf);
                    }
                    StakedId::StakedNodeId(ref value) => {
                        ::prost::encoding::int64::encode(14u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<StakedId>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    13u32 => match field {
                        ::core::option::Option::Some(StakedId::StakedAccountId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        StakedId::StakedAccountId(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    14u32 => match field {
                        ::core::option::Option::Some(StakedId::StakedNodeId(ref mut value)) => {
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map(|_| {
                                *field = ::core::option::Option::Some(StakedId::StakedNodeId(
                                    owned_value,
                                ))
                            })
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid StakedId tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        ::prost::encoding::message::encoded_len(13u32, &*value)
                    }
                    StakedId::StakedNodeId(ref value) => {
                        ::prost::encoding::int64::encoded_len(14u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for StakedId {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("StakedAccountId").field(&wrapper).finish()
                    }
                    StakedId::StakedNodeId(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("StakedNodeId").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// A hash---presumably of some kind of credential or certificate---along with a list of keys, each
    /// of which may be either a primitive or a threshold key.
    pub struct LiveHash {
        /// The account to which the livehash is attached
        #[prost(message, optional, tag = "1")]
        pub account_id: ::core::option::Option<AccountId>,
        /// The SHA-384 hash of a credential or certificate
        #[prost(bytes = "vec", tag = "2")]
        pub hash: ::prost::alloc::vec::Vec<u8>,
        /// A list of keys (primitive or threshold), all of which must sign to attach the livehash to an account, and any one of which can later delete it.
        #[prost(message, optional, tag = "3")]
        pub keys: ::core::option::Option<KeyList>,
        /// The duration for which the livehash will remain valid
        #[prost(message, optional, tag = "5")]
        pub duration: ::core::option::Option<Duration>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for LiveHash {
        #[inline]
        fn clone(&self) -> LiveHash {
            match *self {
                LiveHash {
                    account_id: ref __self_0_0,
                    hash: ref __self_0_1,
                    keys: ref __self_0_2,
                    duration: ref __self_0_3,
                } => LiveHash {
                    account_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    hash: ::core::clone::Clone::clone(&(*__self_0_1)),
                    keys: ::core::clone::Clone::clone(&(*__self_0_2)),
                    duration: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for LiveHash {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for LiveHash {
        #[inline]
        fn eq(&self, other: &LiveHash) -> bool {
            match *other {
                LiveHash {
                    account_id: ref __self_1_0,
                    hash: ref __self_1_1,
                    keys: ref __self_1_2,
                    duration: ref __self_1_3,
                } => match *self {
                    LiveHash {
                        account_id: ref __self_0_0,
                        hash: ref __self_0_1,
                        keys: ref __self_0_2,
                        duration: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &LiveHash) -> bool {
            match *other {
                LiveHash {
                    account_id: ref __self_1_0,
                    hash: ref __self_1_1,
                    keys: ref __self_1_2,
                    duration: ref __self_1_3,
                } => match *self {
                    LiveHash {
                        account_id: ref __self_0_0,
                        hash: ref __self_0_1,
                        keys: ref __self_0_2,
                        duration: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for LiveHash {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.hash != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.hash, buf);
            }
            if let Some(ref msg) = self.keys {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.duration {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "LiveHash";
            match tag {
                1u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.hash;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "hash");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.keys;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "keys");
                        error
                    })
                }
                5u32 => {
                    let mut value = &mut self.duration;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "duration");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .account_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.hash != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(2u32, &self.hash)
                } else {
                    0
                }
                + self
                    .keys
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .duration
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
        }
        fn clear(&mut self) {
            self.account_id = ::core::option::Option::None;
            self.hash.clear();
            self.keys = ::core::option::Option::None;
            self.duration = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for LiveHash {
        fn default() -> Self {
            LiveHash {
                account_id: ::core::default::Default::default(),
                hash: ::core::default::Default::default(),
                keys: ::core::default::Default::default(),
                duration: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for LiveHash {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("LiveHash");
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.hash)
                };
                builder.field("hash", &wrapper)
            };
            let builder = {
                let wrapper = &self.keys;
                builder.field("keys", &wrapper)
            };
            let builder = {
                let wrapper = &self.duration;
                builder.field("duration", &wrapper)
            };
            builder.finish()
        }
    }
    /// At consensus, attaches the given livehash to the given account.  The hash can be deleted by the
    /// key controlling the account, or by any of the keys associated to the livehash.  Hence livehashes
    /// provide a revocation service for their implied credentials; for example, when an authority grants
    /// a credential to the account, the account owner will cosign with the authority (or authorities) to
    /// attach a hash of the credential to the account---hence proving the grant. If the credential is
    /// revoked, then any of the authorities may delete it (or the account owner). In this way, the
    /// livehash mechanism acts as a revocation service.  An account cannot have two identical livehashes
    /// associated. To modify the list of keys in a livehash, the livehash should first be deleted, then
    /// recreated with a new list of keys.
    pub struct CryptoAddLiveHashTransactionBody {
        /// A hash of some credential or certificate, along with the keys of the entities that asserted it validity
        #[prost(message, optional, tag = "3")]
        pub live_hash: ::core::option::Option<LiveHash>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoAddLiveHashTransactionBody {
        #[inline]
        fn clone(&self) -> CryptoAddLiveHashTransactionBody {
            match *self {
                CryptoAddLiveHashTransactionBody {
                    live_hash: ref __self_0_0,
                } => CryptoAddLiveHashTransactionBody {
                    live_hash: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoAddLiveHashTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoAddLiveHashTransactionBody {
        #[inline]
        fn eq(&self, other: &CryptoAddLiveHashTransactionBody) -> bool {
            match *other {
                CryptoAddLiveHashTransactionBody {
                    live_hash: ref __self_1_0,
                } => match *self {
                    CryptoAddLiveHashTransactionBody {
                        live_hash: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoAddLiveHashTransactionBody) -> bool {
            match *other {
                CryptoAddLiveHashTransactionBody {
                    live_hash: ref __self_1_0,
                } => match *self {
                    CryptoAddLiveHashTransactionBody {
                        live_hash: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for CryptoAddLiveHashTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.live_hash {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoAddLiveHashTransactionBody";
            match tag {
                3u32 => {
                    let mut value = &mut self.live_hash;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "live_hash");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .live_hash
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
        }
        fn clear(&mut self) {
            self.live_hash = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CryptoAddLiveHashTransactionBody {
        fn default() -> Self {
            CryptoAddLiveHashTransactionBody {
                live_hash: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoAddLiveHashTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoAddLiveHashTransactionBody");
            let builder = {
                let wrapper = &self.live_hash;
                builder.field("live_hash", &wrapper)
            };
            builder.finish()
        }
    }
    ///
    /// Create a new account. After the account is created, the AccountID for it is in the receipt. It
    /// can also be retrieved with a GetByKey query. Threshold values can be defined, and records are
    /// generated and stored for 25 hours for any transfer that exceeds the thresholds. This account is
    /// charged for each record generated, so the thresholds are useful for limiting record generation to
    /// happen only for large transactions.
    ///
    /// The Key field is the key used to sign transactions for this account. If the account has
    /// receiverSigRequired set to true, then all cryptocurrency transfers must be signed by this
    /// account's key, both for transfers in and out. If it is false, then only transfers out have to be
    /// signed by it. When the account is created, the payer account is charged enough hbars so that the
    /// new account will not expire for the next autoRenewPeriod seconds. When it reaches the expiration
    /// time, the new account will then be automatically charged to renew for another autoRenewPeriod
    /// seconds. If it does not have enough hbars to renew for that long, then the remaining hbars are
    /// used to extend its expiration as long as possible. If it is has a zero balance when it expires,
    /// then it is deleted. This transaction must be signed by the payer account. If receiverSigRequired
    /// is false, then the transaction does not have to be signed by the keys in the keys field. If it is
    /// true, then it must be signed by them, in addition to the keys of the payer account.
    ///
    /// An entity (account, file, or smart contract instance) must be created in a particular realm. If
    /// the realmID is left null, then a new realm will be created with the given admin key. If a new
    /// realm has a null adminKey, then anyone can create/modify/delete entities in that realm. But if an
    /// admin key is given, then any transaction to create/modify/delete an entity in that realm must be
    /// signed by that key, though anyone can still call functions on smart contract instances that exist
    /// in that realm. A realm ceases to exist when everything within it has expired and no longer
    /// exists.
    ///
    /// The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0
    /// and realm 0, with a null key. Future versions of the API will support multiple realms and
    /// multiple shards.
    pub struct CryptoCreateTransactionBody {
        /// The key that must sign each transfer out of the account. If receiverSigRequired is true, then
        /// it must also sign any transfer into the account.
        #[prost(message, optional, tag = "1")]
        pub key: ::core::option::Option<Key>,
        /// The initial number of tinybars to put into the account
        #[prost(uint64, tag = "2")]
        pub initial_balance: u64,
        /// \[Deprecated\] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
        /// invalid account, or is an account that isn't a node, then this account is automatically proxy
        /// staked to a node chosen by the network, but without earning payments. If the proxyAccountID
        /// account refuses to accept proxy staking , or if it is not currently running a node, then it
        /// will behave as if proxyAccountID was null.
        #[deprecated]
        #[prost(message, optional, tag = "3")]
        pub proxy_account_id: ::core::option::Option<AccountId>,
        /// \[Deprecated\]. The threshold amount (in tinybars) for which an account record is created for
        /// any send/withdraw transaction
        #[deprecated]
        #[prost(uint64, tag = "6")]
        pub send_record_threshold: u64,
        /// \[Deprecated\]. The threshold amount (in tinybars) for which an account record is created for
        /// any receive/deposit transaction
        #[deprecated]
        #[prost(uint64, tag = "7")]
        pub receive_record_threshold: u64,
        /// If true, this account's key must sign any transaction depositing into this account (in
        /// addition to all withdrawals)
        #[prost(bool, tag = "8")]
        pub receiver_sig_required: bool,
        /// The account is charged to extend its expiration date every this many seconds. If it doesn't
        /// have enough balance, it extends as long as possible. If it is empty when it expires, then it
        /// is deleted.
        #[prost(message, optional, tag = "9")]
        pub auto_renew_period: ::core::option::Option<Duration>,
        /// The shard in which this account is created
        #[prost(message, optional, tag = "10")]
        pub shard_id: ::core::option::Option<ShardId>,
        /// The realm in which this account is created (leave this null to create a new realm)
        #[prost(message, optional, tag = "11")]
        pub realm_id: ::core::option::Option<RealmId>,
        /// If realmID is null, then this the admin key for the new realm that will be created
        #[prost(message, optional, tag = "12")]
        pub new_realm_admin_key: ::core::option::Option<Key>,
        /// The memo associated with the account (UTF-8 encoding max 100 bytes)
        #[prost(string, tag = "13")]
        pub memo: ::prost::alloc::string::String,
        /// The maximum number of tokens that an Account can be implicitly associated with. Defaults to 0
        /// and up to a maximum value of 1000.
        #[prost(int32, tag = "14")]
        pub max_automatic_token_associations: i32,
        /// If true, the account declines receiving a staking reward. The default value is false.
        #[prost(bool, tag = "17")]
        pub decline_reward: bool,
        /// ID of the account or node to which this account is staking.
        #[prost(oneof = "crypto_create_transaction_body::StakedId", tags = "15, 16")]
        pub staked_id: ::core::option::Option<crypto_create_transaction_body::StakedId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoCreateTransactionBody {
        #[inline]
        fn clone(&self) -> CryptoCreateTransactionBody {
            match *self {
                CryptoCreateTransactionBody {
                    key: ref __self_0_0,
                    initial_balance: ref __self_0_1,
                    proxy_account_id: ref __self_0_2,
                    send_record_threshold: ref __self_0_3,
                    receive_record_threshold: ref __self_0_4,
                    receiver_sig_required: ref __self_0_5,
                    auto_renew_period: ref __self_0_6,
                    shard_id: ref __self_0_7,
                    realm_id: ref __self_0_8,
                    new_realm_admin_key: ref __self_0_9,
                    memo: ref __self_0_10,
                    max_automatic_token_associations: ref __self_0_11,
                    decline_reward: ref __self_0_12,
                    staked_id: ref __self_0_13,
                } => CryptoCreateTransactionBody {
                    key: ::core::clone::Clone::clone(&(*__self_0_0)),
                    initial_balance: ::core::clone::Clone::clone(&(*__self_0_1)),
                    proxy_account_id: ::core::clone::Clone::clone(&(*__self_0_2)),
                    send_record_threshold: ::core::clone::Clone::clone(&(*__self_0_3)),
                    receive_record_threshold: ::core::clone::Clone::clone(&(*__self_0_4)),
                    receiver_sig_required: ::core::clone::Clone::clone(&(*__self_0_5)),
                    auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_6)),
                    shard_id: ::core::clone::Clone::clone(&(*__self_0_7)),
                    realm_id: ::core::clone::Clone::clone(&(*__self_0_8)),
                    new_realm_admin_key: ::core::clone::Clone::clone(&(*__self_0_9)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_10)),
                    max_automatic_token_associations: ::core::clone::Clone::clone(&(*__self_0_11)),
                    decline_reward: ::core::clone::Clone::clone(&(*__self_0_12)),
                    staked_id: ::core::clone::Clone::clone(&(*__self_0_13)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoCreateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoCreateTransactionBody {
        #[inline]
        fn eq(&self, other: &CryptoCreateTransactionBody) -> bool {
            match *other {
                CryptoCreateTransactionBody {
                    key: ref __self_1_0,
                    initial_balance: ref __self_1_1,
                    proxy_account_id: ref __self_1_2,
                    send_record_threshold: ref __self_1_3,
                    receive_record_threshold: ref __self_1_4,
                    receiver_sig_required: ref __self_1_5,
                    auto_renew_period: ref __self_1_6,
                    shard_id: ref __self_1_7,
                    realm_id: ref __self_1_8,
                    new_realm_admin_key: ref __self_1_9,
                    memo: ref __self_1_10,
                    max_automatic_token_associations: ref __self_1_11,
                    decline_reward: ref __self_1_12,
                    staked_id: ref __self_1_13,
                } => match *self {
                    CryptoCreateTransactionBody {
                        key: ref __self_0_0,
                        initial_balance: ref __self_0_1,
                        proxy_account_id: ref __self_0_2,
                        send_record_threshold: ref __self_0_3,
                        receive_record_threshold: ref __self_0_4,
                        receiver_sig_required: ref __self_0_5,
                        auto_renew_period: ref __self_0_6,
                        shard_id: ref __self_0_7,
                        realm_id: ref __self_0_8,
                        new_realm_admin_key: ref __self_0_9,
                        memo: ref __self_0_10,
                        max_automatic_token_associations: ref __self_0_11,
                        decline_reward: ref __self_0_12,
                        staked_id: ref __self_0_13,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                            && (*__self_0_11) == (*__self_1_11)
                            && (*__self_0_12) == (*__self_1_12)
                            && (*__self_0_13) == (*__self_1_13)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoCreateTransactionBody) -> bool {
            match *other {
                CryptoCreateTransactionBody {
                    key: ref __self_1_0,
                    initial_balance: ref __self_1_1,
                    proxy_account_id: ref __self_1_2,
                    send_record_threshold: ref __self_1_3,
                    receive_record_threshold: ref __self_1_4,
                    receiver_sig_required: ref __self_1_5,
                    auto_renew_period: ref __self_1_6,
                    shard_id: ref __self_1_7,
                    realm_id: ref __self_1_8,
                    new_realm_admin_key: ref __self_1_9,
                    memo: ref __self_1_10,
                    max_automatic_token_associations: ref __self_1_11,
                    decline_reward: ref __self_1_12,
                    staked_id: ref __self_1_13,
                } => match *self {
                    CryptoCreateTransactionBody {
                        key: ref __self_0_0,
                        initial_balance: ref __self_0_1,
                        proxy_account_id: ref __self_0_2,
                        send_record_threshold: ref __self_0_3,
                        receive_record_threshold: ref __self_0_4,
                        receiver_sig_required: ref __self_0_5,
                        auto_renew_period: ref __self_0_6,
                        shard_id: ref __self_0_7,
                        realm_id: ref __self_0_8,
                        new_realm_admin_key: ref __self_0_9,
                        memo: ref __self_0_10,
                        max_automatic_token_associations: ref __self_0_11,
                        decline_reward: ref __self_0_12,
                        staked_id: ref __self_0_13,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                            || (*__self_0_11) != (*__self_1_11)
                            || (*__self_0_12) != (*__self_1_12)
                            || (*__self_0_13) != (*__self_1_13)
                    }
                },
            }
        }
    }
    impl ::prost::Message for CryptoCreateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.key {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.initial_balance != 0u64 {
                ::prost::encoding::uint64::encode(2u32, &self.initial_balance, buf);
            }
            if let Some(ref msg) = self.proxy_account_id {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if self.send_record_threshold != 0u64 {
                ::prost::encoding::uint64::encode(6u32, &self.send_record_threshold, buf);
            }
            if self.receive_record_threshold != 0u64 {
                ::prost::encoding::uint64::encode(7u32, &self.receive_record_threshold, buf);
            }
            if self.receiver_sig_required != false {
                ::prost::encoding::bool::encode(8u32, &self.receiver_sig_required, buf);
            }
            if let Some(ref msg) = self.auto_renew_period {
                ::prost::encoding::message::encode(9u32, msg, buf);
            }
            if let Some(ref msg) = self.shard_id {
                ::prost::encoding::message::encode(10u32, msg, buf);
            }
            if let Some(ref msg) = self.realm_id {
                ::prost::encoding::message::encode(11u32, msg, buf);
            }
            if let Some(ref msg) = self.new_realm_admin_key {
                ::prost::encoding::message::encode(12u32, msg, buf);
            }
            if self.memo != "" {
                ::prost::encoding::string::encode(13u32, &self.memo, buf);
            }
            if self.max_automatic_token_associations != 0i32 {
                ::prost::encoding::int32::encode(
                    14u32,
                    &self.max_automatic_token_associations,
                    buf,
                );
            }
            if let Some(ref oneof) = self.staked_id {
                oneof.encode(buf)
            }
            if self.decline_reward != false {
                ::prost::encoding::bool::encode(17u32, &self.decline_reward, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoCreateTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "key");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.initial_balance;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "initial_balance");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.proxy_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "proxy_account_id");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.send_record_threshold;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "send_record_threshold");
                            error
                        },
                    )
                }
                7u32 => {
                    let mut value = &mut self.receive_record_threshold;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "receive_record_threshold");
                            error
                        },
                    )
                }
                8u32 => {
                    let mut value = &mut self.receiver_sig_required;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "receiver_sig_required");
                            error
                        },
                    )
                }
                9u32 => {
                    let mut value = &mut self.auto_renew_period;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_period");
                        error
                    })
                }
                10u32 => {
                    let mut value = &mut self.shard_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "shard_id");
                        error
                    })
                }
                11u32 => {
                    let mut value = &mut self.realm_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "realm_id");
                        error
                    })
                }
                12u32 => {
                    let mut value = &mut self.new_realm_admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "new_realm_admin_key");
                        error
                    })
                }
                13u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                14u32 => {
                    let mut value = &mut self.max_automatic_token_associations;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "max_automatic_token_associations");
                            error
                        },
                    )
                }
                15u32 | 16u32 => {
                    let mut value = &mut self.staked_id;
                    crypto_create_transaction_body::StakedId::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "staked_id");
                            error
                        })
                }
                17u32 => {
                    let mut value = &mut self.decline_reward;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "decline_reward");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .key
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.initial_balance != 0u64 {
                    ::prost::encoding::uint64::encoded_len(2u32, &self.initial_balance)
                } else {
                    0
                }
                + self
                    .proxy_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + if self.send_record_threshold != 0u64 {
                    ::prost::encoding::uint64::encoded_len(6u32, &self.send_record_threshold)
                } else {
                    0
                }
                + if self.receive_record_threshold != 0u64 {
                    ::prost::encoding::uint64::encoded_len(7u32, &self.receive_record_threshold)
                } else {
                    0
                }
                + if self.receiver_sig_required != false {
                    ::prost::encoding::bool::encoded_len(8u32, &self.receiver_sig_required)
                } else {
                    0
                }
                + self
                    .auto_renew_period
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(9u32, msg))
                + self
                    .shard_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(10u32, msg))
                + self
                    .realm_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(11u32, msg))
                + self
                    .new_realm_admin_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(12u32, msg))
                + if self.memo != "" {
                    ::prost::encoding::string::encoded_len(13u32, &self.memo)
                } else {
                    0
                }
                + if self.max_automatic_token_associations != 0i32 {
                    ::prost::encoding::int32::encoded_len(
                        14u32,
                        &self.max_automatic_token_associations,
                    )
                } else {
                    0
                }
                + self
                    .staked_id
                    .as_ref()
                    .map_or(0, crypto_create_transaction_body::StakedId::encoded_len)
                + if self.decline_reward != false {
                    ::prost::encoding::bool::encoded_len(17u32, &self.decline_reward)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.key = ::core::option::Option::None;
            self.initial_balance = 0u64;
            self.proxy_account_id = ::core::option::Option::None;
            self.send_record_threshold = 0u64;
            self.receive_record_threshold = 0u64;
            self.receiver_sig_required = false;
            self.auto_renew_period = ::core::option::Option::None;
            self.shard_id = ::core::option::Option::None;
            self.realm_id = ::core::option::Option::None;
            self.new_realm_admin_key = ::core::option::Option::None;
            self.memo.clear();
            self.max_automatic_token_associations = 0i32;
            self.staked_id = ::core::option::Option::None;
            self.decline_reward = false;
        }
    }
    impl ::core::default::Default for CryptoCreateTransactionBody {
        fn default() -> Self {
            CryptoCreateTransactionBody {
                key: ::core::default::Default::default(),
                initial_balance: 0u64,
                proxy_account_id: ::core::default::Default::default(),
                send_record_threshold: 0u64,
                receive_record_threshold: 0u64,
                receiver_sig_required: false,
                auto_renew_period: ::core::default::Default::default(),
                shard_id: ::core::default::Default::default(),
                realm_id: ::core::default::Default::default(),
                new_realm_admin_key: ::core::default::Default::default(),
                memo: ::prost::alloc::string::String::new(),
                max_automatic_token_associations: 0i32,
                staked_id: ::core::default::Default::default(),
                decline_reward: false,
            }
        }
    }
    impl ::core::fmt::Debug for CryptoCreateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoCreateTransactionBody");
            let builder = {
                let wrapper = &self.key;
                builder.field("key", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.initial_balance)
                };
                builder.field("initial_balance", &wrapper)
            };
            let builder = {
                let wrapper = &self.proxy_account_id;
                builder.field("proxy_account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.send_record_threshold)
                };
                builder.field("send_record_threshold", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.receive_record_threshold)
                };
                builder.field("receive_record_threshold", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.receiver_sig_required)
                };
                builder.field("receiver_sig_required", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_period;
                builder.field("auto_renew_period", &wrapper)
            };
            let builder = {
                let wrapper = &self.shard_id;
                builder.field("shard_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.realm_id;
                builder.field("realm_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.new_realm_admin_key;
                builder.field("new_realm_admin_key", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.max_automatic_token_associations)
                };
                builder.field("max_automatic_token_associations", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.decline_reward)
                };
                builder.field("decline_reward", &wrapper)
            };
            let builder = {
                let wrapper = &self.staked_id;
                builder.field("staked_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `CryptoCreateTransactionBody`.
    pub mod crypto_create_transaction_body {
        /// ID of the account or node to which this account is staking.
        pub enum StakedId {
            /// ID of the account to which this account is staking.
            #[prost(message, tag = "15")]
            StakedAccountId(super::AccountId),
            /// ID of the node this account is staked to.
            #[prost(int64, tag = "16")]
            StakedNodeId(i64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StakedId {
            #[inline]
            fn clone(&self) -> StakedId {
                match (&*self,) {
                    (&StakedId::StakedAccountId(ref __self_0),) => {
                        StakedId::StakedAccountId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&StakedId::StakedNodeId(ref __self_0),) => {
                        StakedId::StakedNodeId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for StakedId {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for StakedId {
            #[inline]
            fn eq(&self, other: &StakedId) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StakedId::StakedAccountId(ref __self_0),
                                &StakedId::StakedAccountId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &StakedId::StakedNodeId(ref __self_0),
                                &StakedId::StakedNodeId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &StakedId) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StakedId::StakedAccountId(ref __self_0),
                                &StakedId::StakedAccountId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &StakedId::StakedNodeId(ref __self_0),
                                &StakedId::StakedNodeId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl StakedId {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        ::prost::encoding::message::encode(15u32, &*value, buf);
                    }
                    StakedId::StakedNodeId(ref value) => {
                        ::prost::encoding::int64::encode(16u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<StakedId>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    15u32 => match field {
                        ::core::option::Option::Some(StakedId::StakedAccountId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        StakedId::StakedAccountId(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    16u32 => match field {
                        ::core::option::Option::Some(StakedId::StakedNodeId(ref mut value)) => {
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map(|_| {
                                *field = ::core::option::Option::Some(StakedId::StakedNodeId(
                                    owned_value,
                                ))
                            })
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid StakedId tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        ::prost::encoding::message::encoded_len(15u32, &*value)
                    }
                    StakedId::StakedNodeId(ref value) => {
                        ::prost::encoding::int64::encoded_len(16u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for StakedId {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("StakedAccountId").field(&wrapper).finish()
                    }
                    StakedId::StakedNodeId(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("StakedNodeId").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// Mark an account as deleted, moving all its current hbars to another account. It will remain in
    /// the ledger, marked as deleted, until it expires. Transfers into it a deleted account fail. But a
    /// deleted account can still have its expiration extended in the normal way.
    pub struct CryptoDeleteTransactionBody {
        /// The account ID which will receive all remaining hbars
        #[prost(message, optional, tag = "1")]
        pub transfer_account_id: ::core::option::Option<AccountId>,
        /// The account ID which should be deleted
        #[prost(message, optional, tag = "2")]
        pub delete_account_id: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoDeleteTransactionBody {
        #[inline]
        fn clone(&self) -> CryptoDeleteTransactionBody {
            match *self {
                CryptoDeleteTransactionBody {
                    transfer_account_id: ref __self_0_0,
                    delete_account_id: ref __self_0_1,
                } => CryptoDeleteTransactionBody {
                    transfer_account_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    delete_account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoDeleteTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoDeleteTransactionBody {
        #[inline]
        fn eq(&self, other: &CryptoDeleteTransactionBody) -> bool {
            match *other {
                CryptoDeleteTransactionBody {
                    transfer_account_id: ref __self_1_0,
                    delete_account_id: ref __self_1_1,
                } => match *self {
                    CryptoDeleteTransactionBody {
                        transfer_account_id: ref __self_0_0,
                        delete_account_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoDeleteTransactionBody) -> bool {
            match *other {
                CryptoDeleteTransactionBody {
                    transfer_account_id: ref __self_1_0,
                    delete_account_id: ref __self_1_1,
                } => match *self {
                    CryptoDeleteTransactionBody {
                        transfer_account_id: ref __self_0_0,
                        delete_account_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CryptoDeleteTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.transfer_account_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.delete_account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoDeleteTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.transfer_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transfer_account_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.delete_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "delete_account_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .transfer_account_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .delete_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.transfer_account_id = ::core::option::Option::None;
            self.delete_account_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CryptoDeleteTransactionBody {
        fn default() -> Self {
            CryptoDeleteTransactionBody {
                transfer_account_id: ::core::default::Default::default(),
                delete_account_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoDeleteTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoDeleteTransactionBody");
            let builder = {
                let wrapper = &self.transfer_account_id;
                builder.field("transfer_account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.delete_account_id;
                builder.field("delete_account_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// At consensus, deletes a livehash associated to the given account. The transaction must be signed
    /// by either the key of the owning account, or at least one of the keys associated to the livehash.
    pub struct CryptoDeleteLiveHashTransactionBody {
        /// The account owning the livehash
        #[prost(message, optional, tag = "1")]
        pub account_of_live_hash: ::core::option::Option<AccountId>,
        /// The SHA-384 livehash to delete from the account
        #[prost(bytes = "vec", tag = "2")]
        pub live_hash_to_delete: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoDeleteLiveHashTransactionBody {
        #[inline]
        fn clone(&self) -> CryptoDeleteLiveHashTransactionBody {
            match *self {
                CryptoDeleteLiveHashTransactionBody {
                    account_of_live_hash: ref __self_0_0,
                    live_hash_to_delete: ref __self_0_1,
                } => CryptoDeleteLiveHashTransactionBody {
                    account_of_live_hash: ::core::clone::Clone::clone(&(*__self_0_0)),
                    live_hash_to_delete: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoDeleteLiveHashTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoDeleteLiveHashTransactionBody {
        #[inline]
        fn eq(&self, other: &CryptoDeleteLiveHashTransactionBody) -> bool {
            match *other {
                CryptoDeleteLiveHashTransactionBody {
                    account_of_live_hash: ref __self_1_0,
                    live_hash_to_delete: ref __self_1_1,
                } => match *self {
                    CryptoDeleteLiveHashTransactionBody {
                        account_of_live_hash: ref __self_0_0,
                        live_hash_to_delete: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoDeleteLiveHashTransactionBody) -> bool {
            match *other {
                CryptoDeleteLiveHashTransactionBody {
                    account_of_live_hash: ref __self_1_0,
                    live_hash_to_delete: ref __self_1_1,
                } => match *self {
                    CryptoDeleteLiveHashTransactionBody {
                        account_of_live_hash: ref __self_0_0,
                        live_hash_to_delete: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CryptoDeleteLiveHashTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.account_of_live_hash {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.live_hash_to_delete != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.live_hash_to_delete, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoDeleteLiveHashTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.account_of_live_hash;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_of_live_hash");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.live_hash_to_delete;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "live_hash_to_delete");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .account_of_live_hash
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.live_hash_to_delete != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(2u32, &self.live_hash_to_delete)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.account_of_live_hash = ::core::option::Option::None;
            self.live_hash_to_delete.clear();
        }
    }
    impl ::core::default::Default for CryptoDeleteLiveHashTransactionBody {
        fn default() -> Self {
            CryptoDeleteLiveHashTransactionBody {
                account_of_live_hash: ::core::default::Default::default(),
                live_hash_to_delete: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoDeleteLiveHashTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoDeleteLiveHashTransactionBody");
            let builder = {
                let wrapper = &self.account_of_live_hash;
                builder.field("account_of_live_hash", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.live_hash_to_delete)
                };
                builder.field("live_hash_to_delete", &wrapper)
            };
            builder.finish()
        }
    }
    /// Transfers cryptocurrency among two or more accounts by making the desired adjustments to their
    /// balances. Each transfer list can specify up to 10 adjustments. Each negative amount is withdrawn
    /// from the corresponding account (a sender), and each positive one is added to the corresponding
    /// account (a receiver). The amounts list must sum to zero. Each amount is a number of tinybars
    /// (there are 100,000,000 tinybars in one hbar).  If any sender account fails to have sufficient
    /// hbars, then the entire transaction fails, and none of those transfers occur, though the
    /// transaction fee is still charged. This transaction must be signed by the keys for all the sending
    /// accounts, and for any receiving accounts that have receiverSigRequired == true. The signatures
    /// are in the same order as the accounts, skipping those accounts that don't need a signature.
    pub struct CryptoTransferTransactionBody {
        /// The desired hbar balance adjustments
        #[prost(message, optional, tag = "1")]
        pub transfers: ::core::option::Option<TransferList>,
        /// The desired token unit balance adjustments; if any custom fees are assessed, the ledger will
        /// try to deduct them from the payer of this CryptoTransfer, resolving the transaction to
        /// INSUFFICIENT_PAYER_BALANCE_FOR_CUSTOM_FEE if this is not possible
        #[prost(message, repeated, tag = "2")]
        pub token_transfers: ::prost::alloc::vec::Vec<TokenTransferList>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoTransferTransactionBody {
        #[inline]
        fn clone(&self) -> CryptoTransferTransactionBody {
            match *self {
                CryptoTransferTransactionBody {
                    transfers: ref __self_0_0,
                    token_transfers: ref __self_0_1,
                } => CryptoTransferTransactionBody {
                    transfers: ::core::clone::Clone::clone(&(*__self_0_0)),
                    token_transfers: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoTransferTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoTransferTransactionBody {
        #[inline]
        fn eq(&self, other: &CryptoTransferTransactionBody) -> bool {
            match *other {
                CryptoTransferTransactionBody {
                    transfers: ref __self_1_0,
                    token_transfers: ref __self_1_1,
                } => match *self {
                    CryptoTransferTransactionBody {
                        transfers: ref __self_0_0,
                        token_transfers: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoTransferTransactionBody) -> bool {
            match *other {
                CryptoTransferTransactionBody {
                    transfers: ref __self_1_0,
                    token_transfers: ref __self_1_1,
                } => match *self {
                    CryptoTransferTransactionBody {
                        transfers: ref __self_0_0,
                        token_transfers: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CryptoTransferTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.transfers {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.token_transfers {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoTransferTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.transfers;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transfers");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.token_transfers;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "token_transfers");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .transfers
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.token_transfers)
        }
        fn clear(&mut self) {
            self.transfers = ::core::option::Option::None;
            self.token_transfers.clear();
        }
    }
    impl ::core::default::Default for CryptoTransferTransactionBody {
        fn default() -> Self {
            CryptoTransferTransactionBody {
                transfers: ::core::default::Default::default(),
                token_transfers: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoTransferTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoTransferTransactionBody");
            let builder = {
                let wrapper = &self.transfers;
                builder.field("transfers", &wrapper)
            };
            let builder = {
                let wrapper = &self.token_transfers;
                builder.field("token_transfers", &wrapper)
            };
            builder.finish()
        }
    }
    /// Change properties for the given account. Any null field is ignored (left unchanged). This
    /// transaction must be signed by the existing key for this account. If the transaction is changing
    /// the key field, then the transaction must be signed by both the old key (from before the change)
    /// and the new key. The old key must sign for security. The new key must sign as a safeguard to
    /// avoid accidentally changing to an invalid key, and then having no way to recover.
    pub struct CryptoUpdateTransactionBody {
        /// The account ID which is being updated in this transaction
        #[prost(message, optional, tag = "2")]
        pub account_id_to_update: ::core::option::Option<AccountId>,
        /// The new key
        #[prost(message, optional, tag = "3")]
        pub key: ::core::option::Option<Key>,
        /// \[Deprecated\] ID of the account to which this account is proxy staked. If proxyAccountID is null, or is an
        /// invalid account, or is an account that isn't a node, then this account is automatically proxy
        /// staked to a node chosen by the network, but without earning payments. If the proxyAccountID
        /// account refuses to accept proxy staking , or if it is not currently running a node, then it
        /// will behave as if proxyAccountID was null.
        #[deprecated]
        #[prost(message, optional, tag = "4")]
        pub proxy_account_id: ::core::option::Option<AccountId>,
        /// \[Deprecated\]. Payments earned from proxy staking are shared between the node and this
        /// account, with proxyFraction / 10000 going to this account
        #[deprecated]
        #[prost(int32, tag = "5")]
        pub proxy_fraction: i32,
        /// The duration in which it will automatically extend the expiration period. If it doesn't have
        /// enough balance, it extends as long as possible. If it is empty when it expires, then it is
        /// deleted.
        #[prost(message, optional, tag = "8")]
        pub auto_renew_period: ::core::option::Option<Duration>,
        /// The new expiration time to extend to (ignored if equal to or before the current one)
        #[prost(message, optional, tag = "9")]
        pub expiration_time: ::core::option::Option<Timestamp>,
        /// If set, the new memo to be associated with the account (UTF-8 encoding max 100 bytes)
        #[prost(message, optional, tag = "14")]
        pub memo: ::core::option::Option<::prost::alloc::string::String>,
        /// The maximum number of tokens that an Account can be implicitly associated with. Up to a 1000
        /// including implicit and explicit associations.
        #[prost(message, optional, tag = "15")]
        pub max_automatic_token_associations: ::core::option::Option<i32>,
        /// If true, the account declines receiving a staking reward. The default value is false.
        #[prost(message, optional, tag = "18")]
        pub decline_reward: ::core::option::Option<bool>,
        #[prost(
            oneof = "crypto_update_transaction_body::SendRecordThresholdField",
            tags = "6, 11"
        )]
        pub send_record_threshold_field:
            ::core::option::Option<crypto_update_transaction_body::SendRecordThresholdField>,
        #[prost(
            oneof = "crypto_update_transaction_body::ReceiveRecordThresholdField",
            tags = "7, 12"
        )]
        pub receive_record_threshold_field:
            ::core::option::Option<crypto_update_transaction_body::ReceiveRecordThresholdField>,
        #[prost(
            oneof = "crypto_update_transaction_body::ReceiverSigRequiredField",
            tags = "10, 13"
        )]
        pub receiver_sig_required_field:
            ::core::option::Option<crypto_update_transaction_body::ReceiverSigRequiredField>,
        /// ID of the account or node to which this account is staking.
        #[prost(oneof = "crypto_update_transaction_body::StakedId", tags = "16, 17")]
        pub staked_id: ::core::option::Option<crypto_update_transaction_body::StakedId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoUpdateTransactionBody {
        #[inline]
        fn clone(&self) -> CryptoUpdateTransactionBody {
            match *self {
                CryptoUpdateTransactionBody {
                    account_id_to_update: ref __self_0_0,
                    key: ref __self_0_1,
                    proxy_account_id: ref __self_0_2,
                    proxy_fraction: ref __self_0_3,
                    auto_renew_period: ref __self_0_4,
                    expiration_time: ref __self_0_5,
                    memo: ref __self_0_6,
                    max_automatic_token_associations: ref __self_0_7,
                    decline_reward: ref __self_0_8,
                    send_record_threshold_field: ref __self_0_9,
                    receive_record_threshold_field: ref __self_0_10,
                    receiver_sig_required_field: ref __self_0_11,
                    staked_id: ref __self_0_12,
                } => CryptoUpdateTransactionBody {
                    account_id_to_update: ::core::clone::Clone::clone(&(*__self_0_0)),
                    key: ::core::clone::Clone::clone(&(*__self_0_1)),
                    proxy_account_id: ::core::clone::Clone::clone(&(*__self_0_2)),
                    proxy_fraction: ::core::clone::Clone::clone(&(*__self_0_3)),
                    auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_4)),
                    expiration_time: ::core::clone::Clone::clone(&(*__self_0_5)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_6)),
                    max_automatic_token_associations: ::core::clone::Clone::clone(&(*__self_0_7)),
                    decline_reward: ::core::clone::Clone::clone(&(*__self_0_8)),
                    send_record_threshold_field: ::core::clone::Clone::clone(&(*__self_0_9)),
                    receive_record_threshold_field: ::core::clone::Clone::clone(&(*__self_0_10)),
                    receiver_sig_required_field: ::core::clone::Clone::clone(&(*__self_0_11)),
                    staked_id: ::core::clone::Clone::clone(&(*__self_0_12)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoUpdateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoUpdateTransactionBody {
        #[inline]
        fn eq(&self, other: &CryptoUpdateTransactionBody) -> bool {
            match *other {
                CryptoUpdateTransactionBody {
                    account_id_to_update: ref __self_1_0,
                    key: ref __self_1_1,
                    proxy_account_id: ref __self_1_2,
                    proxy_fraction: ref __self_1_3,
                    auto_renew_period: ref __self_1_4,
                    expiration_time: ref __self_1_5,
                    memo: ref __self_1_6,
                    max_automatic_token_associations: ref __self_1_7,
                    decline_reward: ref __self_1_8,
                    send_record_threshold_field: ref __self_1_9,
                    receive_record_threshold_field: ref __self_1_10,
                    receiver_sig_required_field: ref __self_1_11,
                    staked_id: ref __self_1_12,
                } => match *self {
                    CryptoUpdateTransactionBody {
                        account_id_to_update: ref __self_0_0,
                        key: ref __self_0_1,
                        proxy_account_id: ref __self_0_2,
                        proxy_fraction: ref __self_0_3,
                        auto_renew_period: ref __self_0_4,
                        expiration_time: ref __self_0_5,
                        memo: ref __self_0_6,
                        max_automatic_token_associations: ref __self_0_7,
                        decline_reward: ref __self_0_8,
                        send_record_threshold_field: ref __self_0_9,
                        receive_record_threshold_field: ref __self_0_10,
                        receiver_sig_required_field: ref __self_0_11,
                        staked_id: ref __self_0_12,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                            && (*__self_0_11) == (*__self_1_11)
                            && (*__self_0_12) == (*__self_1_12)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoUpdateTransactionBody) -> bool {
            match *other {
                CryptoUpdateTransactionBody {
                    account_id_to_update: ref __self_1_0,
                    key: ref __self_1_1,
                    proxy_account_id: ref __self_1_2,
                    proxy_fraction: ref __self_1_3,
                    auto_renew_period: ref __self_1_4,
                    expiration_time: ref __self_1_5,
                    memo: ref __self_1_6,
                    max_automatic_token_associations: ref __self_1_7,
                    decline_reward: ref __self_1_8,
                    send_record_threshold_field: ref __self_1_9,
                    receive_record_threshold_field: ref __self_1_10,
                    receiver_sig_required_field: ref __self_1_11,
                    staked_id: ref __self_1_12,
                } => match *self {
                    CryptoUpdateTransactionBody {
                        account_id_to_update: ref __self_0_0,
                        key: ref __self_0_1,
                        proxy_account_id: ref __self_0_2,
                        proxy_fraction: ref __self_0_3,
                        auto_renew_period: ref __self_0_4,
                        expiration_time: ref __self_0_5,
                        memo: ref __self_0_6,
                        max_automatic_token_associations: ref __self_0_7,
                        decline_reward: ref __self_0_8,
                        send_record_threshold_field: ref __self_0_9,
                        receive_record_threshold_field: ref __self_0_10,
                        receiver_sig_required_field: ref __self_0_11,
                        staked_id: ref __self_0_12,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                            || (*__self_0_11) != (*__self_1_11)
                            || (*__self_0_12) != (*__self_1_12)
                    }
                },
            }
        }
    }
    impl ::prost::Message for CryptoUpdateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.account_id_to_update {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.key {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.proxy_account_id {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            if self.proxy_fraction != 0i32 {
                ::prost::encoding::int32::encode(5u32, &self.proxy_fraction, buf);
            }
            if let Some(ref oneof) = self.send_record_threshold_field {
                oneof.encode(buf)
            }
            if let Some(ref oneof) = self.receive_record_threshold_field {
                oneof.encode(buf)
            }
            if let Some(ref msg) = self.auto_renew_period {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
            if let Some(ref msg) = self.expiration_time {
                ::prost::encoding::message::encode(9u32, msg, buf);
            }
            if let Some(ref oneof) = self.receiver_sig_required_field {
                oneof.encode(buf)
            }
            if let Some(ref msg) = self.memo {
                ::prost::encoding::message::encode(14u32, msg, buf);
            }
            if let Some(ref msg) = self.max_automatic_token_associations {
                ::prost::encoding::message::encode(15u32, msg, buf);
            }
            if let Some(ref oneof) = self.staked_id {
                oneof.encode(buf)
            }
            if let Some(ref msg) = self.decline_reward {
                ::prost::encoding::message::encode(18u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoUpdateTransactionBody";
            match tag {
                2u32 => {
                    let mut value = &mut self.account_id_to_update;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id_to_update");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "key");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.proxy_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "proxy_account_id");
                        error
                    })
                }
                5u32 => {
                    let mut value = &mut self.proxy_fraction;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "proxy_fraction");
                            error
                        },
                    )
                }
                6u32 | 11u32 => {
                    let mut value = &mut self.send_record_threshold_field;
                    crypto_update_transaction_body::SendRecordThresholdField::merge(
                        value, tag, wire_type, buf, ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "send_record_threshold_field");
                        error
                    })
                }
                7u32 | 12u32 => {
                    let mut value = &mut self.receive_record_threshold_field;
                    crypto_update_transaction_body::ReceiveRecordThresholdField::merge(
                        value, tag, wire_type, buf, ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "receive_record_threshold_field");
                        error
                    })
                }
                8u32 => {
                    let mut value = &mut self.auto_renew_period;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_period");
                        error
                    })
                }
                9u32 => {
                    let mut value = &mut self.expiration_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiration_time");
                        error
                    })
                }
                10u32 | 13u32 => {
                    let mut value = &mut self.receiver_sig_required_field;
                    crypto_update_transaction_body::ReceiverSigRequiredField::merge(
                        value, tag, wire_type, buf, ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "receiver_sig_required_field");
                        error
                    })
                }
                14u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "memo");
                        error
                    })
                }
                15u32 => {
                    let mut value = &mut self.max_automatic_token_associations;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "max_automatic_token_associations");
                        error
                    })
                }
                16u32 | 17u32 => {
                    let mut value = &mut self.staked_id;
                    crypto_update_transaction_body::StakedId::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "staked_id");
                            error
                        })
                }
                18u32 => {
                    let mut value = &mut self.decline_reward;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "decline_reward");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .account_id_to_update
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .proxy_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + if self.proxy_fraction != 0i32 {
                    ::prost::encoding::int32::encoded_len(5u32, &self.proxy_fraction)
                } else {
                    0
                }
                + self.send_record_threshold_field.as_ref().map_or(
                    0,
                    crypto_update_transaction_body::SendRecordThresholdField::encoded_len,
                )
                + self.receive_record_threshold_field.as_ref().map_or(
                    0,
                    crypto_update_transaction_body::ReceiveRecordThresholdField::encoded_len,
                )
                + self
                    .auto_renew_period
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(8u32, msg))
                + self
                    .expiration_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(9u32, msg))
                + self.receiver_sig_required_field.as_ref().map_or(
                    0,
                    crypto_update_transaction_body::ReceiverSigRequiredField::encoded_len,
                )
                + self
                    .memo
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(14u32, msg))
                + self
                    .max_automatic_token_associations
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(15u32, msg))
                + self
                    .staked_id
                    .as_ref()
                    .map_or(0, crypto_update_transaction_body::StakedId::encoded_len)
                + self
                    .decline_reward
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(18u32, msg))
        }
        fn clear(&mut self) {
            self.account_id_to_update = ::core::option::Option::None;
            self.key = ::core::option::Option::None;
            self.proxy_account_id = ::core::option::Option::None;
            self.proxy_fraction = 0i32;
            self.send_record_threshold_field = ::core::option::Option::None;
            self.receive_record_threshold_field = ::core::option::Option::None;
            self.auto_renew_period = ::core::option::Option::None;
            self.expiration_time = ::core::option::Option::None;
            self.receiver_sig_required_field = ::core::option::Option::None;
            self.memo = ::core::option::Option::None;
            self.max_automatic_token_associations = ::core::option::Option::None;
            self.staked_id = ::core::option::Option::None;
            self.decline_reward = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CryptoUpdateTransactionBody {
        fn default() -> Self {
            CryptoUpdateTransactionBody {
                account_id_to_update: ::core::default::Default::default(),
                key: ::core::default::Default::default(),
                proxy_account_id: ::core::default::Default::default(),
                proxy_fraction: 0i32,
                send_record_threshold_field: ::core::default::Default::default(),
                receive_record_threshold_field: ::core::default::Default::default(),
                auto_renew_period: ::core::default::Default::default(),
                expiration_time: ::core::default::Default::default(),
                receiver_sig_required_field: ::core::default::Default::default(),
                memo: ::core::default::Default::default(),
                max_automatic_token_associations: ::core::default::Default::default(),
                staked_id: ::core::default::Default::default(),
                decline_reward: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoUpdateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoUpdateTransactionBody");
            let builder = {
                let wrapper = &self.account_id_to_update;
                builder.field("account_id_to_update", &wrapper)
            };
            let builder = {
                let wrapper = &self.key;
                builder.field("key", &wrapper)
            };
            let builder = {
                let wrapper = &self.proxy_account_id;
                builder.field("proxy_account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.proxy_fraction)
                };
                builder.field("proxy_fraction", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_period;
                builder.field("auto_renew_period", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiration_time;
                builder.field("expiration_time", &wrapper)
            };
            let builder = {
                let wrapper = &self.memo;
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = &self.max_automatic_token_associations;
                builder.field("max_automatic_token_associations", &wrapper)
            };
            let builder = {
                let wrapper = &self.decline_reward;
                builder.field("decline_reward", &wrapper)
            };
            let builder = {
                let wrapper = &self.send_record_threshold_field;
                builder.field("send_record_threshold_field", &wrapper)
            };
            let builder = {
                let wrapper = &self.receive_record_threshold_field;
                builder.field("receive_record_threshold_field", &wrapper)
            };
            let builder = {
                let wrapper = &self.receiver_sig_required_field;
                builder.field("receiver_sig_required_field", &wrapper)
            };
            let builder = {
                let wrapper = &self.staked_id;
                builder.field("staked_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `CryptoUpdateTransactionBody`.
    pub mod crypto_update_transaction_body {
        pub enum SendRecordThresholdField {
            /// \[Deprecated\]. The new threshold amount (in tinybars) for which an account record is
            /// created for any send/withdraw transaction
            #[prost(uint64, tag = "6")]
            SendRecordThreshold(u64),
            /// \[Deprecated\]. The new threshold amount (in tinybars) for which an account record is
            /// created for any send/withdraw transaction
            #[prost(message, tag = "11")]
            SendRecordThresholdWrapper(u64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SendRecordThresholdField {
            #[inline]
            fn clone(&self) -> SendRecordThresholdField {
                match (&*self,) {
                    (&SendRecordThresholdField::SendRecordThreshold(ref __self_0),) => {
                        SendRecordThresholdField::SendRecordThreshold(::core::clone::Clone::clone(
                            &(*__self_0),
                        ))
                    }
                    (&SendRecordThresholdField::SendRecordThresholdWrapper(ref __self_0),) => {
                        SendRecordThresholdField::SendRecordThresholdWrapper(
                            ::core::clone::Clone::clone(&(*__self_0)),
                        )
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for SendRecordThresholdField {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SendRecordThresholdField {
            #[inline]
            fn eq(&self, other: &SendRecordThresholdField) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &SendRecordThresholdField::SendRecordThreshold(ref __self_0),
                                &SendRecordThresholdField::SendRecordThreshold(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &SendRecordThresholdField::SendRecordThresholdWrapper(ref __self_0),
                                &SendRecordThresholdField::SendRecordThresholdWrapper(
                                    ref __arg_1_0,
                                ),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &SendRecordThresholdField) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &SendRecordThresholdField::SendRecordThreshold(ref __self_0),
                                &SendRecordThresholdField::SendRecordThreshold(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &SendRecordThresholdField::SendRecordThresholdWrapper(ref __self_0),
                                &SendRecordThresholdField::SendRecordThresholdWrapper(
                                    ref __arg_1_0,
                                ),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl SendRecordThresholdField {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    SendRecordThresholdField::SendRecordThreshold(ref value) => {
                        ::prost::encoding::uint64::encode(6u32, &*value, buf);
                    }
                    SendRecordThresholdField::SendRecordThresholdWrapper(ref value) => {
                        ::prost::encoding::message::encode(11u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<SendRecordThresholdField>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag { 6u32 => { match field { :: core :: option :: Option :: Some (SendRecordThresholdField :: SendRecordThreshold (ref mut value)) => { :: prost :: encoding :: uint64 :: merge (wire_type , value , buf , ctx) } _ => { let mut owned_value = :: core :: default :: Default :: default () ; let value = & mut owned_value ; :: prost :: encoding :: uint64 :: merge (wire_type , value , buf , ctx) . map (| _ | * field = :: core :: option :: Option :: Some (SendRecordThresholdField :: SendRecordThreshold (owned_value))) } } } 11u32 => { match field { :: core :: option :: Option :: Some (SendRecordThresholdField :: SendRecordThresholdWrapper (ref mut value)) => { :: prost :: encoding :: message :: merge (wire_type , value , buf , ctx) } _ => { let mut owned_value = :: core :: default :: Default :: default () ; let value = & mut owned_value ; :: prost :: encoding :: message :: merge (wire_type , value , buf , ctx) . map (| _ | * field = :: core :: option :: Option :: Some (SendRecordThresholdField :: SendRecordThresholdWrapper (owned_value))) } } } _ => :: core :: panicking :: panic_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["internal error: entered unreachable code: invalid SendRecordThresholdField tag: "] , & [:: core :: fmt :: ArgumentV1 :: new_display (& tag)])) , }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    SendRecordThresholdField::SendRecordThreshold(ref value) => {
                        ::prost::encoding::uint64::encoded_len(6u32, &*value)
                    }
                    SendRecordThresholdField::SendRecordThresholdWrapper(ref value) => {
                        ::prost::encoding::message::encoded_len(11u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for SendRecordThresholdField {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    SendRecordThresholdField::SendRecordThreshold(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("SendRecordThreshold")
                            .field(&wrapper)
                            .finish()
                    }
                    SendRecordThresholdField::SendRecordThresholdWrapper(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("SendRecordThresholdWrapper")
                            .field(&wrapper)
                            .finish()
                    }
                }
            }
        }
        pub enum ReceiveRecordThresholdField {
            /// \[Deprecated\]. The new threshold amount (in tinybars) for which an account record is
            /// created for any receive/deposit transaction.
            #[prost(uint64, tag = "7")]
            ReceiveRecordThreshold(u64),
            /// \[Deprecated\]. The new threshold amount (in tinybars) for which an account record is
            /// created for any receive/deposit transaction.
            #[prost(message, tag = "12")]
            ReceiveRecordThresholdWrapper(u64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ReceiveRecordThresholdField {
            #[inline]
            fn clone(&self) -> ReceiveRecordThresholdField {
                match (&*self,) {
                    (&ReceiveRecordThresholdField::ReceiveRecordThreshold(ref __self_0),) => {
                        ReceiveRecordThresholdField::ReceiveRecordThreshold(
                            ::core::clone::Clone::clone(&(*__self_0)),
                        )
                    }
                    (&ReceiveRecordThresholdField::ReceiveRecordThresholdWrapper(ref __self_0),) => {
                        ReceiveRecordThresholdField::ReceiveRecordThresholdWrapper(
                            ::core::clone::Clone::clone(&(*__self_0)),
                        )
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ReceiveRecordThresholdField {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ReceiveRecordThresholdField {
            #[inline]
            fn eq(&self, other: &ReceiveRecordThresholdField) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ReceiveRecordThresholdField::ReceiveRecordThreshold(ref __self_0),
                                &ReceiveRecordThresholdField::ReceiveRecordThreshold(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &ReceiveRecordThresholdField::ReceiveRecordThresholdWrapper(
                                    ref __self_0,
                                ),
                                &ReceiveRecordThresholdField::ReceiveRecordThresholdWrapper(
                                    ref __arg_1_0,
                                ),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &ReceiveRecordThresholdField) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ReceiveRecordThresholdField::ReceiveRecordThreshold(ref __self_0),
                                &ReceiveRecordThresholdField::ReceiveRecordThreshold(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &ReceiveRecordThresholdField::ReceiveRecordThresholdWrapper(
                                    ref __self_0,
                                ),
                                &ReceiveRecordThresholdField::ReceiveRecordThresholdWrapper(
                                    ref __arg_1_0,
                                ),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl ReceiveRecordThresholdField {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ReceiveRecordThresholdField::ReceiveRecordThreshold(ref value) => {
                        ::prost::encoding::uint64::encode(7u32, &*value, buf);
                    }
                    ReceiveRecordThresholdField::ReceiveRecordThresholdWrapper(ref value) => {
                        ::prost::encoding::message::encode(12u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<ReceiveRecordThresholdField>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag { 7u32 => { match field { :: core :: option :: Option :: Some (ReceiveRecordThresholdField :: ReceiveRecordThreshold (ref mut value)) => { :: prost :: encoding :: uint64 :: merge (wire_type , value , buf , ctx) } _ => { let mut owned_value = :: core :: default :: Default :: default () ; let value = & mut owned_value ; :: prost :: encoding :: uint64 :: merge (wire_type , value , buf , ctx) . map (| _ | * field = :: core :: option :: Option :: Some (ReceiveRecordThresholdField :: ReceiveRecordThreshold (owned_value))) } } } 12u32 => { match field { :: core :: option :: Option :: Some (ReceiveRecordThresholdField :: ReceiveRecordThresholdWrapper (ref mut value)) => { :: prost :: encoding :: message :: merge (wire_type , value , buf , ctx) } _ => { let mut owned_value = :: core :: default :: Default :: default () ; let value = & mut owned_value ; :: prost :: encoding :: message :: merge (wire_type , value , buf , ctx) . map (| _ | * field = :: core :: option :: Option :: Some (ReceiveRecordThresholdField :: ReceiveRecordThresholdWrapper (owned_value))) } } } _ => :: core :: panicking :: panic_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["internal error: entered unreachable code: invalid ReceiveRecordThresholdField tag: "] , & [:: core :: fmt :: ArgumentV1 :: new_display (& tag)])) , }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ReceiveRecordThresholdField::ReceiveRecordThreshold(ref value) => {
                        ::prost::encoding::uint64::encoded_len(7u32, &*value)
                    }
                    ReceiveRecordThresholdField::ReceiveRecordThresholdWrapper(ref value) => {
                        ::prost::encoding::message::encoded_len(12u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ReceiveRecordThresholdField {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ReceiveRecordThresholdField::ReceiveRecordThreshold(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("ReceiveRecordThreshold")
                            .field(&wrapper)
                            .finish()
                    }
                    ReceiveRecordThresholdField::ReceiveRecordThresholdWrapper(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReceiveRecordThresholdWrapper")
                            .field(&wrapper)
                            .finish()
                    }
                }
            }
        }
        pub enum ReceiverSigRequiredField {
            /// \[Deprecated\] Do NOT use this field to set a false value because the server cannot
            /// distinguish from the default value. Use receiverSigRequiredWrapper field for this
            /// purpose.
            #[prost(bool, tag = "10")]
            ReceiverSigRequired(bool),
            /// If true, this account's key must sign any transaction depositing into this account (in
            /// addition to all withdrawals)
            #[prost(message, tag = "13")]
            ReceiverSigRequiredWrapper(bool),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ReceiverSigRequiredField {
            #[inline]
            fn clone(&self) -> ReceiverSigRequiredField {
                match (&*self,) {
                    (&ReceiverSigRequiredField::ReceiverSigRequired(ref __self_0),) => {
                        ReceiverSigRequiredField::ReceiverSigRequired(::core::clone::Clone::clone(
                            &(*__self_0),
                        ))
                    }
                    (&ReceiverSigRequiredField::ReceiverSigRequiredWrapper(ref __self_0),) => {
                        ReceiverSigRequiredField::ReceiverSigRequiredWrapper(
                            ::core::clone::Clone::clone(&(*__self_0)),
                        )
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ReceiverSigRequiredField {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ReceiverSigRequiredField {
            #[inline]
            fn eq(&self, other: &ReceiverSigRequiredField) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ReceiverSigRequiredField::ReceiverSigRequired(ref __self_0),
                                &ReceiverSigRequiredField::ReceiverSigRequired(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &ReceiverSigRequiredField::ReceiverSigRequiredWrapper(ref __self_0),
                                &ReceiverSigRequiredField::ReceiverSigRequiredWrapper(
                                    ref __arg_1_0,
                                ),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &ReceiverSigRequiredField) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ReceiverSigRequiredField::ReceiverSigRequired(ref __self_0),
                                &ReceiverSigRequiredField::ReceiverSigRequired(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &ReceiverSigRequiredField::ReceiverSigRequiredWrapper(ref __self_0),
                                &ReceiverSigRequiredField::ReceiverSigRequiredWrapper(
                                    ref __arg_1_0,
                                ),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl ReceiverSigRequiredField {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    ReceiverSigRequiredField::ReceiverSigRequired(ref value) => {
                        ::prost::encoding::bool::encode(10u32, &*value, buf);
                    }
                    ReceiverSigRequiredField::ReceiverSigRequiredWrapper(ref value) => {
                        ::prost::encoding::message::encode(13u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<ReceiverSigRequiredField>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag { 10u32 => { match field { :: core :: option :: Option :: Some (ReceiverSigRequiredField :: ReceiverSigRequired (ref mut value)) => { :: prost :: encoding :: bool :: merge (wire_type , value , buf , ctx) } _ => { let mut owned_value = :: core :: default :: Default :: default () ; let value = & mut owned_value ; :: prost :: encoding :: bool :: merge (wire_type , value , buf , ctx) . map (| _ | * field = :: core :: option :: Option :: Some (ReceiverSigRequiredField :: ReceiverSigRequired (owned_value))) } } } 13u32 => { match field { :: core :: option :: Option :: Some (ReceiverSigRequiredField :: ReceiverSigRequiredWrapper (ref mut value)) => { :: prost :: encoding :: message :: merge (wire_type , value , buf , ctx) } _ => { let mut owned_value = :: core :: default :: Default :: default () ; let value = & mut owned_value ; :: prost :: encoding :: message :: merge (wire_type , value , buf , ctx) . map (| _ | * field = :: core :: option :: Option :: Some (ReceiverSigRequiredField :: ReceiverSigRequiredWrapper (owned_value))) } } } _ => :: core :: panicking :: panic_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["internal error: entered unreachable code: invalid ReceiverSigRequiredField tag: "] , & [:: core :: fmt :: ArgumentV1 :: new_display (& tag)])) , }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    ReceiverSigRequiredField::ReceiverSigRequired(ref value) => {
                        ::prost::encoding::bool::encoded_len(10u32, &*value)
                    }
                    ReceiverSigRequiredField::ReceiverSigRequiredWrapper(ref value) => {
                        ::prost::encoding::message::encoded_len(13u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for ReceiverSigRequiredField {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ReceiverSigRequiredField::ReceiverSigRequired(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("ReceiverSigRequired")
                            .field(&wrapper)
                            .finish()
                    }
                    ReceiverSigRequiredField::ReceiverSigRequiredWrapper(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ReceiverSigRequiredWrapper")
                            .field(&wrapper)
                            .finish()
                    }
                }
            }
        }
        /// ID of the account or node to which this account is staking.
        pub enum StakedId {
            /// ID of the new account to which this account is staking. If set to the sentinel <tt>0.0.0</tt> AccountID,
            /// this field removes this account's staked account ID.
            #[prost(message, tag = "16")]
            StakedAccountId(super::AccountId),
            /// ID of the new node this account is staked to. If set to the sentinel <tt>-1</tt>, this field
            /// removes this account's staked node ID.
            #[prost(int64, tag = "17")]
            StakedNodeId(i64),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StakedId {
            #[inline]
            fn clone(&self) -> StakedId {
                match (&*self,) {
                    (&StakedId::StakedAccountId(ref __self_0),) => {
                        StakedId::StakedAccountId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&StakedId::StakedNodeId(ref __self_0),) => {
                        StakedId::StakedNodeId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for StakedId {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for StakedId {
            #[inline]
            fn eq(&self, other: &StakedId) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StakedId::StakedAccountId(ref __self_0),
                                &StakedId::StakedAccountId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &StakedId::StakedNodeId(ref __self_0),
                                &StakedId::StakedNodeId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &StakedId) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StakedId::StakedAccountId(ref __self_0),
                                &StakedId::StakedAccountId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &StakedId::StakedNodeId(ref __self_0),
                                &StakedId::StakedNodeId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl StakedId {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        ::prost::encoding::message::encode(16u32, &*value, buf);
                    }
                    StakedId::StakedNodeId(ref value) => {
                        ::prost::encoding::int64::encode(17u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<StakedId>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    16u32 => match field {
                        ::core::option::Option::Some(StakedId::StakedAccountId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        StakedId::StakedAccountId(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    17u32 => match field {
                        ::core::option::Option::Some(StakedId::StakedNodeId(ref mut value)) => {
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map(|_| {
                                *field = ::core::option::Option::Some(StakedId::StakedNodeId(
                                    owned_value,
                                ))
                            })
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid StakedId tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        ::prost::encoding::message::encoded_len(16u32, &*value)
                    }
                    StakedId::StakedNodeId(ref value) => {
                        ::prost::encoding::int64::encoded_len(17u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for StakedId {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    StakedId::StakedAccountId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("StakedAccountId").field(&wrapper).finish()
                    }
                    StakedId::StakedNodeId(ref value) => {
                        let wrapper = {
                            fn ScalarWrapper<T>(v: T) -> T {
                                v
                            }
                            ScalarWrapper(&*value)
                        };
                        f.debug_tuple("StakedNodeId").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// Creates one or more hbar/token approved allowances <b>relative to the owner account specified in the allowances of
    /// this transaction</b>. Each allowance grants a spender the right to transfer a pre-determined amount of the owner's
    /// hbar/token to any other account of the spender's choice. If the owner is not specified in any allowance, the payer
    /// of transaction is considered to be the owner for that particular allowance.
    /// Setting the amount to zero in CryptoAllowance or TokenAllowance will remove the respective allowance for the spender.
    ///
    /// (So if account <tt>0.0.X</tt> pays for this transaction and owner is not specified in the allowance,
    /// then at consensus each spender account will have new allowances to spend hbar or tokens from <tt>0.0.X</tt>).
    pub struct CryptoApproveAllowanceTransactionBody {
        /// List of hbar allowances approved by the account owner.
        #[prost(message, repeated, tag = "1")]
        pub crypto_allowances: ::prost::alloc::vec::Vec<CryptoAllowance>,
        /// List of non-fungible token allowances approved by the account owner.
        #[prost(message, repeated, tag = "2")]
        pub nft_allowances: ::prost::alloc::vec::Vec<NftAllowance>,
        /// List of fungible token allowances approved by the account owner.
        #[prost(message, repeated, tag = "3")]
        pub token_allowances: ::prost::alloc::vec::Vec<TokenAllowance>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoApproveAllowanceTransactionBody {
        #[inline]
        fn clone(&self) -> CryptoApproveAllowanceTransactionBody {
            match *self {
                CryptoApproveAllowanceTransactionBody {
                    crypto_allowances: ref __self_0_0,
                    nft_allowances: ref __self_0_1,
                    token_allowances: ref __self_0_2,
                } => CryptoApproveAllowanceTransactionBody {
                    crypto_allowances: ::core::clone::Clone::clone(&(*__self_0_0)),
                    nft_allowances: ::core::clone::Clone::clone(&(*__self_0_1)),
                    token_allowances: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoApproveAllowanceTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoApproveAllowanceTransactionBody {
        #[inline]
        fn eq(&self, other: &CryptoApproveAllowanceTransactionBody) -> bool {
            match *other {
                CryptoApproveAllowanceTransactionBody {
                    crypto_allowances: ref __self_1_0,
                    nft_allowances: ref __self_1_1,
                    token_allowances: ref __self_1_2,
                } => match *self {
                    CryptoApproveAllowanceTransactionBody {
                        crypto_allowances: ref __self_0_0,
                        nft_allowances: ref __self_0_1,
                        token_allowances: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoApproveAllowanceTransactionBody) -> bool {
            match *other {
                CryptoApproveAllowanceTransactionBody {
                    crypto_allowances: ref __self_1_0,
                    nft_allowances: ref __self_1_1,
                    token_allowances: ref __self_1_2,
                } => match *self {
                    CryptoApproveAllowanceTransactionBody {
                        crypto_allowances: ref __self_0_0,
                        nft_allowances: ref __self_0_1,
                        token_allowances: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for CryptoApproveAllowanceTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.crypto_allowances {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.nft_allowances {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            for msg in &self.token_allowances {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoApproveAllowanceTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.crypto_allowances;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "crypto_allowances");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.nft_allowances;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "nft_allowances");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.token_allowances;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "token_allowances");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.crypto_allowances)
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.nft_allowances)
                + ::prost::encoding::message::encoded_len_repeated(3u32, &self.token_allowances)
        }
        fn clear(&mut self) {
            self.crypto_allowances.clear();
            self.nft_allowances.clear();
            self.token_allowances.clear();
        }
    }
    impl ::core::default::Default for CryptoApproveAllowanceTransactionBody {
        fn default() -> Self {
            CryptoApproveAllowanceTransactionBody {
                crypto_allowances: ::core::default::Default::default(),
                nft_allowances: ::core::default::Default::default(),
                token_allowances: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoApproveAllowanceTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoApproveAllowanceTransactionBody");
            let builder = {
                let wrapper = &self.crypto_allowances;
                builder.field("crypto_allowances", &wrapper)
            };
            let builder = {
                let wrapper = &self.nft_allowances;
                builder.field("nft_allowances", &wrapper)
            };
            let builder = {
                let wrapper = &self.token_allowances;
                builder.field("token_allowances", &wrapper)
            };
            builder.finish()
        }
    }
    /// An approved allowance of hbar transfers for a spender.
    pub struct CryptoAllowance {
        /// The account ID of the hbar owner (ie. the grantor of the allowance).
        #[prost(message, optional, tag = "1")]
        pub owner: ::core::option::Option<AccountId>,
        /// The account ID of the spender of the hbar allowance.
        #[prost(message, optional, tag = "2")]
        pub spender: ::core::option::Option<AccountId>,
        /// The amount of the spender's allowance in tinybars.
        #[prost(int64, tag = "3")]
        pub amount: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoAllowance {
        #[inline]
        fn clone(&self) -> CryptoAllowance {
            match *self {
                CryptoAllowance {
                    owner: ref __self_0_0,
                    spender: ref __self_0_1,
                    amount: ref __self_0_2,
                } => CryptoAllowance {
                    owner: ::core::clone::Clone::clone(&(*__self_0_0)),
                    spender: ::core::clone::Clone::clone(&(*__self_0_1)),
                    amount: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoAllowance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoAllowance {
        #[inline]
        fn eq(&self, other: &CryptoAllowance) -> bool {
            match *other {
                CryptoAllowance {
                    owner: ref __self_1_0,
                    spender: ref __self_1_1,
                    amount: ref __self_1_2,
                } => match *self {
                    CryptoAllowance {
                        owner: ref __self_0_0,
                        spender: ref __self_0_1,
                        amount: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoAllowance) -> bool {
            match *other {
                CryptoAllowance {
                    owner: ref __self_1_0,
                    spender: ref __self_1_1,
                    amount: ref __self_1_2,
                } => match *self {
                    CryptoAllowance {
                        owner: ref __self_0_0,
                        spender: ref __self_0_1,
                        amount: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for CryptoAllowance {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.owner {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.spender {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.amount != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.amount, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoAllowance";
            match tag {
                1u32 => {
                    let mut value = &mut self.owner;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "owner");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.spender;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "spender");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .owner
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .spender
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.amount != 0i64 {
                    ::prost::encoding::int64::encoded_len(3u32, &self.amount)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.owner = ::core::option::Option::None;
            self.spender = ::core::option::Option::None;
            self.amount = 0i64;
        }
    }
    impl ::core::default::Default for CryptoAllowance {
        fn default() -> Self {
            CryptoAllowance {
                owner: ::core::default::Default::default(),
                spender: ::core::default::Default::default(),
                amount: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for CryptoAllowance {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoAllowance");
            let builder = {
                let wrapper = &self.owner;
                builder.field("owner", &wrapper)
            };
            let builder = {
                let wrapper = &self.spender;
                builder.field("spender", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for CryptoAllowance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for CryptoAllowance {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<AccountId>>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<AccountId>>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for CryptoAllowance {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                CryptoAllowance {
                    owner: ref __self_0_0,
                    spender: ref __self_0_1,
                    amount: ref __self_0_2,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state)
                }
            }
        }
    }
    /// An approved allowance of non-fungible token transfers for a spender.
    pub struct NftAllowance {
        /// The NFT token type that the allowance pertains to.
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<TokenId>,
        /// The account ID of the token owner (ie. the grantor of the allowance).
        #[prost(message, optional, tag = "2")]
        pub owner: ::core::option::Option<AccountId>,
        /// The account ID of the token allowance spender.
        #[prost(message, optional, tag = "3")]
        pub spender: ::core::option::Option<AccountId>,
        /// The list of serial numbers that the spender is permitted to transfer.
        #[prost(int64, repeated, tag = "4")]
        pub serial_numbers: ::prost::alloc::vec::Vec<i64>,
        /// If true, the spender has access to all of the owner's NFT units of type tokenId (currently
        /// owned and any in the future).
        #[prost(message, optional, tag = "5")]
        pub approved_for_all: ::core::option::Option<bool>,
        /// The account ID of the spender who is granted approvedForAll allowance and granting
        /// approval on an NFT serial to another spender.
        #[prost(message, optional, tag = "6")]
        pub delegating_spender: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NftAllowance {
        #[inline]
        fn clone(&self) -> NftAllowance {
            match *self {
                NftAllowance {
                    token_id: ref __self_0_0,
                    owner: ref __self_0_1,
                    spender: ref __self_0_2,
                    serial_numbers: ref __self_0_3,
                    approved_for_all: ref __self_0_4,
                    delegating_spender: ref __self_0_5,
                } => NftAllowance {
                    token_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    owner: ::core::clone::Clone::clone(&(*__self_0_1)),
                    spender: ::core::clone::Clone::clone(&(*__self_0_2)),
                    serial_numbers: ::core::clone::Clone::clone(&(*__self_0_3)),
                    approved_for_all: ::core::clone::Clone::clone(&(*__self_0_4)),
                    delegating_spender: ::core::clone::Clone::clone(&(*__self_0_5)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for NftAllowance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for NftAllowance {
        #[inline]
        fn eq(&self, other: &NftAllowance) -> bool {
            match *other {
                NftAllowance {
                    token_id: ref __self_1_0,
                    owner: ref __self_1_1,
                    spender: ref __self_1_2,
                    serial_numbers: ref __self_1_3,
                    approved_for_all: ref __self_1_4,
                    delegating_spender: ref __self_1_5,
                } => match *self {
                    NftAllowance {
                        token_id: ref __self_0_0,
                        owner: ref __self_0_1,
                        spender: ref __self_0_2,
                        serial_numbers: ref __self_0_3,
                        approved_for_all: ref __self_0_4,
                        delegating_spender: ref __self_0_5,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NftAllowance) -> bool {
            match *other {
                NftAllowance {
                    token_id: ref __self_1_0,
                    owner: ref __self_1_1,
                    spender: ref __self_1_2,
                    serial_numbers: ref __self_1_3,
                    approved_for_all: ref __self_1_4,
                    delegating_spender: ref __self_1_5,
                } => match *self {
                    NftAllowance {
                        token_id: ref __self_0_0,
                        owner: ref __self_0_1,
                        spender: ref __self_0_2,
                        serial_numbers: ref __self_0_3,
                        approved_for_all: ref __self_0_4,
                        delegating_spender: ref __self_0_5,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                    }
                },
            }
        }
    }
    impl ::prost::Message for NftAllowance {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.owner {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.spender {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            ::prost::encoding::int64::encode_packed(4u32, &self.serial_numbers, buf);
            if let Some(ref msg) = self.approved_for_all {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
            if let Some(ref msg) = self.delegating_spender {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "NftAllowance";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.owner;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "owner");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.spender;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "spender");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.serial_numbers;
                    ::prost::encoding::int64::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "serial_numbers");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.approved_for_all;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "approved_for_all");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.delegating_spender;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "delegating_spender");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .owner
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .spender
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + ::prost::encoding::int64::encoded_len_packed(4u32, &self.serial_numbers)
                + self
                    .approved_for_all
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                + self
                    .delegating_spender
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
        }
        fn clear(&mut self) {
            self.token_id = ::core::option::Option::None;
            self.owner = ::core::option::Option::None;
            self.spender = ::core::option::Option::None;
            self.serial_numbers.clear();
            self.approved_for_all = ::core::option::Option::None;
            self.delegating_spender = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for NftAllowance {
        fn default() -> Self {
            NftAllowance {
                token_id: ::core::default::Default::default(),
                owner: ::core::default::Default::default(),
                spender: ::core::default::Default::default(),
                serial_numbers: ::prost::alloc::vec::Vec::new(),
                approved_for_all: ::core::default::Default::default(),
                delegating_spender: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for NftAllowance {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NftAllowance");
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.owner;
                builder.field("owner", &wrapper)
            };
            let builder = {
                let wrapper = &self.spender;
                builder.field("spender", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i64>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.serial_numbers)
                };
                builder.field("serial_numbers", &wrapper)
            };
            let builder = {
                let wrapper = &self.approved_for_all;
                builder.field("approved_for_all", &wrapper)
            };
            let builder = {
                let wrapper = &self.delegating_spender;
                builder.field("delegating_spender", &wrapper)
            };
            builder.finish()
        }
    }
    /// An approved allowance of fungible token transfers for a spender.
    pub struct TokenAllowance {
        /// The token that the allowance pertains to.
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<TokenId>,
        /// The account ID of the token owner (ie. the grantor of the allowance).
        #[prost(message, optional, tag = "2")]
        pub owner: ::core::option::Option<AccountId>,
        /// The account ID of the token allowance spender.
        #[prost(message, optional, tag = "3")]
        pub spender: ::core::option::Option<AccountId>,
        /// The amount of the spender's token allowance.
        #[prost(int64, tag = "4")]
        pub amount: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenAllowance {
        #[inline]
        fn clone(&self) -> TokenAllowance {
            match *self {
                TokenAllowance {
                    token_id: ref __self_0_0,
                    owner: ref __self_0_1,
                    spender: ref __self_0_2,
                    amount: ref __self_0_3,
                } => TokenAllowance {
                    token_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    owner: ::core::clone::Clone::clone(&(*__self_0_1)),
                    spender: ::core::clone::Clone::clone(&(*__self_0_2)),
                    amount: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenAllowance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenAllowance {
        #[inline]
        fn eq(&self, other: &TokenAllowance) -> bool {
            match *other {
                TokenAllowance {
                    token_id: ref __self_1_0,
                    owner: ref __self_1_1,
                    spender: ref __self_1_2,
                    amount: ref __self_1_3,
                } => match *self {
                    TokenAllowance {
                        token_id: ref __self_0_0,
                        owner: ref __self_0_1,
                        spender: ref __self_0_2,
                        amount: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenAllowance) -> bool {
            match *other {
                TokenAllowance {
                    token_id: ref __self_1_0,
                    owner: ref __self_1_1,
                    spender: ref __self_1_2,
                    amount: ref __self_1_3,
                } => match *self {
                    TokenAllowance {
                        token_id: ref __self_0_0,
                        owner: ref __self_0_1,
                        spender: ref __self_0_2,
                        amount: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenAllowance {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.owner {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.spender {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if self.amount != 0i64 {
                ::prost::encoding::int64::encode(4u32, &self.amount, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenAllowance";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.owner;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "owner");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.spender;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "spender");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .owner
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .spender
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + if self.amount != 0i64 {
                    ::prost::encoding::int64::encoded_len(4u32, &self.amount)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.token_id = ::core::option::Option::None;
            self.owner = ::core::option::Option::None;
            self.spender = ::core::option::Option::None;
            self.amount = 0i64;
        }
    }
    impl ::core::default::Default for TokenAllowance {
        fn default() -> Self {
            TokenAllowance {
                token_id: ::core::default::Default::default(),
                owner: ::core::default::Default::default(),
                spender: ::core::default::Default::default(),
                amount: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for TokenAllowance {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenAllowance");
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.owner;
                builder.field("owner", &wrapper)
            };
            let builder = {
                let wrapper = &self.spender;
                builder.field("spender", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for TokenAllowance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenAllowance {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<TokenId>>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<AccountId>>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<AccountId>>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for TokenAllowance {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                TokenAllowance {
                    token_id: ref __self_0_0,
                    owner: ref __self_0_1,
                    spender: ref __self_0_2,
                    amount: ref __self_0_3,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state);
                    ::core::hash::Hash::hash(&(*__self_0_3), state)
                }
            }
        }
    }
    /// Deletes one or more non-fungible approved allowances from an owner's account. This operation
    /// will remove the allowances granted to one or more specific non-fungible token serial numbers. Each owner account
    /// listed as wiping an allowance must sign the transaction. Hbar and fungible token allowances
    /// can be removed by setting the amount to zero in CryptoApproveAllowance.
    pub struct CryptoDeleteAllowanceTransactionBody {
        /// List of non-fungible token allowances to remove.
        #[prost(message, repeated, tag = "2")]
        pub nft_allowances: ::prost::alloc::vec::Vec<NftRemoveAllowance>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoDeleteAllowanceTransactionBody {
        #[inline]
        fn clone(&self) -> CryptoDeleteAllowanceTransactionBody {
            match *self {
                CryptoDeleteAllowanceTransactionBody {
                    nft_allowances: ref __self_0_0,
                } => CryptoDeleteAllowanceTransactionBody {
                    nft_allowances: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoDeleteAllowanceTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoDeleteAllowanceTransactionBody {
        #[inline]
        fn eq(&self, other: &CryptoDeleteAllowanceTransactionBody) -> bool {
            match *other {
                CryptoDeleteAllowanceTransactionBody {
                    nft_allowances: ref __self_1_0,
                } => match *self {
                    CryptoDeleteAllowanceTransactionBody {
                        nft_allowances: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoDeleteAllowanceTransactionBody) -> bool {
            match *other {
                CryptoDeleteAllowanceTransactionBody {
                    nft_allowances: ref __self_1_0,
                } => match *self {
                    CryptoDeleteAllowanceTransactionBody {
                        nft_allowances: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for CryptoDeleteAllowanceTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.nft_allowances {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoDeleteAllowanceTransactionBody";
            match tag {
                2u32 => {
                    let mut value = &mut self.nft_allowances;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "nft_allowances");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(2u32, &self.nft_allowances)
        }
        fn clear(&mut self) {
            self.nft_allowances.clear();
        }
    }
    impl ::core::default::Default for CryptoDeleteAllowanceTransactionBody {
        fn default() -> Self {
            CryptoDeleteAllowanceTransactionBody {
                nft_allowances: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoDeleteAllowanceTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoDeleteAllowanceTransactionBody");
            let builder = {
                let wrapper = &self.nft_allowances;
                builder.field("nft_allowances", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nft allowances to be removed on an owner account
    pub struct NftRemoveAllowance {
        /// The token that the allowance pertains to.
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<TokenId>,
        /// The account ID of the token owner (ie. the grantor of the allowance).
        #[prost(message, optional, tag = "2")]
        pub owner: ::core::option::Option<AccountId>,
        /// The list of serial numbers to remove allowances from.
        #[prost(int64, repeated, tag = "3")]
        pub serial_numbers: ::prost::alloc::vec::Vec<i64>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NftRemoveAllowance {
        #[inline]
        fn clone(&self) -> NftRemoveAllowance {
            match *self {
                NftRemoveAllowance {
                    token_id: ref __self_0_0,
                    owner: ref __self_0_1,
                    serial_numbers: ref __self_0_2,
                } => NftRemoveAllowance {
                    token_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    owner: ::core::clone::Clone::clone(&(*__self_0_1)),
                    serial_numbers: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for NftRemoveAllowance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for NftRemoveAllowance {
        #[inline]
        fn eq(&self, other: &NftRemoveAllowance) -> bool {
            match *other {
                NftRemoveAllowance {
                    token_id: ref __self_1_0,
                    owner: ref __self_1_1,
                    serial_numbers: ref __self_1_2,
                } => match *self {
                    NftRemoveAllowance {
                        token_id: ref __self_0_0,
                        owner: ref __self_0_1,
                        serial_numbers: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NftRemoveAllowance) -> bool {
            match *other {
                NftRemoveAllowance {
                    token_id: ref __self_1_0,
                    owner: ref __self_1_1,
                    serial_numbers: ref __self_1_2,
                } => match *self {
                    NftRemoveAllowance {
                        token_id: ref __self_0_0,
                        owner: ref __self_0_1,
                        serial_numbers: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for NftRemoveAllowance {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.owner {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            ::prost::encoding::int64::encode_packed(3u32, &self.serial_numbers, buf);
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "NftRemoveAllowance";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.owner;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "owner");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.serial_numbers;
                    ::prost::encoding::int64::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "serial_numbers");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .owner
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + ::prost::encoding::int64::encoded_len_packed(3u32, &self.serial_numbers)
        }
        fn clear(&mut self) {
            self.token_id = ::core::option::Option::None;
            self.owner = ::core::option::Option::None;
            self.serial_numbers.clear();
        }
    }
    impl ::core::default::Default for NftRemoveAllowance {
        fn default() -> Self {
            NftRemoveAllowance {
                token_id: ::core::default::Default::default(),
                owner: ::core::default::Default::default(),
                serial_numbers: ::prost::alloc::vec::Vec::new(),
            }
        }
    }
    impl ::core::fmt::Debug for NftRemoveAllowance {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NftRemoveAllowance");
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.owner;
                builder.field("owner", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i64>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.serial_numbers)
                };
                builder.field("serial_numbers", &wrapper)
            };
            builder.finish()
        }
    }
    pub struct EthereumTransactionBody {
        /// The raw Ethereum transaction (RLP encoded type 0, 1, and 2). Complete
        /// unless the callData field is set.
        #[prost(bytes = "vec", tag = "1")]
        pub ethereum_data: ::prost::alloc::vec::Vec<u8>,
        /// For large transactions (for example contract create) this is the callData
        /// of the ethereumData. The data in the ethereumData will be re-written with
        /// the callData element as a zero length string with the original contents in
        /// the referenced file at time of execution. The ethereumData will need to be
        /// "rehydrated" with the callData for signature validation to pass.
        #[prost(message, optional, tag = "2")]
        pub call_data: ::core::option::Option<FileId>,
        /// The maximum amount, in tinybars, that the payer of the hedera transaction
        /// is willing to pay to complete the transaction.
        ///
        /// Ordinarily the account with the ECDSA alias corresponding to the public
        /// key that is extracted from the ethereum_data signature is responsible for
        /// fees that result from the execution of the transaction. If that amount of
        /// authorized fees is not sufficient then the payer of the transaction can be
        /// charged, up to but not exceeding this amount. If the ethereum_data
        /// transaction authorized an amount that was insufficient then the payer will
        /// only be charged the amount needed to make up the difference. If the gas
        /// price in the transaction was set to zero then the payer will be assessed
        /// the entire fee.
        #[prost(int64, tag = "3")]
        pub max_gas_allowance: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for EthereumTransactionBody {
        #[inline]
        fn clone(&self) -> EthereumTransactionBody {
            match *self {
                EthereumTransactionBody {
                    ethereum_data: ref __self_0_0,
                    call_data: ref __self_0_1,
                    max_gas_allowance: ref __self_0_2,
                } => EthereumTransactionBody {
                    ethereum_data: ::core::clone::Clone::clone(&(*__self_0_0)),
                    call_data: ::core::clone::Clone::clone(&(*__self_0_1)),
                    max_gas_allowance: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for EthereumTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for EthereumTransactionBody {
        #[inline]
        fn eq(&self, other: &EthereumTransactionBody) -> bool {
            match *other {
                EthereumTransactionBody {
                    ethereum_data: ref __self_1_0,
                    call_data: ref __self_1_1,
                    max_gas_allowance: ref __self_1_2,
                } => match *self {
                    EthereumTransactionBody {
                        ethereum_data: ref __self_0_0,
                        call_data: ref __self_0_1,
                        max_gas_allowance: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &EthereumTransactionBody) -> bool {
            match *other {
                EthereumTransactionBody {
                    ethereum_data: ref __self_1_0,
                    call_data: ref __self_1_1,
                    max_gas_allowance: ref __self_1_2,
                } => match *self {
                    EthereumTransactionBody {
                        ethereum_data: ref __self_0_0,
                        call_data: ref __self_0_1,
                        max_gas_allowance: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for EthereumTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.ethereum_data != b"" as &[u8] {
                ::prost::encoding::bytes::encode(1u32, &self.ethereum_data, buf);
            }
            if let Some(ref msg) = self.call_data {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.max_gas_allowance != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.max_gas_allowance, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "EthereumTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.ethereum_data;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "ethereum_data");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.call_data;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "call_data");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.max_gas_allowance;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "max_gas_allowance");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.ethereum_data != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(1u32, &self.ethereum_data)
            } else {
                0
            } + self
                .call_data
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.max_gas_allowance != 0i64 {
                    ::prost::encoding::int64::encoded_len(3u32, &self.max_gas_allowance)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.ethereum_data.clear();
            self.call_data = ::core::option::Option::None;
            self.max_gas_allowance = 0i64;
        }
    }
    impl ::core::default::Default for EthereumTransactionBody {
        fn default() -> Self {
            EthereumTransactionBody {
                ethereum_data: ::core::default::Default::default(),
                call_data: ::core::default::Default::default(),
                max_gas_allowance: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for EthereumTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("EthereumTransactionBody");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.ethereum_data)
                };
                builder.field("ethereum_data", &wrapper)
            };
            let builder = {
                let wrapper = &self.call_data;
                builder.field("call_data", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.max_gas_allowance)
                };
                builder.field("max_gas_allowance", &wrapper)
            };
            builder.finish()
        }
    }
    /// Append the given contents to the end of the specified file. If a file is too big to create with a
    /// single FileCreateTransaction, then it can be created with the first part of its contents, and
    /// then appended as many times as necessary to create the entire file. This transaction must be
    /// signed by all initial M-of-M KeyList keys. If keys contains additional KeyList or ThresholdKey
    /// then M-of-M secondary KeyList or ThresholdKey signing requirements must be meet.
    pub struct FileAppendTransactionBody {
        /// The file to which the bytes will be appended
        #[prost(message, optional, tag = "2")]
        pub file_id: ::core::option::Option<FileId>,
        /// The bytes that will be appended to the end of the specified file
        #[prost(bytes = "vec", tag = "4")]
        pub contents: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FileAppendTransactionBody {
        #[inline]
        fn clone(&self) -> FileAppendTransactionBody {
            match *self {
                FileAppendTransactionBody {
                    file_id: ref __self_0_0,
                    contents: ref __self_0_1,
                } => FileAppendTransactionBody {
                    file_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    contents: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FileAppendTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FileAppendTransactionBody {
        #[inline]
        fn eq(&self, other: &FileAppendTransactionBody) -> bool {
            match *other {
                FileAppendTransactionBody {
                    file_id: ref __self_1_0,
                    contents: ref __self_1_1,
                } => match *self {
                    FileAppendTransactionBody {
                        file_id: ref __self_0_0,
                        contents: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FileAppendTransactionBody) -> bool {
            match *other {
                FileAppendTransactionBody {
                    file_id: ref __self_1_0,
                    contents: ref __self_1_1,
                } => match *self {
                    FileAppendTransactionBody {
                        file_id: ref __self_0_0,
                        contents: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for FileAppendTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.file_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.contents != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.contents, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FileAppendTransactionBody";
            match tag {
                2u32 => {
                    let mut value = &mut self.file_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "file_id");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.contents;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "contents");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .file_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.contents != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(4u32, &self.contents)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.file_id = ::core::option::Option::None;
            self.contents.clear();
        }
    }
    impl ::core::default::Default for FileAppendTransactionBody {
        fn default() -> Self {
            FileAppendTransactionBody {
                file_id: ::core::default::Default::default(),
                contents: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for FileAppendTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FileAppendTransactionBody");
            let builder = {
                let wrapper = &self.file_id;
                builder.field("file_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.contents)
                };
                builder.field("contents", &wrapper)
            };
            builder.finish()
        }
    }
    /// Create a new file, containing the given contents.
    /// After the file is created, the FileID for it can be found in the receipt, or record, or retrieved
    /// with a GetByKey query.
    ///
    /// The file contains the specified contents (possibly empty). The file will automatically disappear
    /// at the expirationTime, unless its expiration is extended by another transaction before that time.
    /// If the file is deleted, then its contents will become empty and it will be marked as deleted
    /// until it expires, and then it will cease to exist.
    ///
    /// The keys field is a list of keys. All keys within the top-level key list must sign (M-M) to
    /// create or modify a file. However, to delete the file, only one key (1-M) is required to sign from
    /// the top-level key list.  Each of those "keys" may itself be threshold key containing other keys
    /// (including other threshold keys). In other words, the behavior is an AND for create/modify, OR
    /// for delete. This is useful for acting as a revocation server. If it is desired to have the
    /// behavior be AND for all 3 operations (or OR for all 3), then the list should have only a single
    /// Key, which is a threshold key, with N=1 for OR, N=M for AND.
    ///
    /// If a file is created without ANY keys in the keys field, the file is immutable and ONLY the
    /// expirationTime of the file can be changed with a FileUpdate transaction. The file contents or its
    /// keys cannot be changed.
    ///
    /// An entity (account, file, or smart contract instance) must be created in a particular realm. If
    /// the realmID is left null, then a new realm will be created with the given admin key. If a new
    /// realm has a null adminKey, then anyone can create/modify/delete entities in that realm. But if an
    /// admin key is given, then any transaction to create/modify/delete an entity in that realm must be
    /// signed by that key, though anyone can still call functions on smart contract instances that exist
    /// in that realm. A realm ceases to exist when everything within it has expired and no longer
    /// exists.
    ///
    /// The current API ignores shardID, realmID, and newRealmAdminKey, and creates everything in shard 0
    /// and realm 0, with a null key. Future versions of the API will support multiple realms and
    /// multiple shards.
    pub struct FileCreateTransactionBody {
        /// The time at which this file should expire (unless FileUpdateTransaction is used before then
        /// to extend its life)
        #[prost(message, optional, tag = "2")]
        pub expiration_time: ::core::option::Option<Timestamp>,
        /// All keys at the top level of a key list must sign to create or modify the file. Any one of
        /// the keys at the top level key list can sign to delete the file.
        #[prost(message, optional, tag = "3")]
        pub keys: ::core::option::Option<KeyList>,
        /// The bytes that are the contents of the file
        #[prost(bytes = "vec", tag = "4")]
        pub contents: ::prost::alloc::vec::Vec<u8>,
        /// Shard in which this file is created
        #[prost(message, optional, tag = "5")]
        pub shard_id: ::core::option::Option<ShardId>,
        /// The Realm in which to the file is created (leave this null to create a new realm)
        #[prost(message, optional, tag = "6")]
        pub realm_id: ::core::option::Option<RealmId>,
        /// If realmID is null, then this the admin key for the new realm that will be created
        #[prost(message, optional, tag = "7")]
        pub new_realm_admin_key: ::core::option::Option<Key>,
        /// The memo associated with the file (UTF-8 encoding max 100 bytes)
        #[prost(string, tag = "8")]
        pub memo: ::prost::alloc::string::String,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FileCreateTransactionBody {
        #[inline]
        fn clone(&self) -> FileCreateTransactionBody {
            match *self {
                FileCreateTransactionBody {
                    expiration_time: ref __self_0_0,
                    keys: ref __self_0_1,
                    contents: ref __self_0_2,
                    shard_id: ref __self_0_3,
                    realm_id: ref __self_0_4,
                    new_realm_admin_key: ref __self_0_5,
                    memo: ref __self_0_6,
                } => FileCreateTransactionBody {
                    expiration_time: ::core::clone::Clone::clone(&(*__self_0_0)),
                    keys: ::core::clone::Clone::clone(&(*__self_0_1)),
                    contents: ::core::clone::Clone::clone(&(*__self_0_2)),
                    shard_id: ::core::clone::Clone::clone(&(*__self_0_3)),
                    realm_id: ::core::clone::Clone::clone(&(*__self_0_4)),
                    new_realm_admin_key: ::core::clone::Clone::clone(&(*__self_0_5)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_6)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FileCreateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FileCreateTransactionBody {
        #[inline]
        fn eq(&self, other: &FileCreateTransactionBody) -> bool {
            match *other {
                FileCreateTransactionBody {
                    expiration_time: ref __self_1_0,
                    keys: ref __self_1_1,
                    contents: ref __self_1_2,
                    shard_id: ref __self_1_3,
                    realm_id: ref __self_1_4,
                    new_realm_admin_key: ref __self_1_5,
                    memo: ref __self_1_6,
                } => match *self {
                    FileCreateTransactionBody {
                        expiration_time: ref __self_0_0,
                        keys: ref __self_0_1,
                        contents: ref __self_0_2,
                        shard_id: ref __self_0_3,
                        realm_id: ref __self_0_4,
                        new_realm_admin_key: ref __self_0_5,
                        memo: ref __self_0_6,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FileCreateTransactionBody) -> bool {
            match *other {
                FileCreateTransactionBody {
                    expiration_time: ref __self_1_0,
                    keys: ref __self_1_1,
                    contents: ref __self_1_2,
                    shard_id: ref __self_1_3,
                    realm_id: ref __self_1_4,
                    new_realm_admin_key: ref __self_1_5,
                    memo: ref __self_1_6,
                } => match *self {
                    FileCreateTransactionBody {
                        expiration_time: ref __self_0_0,
                        keys: ref __self_0_1,
                        contents: ref __self_0_2,
                        shard_id: ref __self_0_3,
                        realm_id: ref __self_0_4,
                        new_realm_admin_key: ref __self_0_5,
                        memo: ref __self_0_6,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                    }
                },
            }
        }
    }
    impl ::prost::Message for FileCreateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.expiration_time {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.keys {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if self.contents != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.contents, buf);
            }
            if let Some(ref msg) = self.shard_id {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
            if let Some(ref msg) = self.realm_id {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            if let Some(ref msg) = self.new_realm_admin_key {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            if self.memo != "" {
                ::prost::encoding::string::encode(8u32, &self.memo, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FileCreateTransactionBody";
            match tag {
                2u32 => {
                    let mut value = &mut self.expiration_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiration_time");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.keys;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "keys");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.contents;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "contents");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.shard_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "shard_id");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.realm_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "realm_id");
                        error
                    })
                }
                7u32 => {
                    let mut value = &mut self.new_realm_admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "new_realm_admin_key");
                        error
                    })
                }
                8u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .expiration_time
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .keys
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + if self.contents != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(4u32, &self.contents)
                } else {
                    0
                }
                + self
                    .shard_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                + self
                    .realm_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                + self
                    .new_realm_admin_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                + if self.memo != "" {
                    ::prost::encoding::string::encoded_len(8u32, &self.memo)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.expiration_time = ::core::option::Option::None;
            self.keys = ::core::option::Option::None;
            self.contents.clear();
            self.shard_id = ::core::option::Option::None;
            self.realm_id = ::core::option::Option::None;
            self.new_realm_admin_key = ::core::option::Option::None;
            self.memo.clear();
        }
    }
    impl ::core::default::Default for FileCreateTransactionBody {
        fn default() -> Self {
            FileCreateTransactionBody {
                expiration_time: ::core::default::Default::default(),
                keys: ::core::default::Default::default(),
                contents: ::core::default::Default::default(),
                shard_id: ::core::default::Default::default(),
                realm_id: ::core::default::Default::default(),
                new_realm_admin_key: ::core::default::Default::default(),
                memo: ::prost::alloc::string::String::new(),
            }
        }
    }
    impl ::core::fmt::Debug for FileCreateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FileCreateTransactionBody");
            let builder = {
                let wrapper = &self.expiration_time;
                builder.field("expiration_time", &wrapper)
            };
            let builder = {
                let wrapper = &self.keys;
                builder.field("keys", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.contents)
                };
                builder.field("contents", &wrapper)
            };
            let builder = {
                let wrapper = &self.shard_id;
                builder.field("shard_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.realm_id;
                builder.field("realm_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.new_realm_admin_key;
                builder.field("new_realm_admin_key", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            builder.finish()
        }
    }
    /// Delete the given file. After deletion, it will be marked as deleted and will have no contents.
    /// But information about it will continue to exist until it expires. A list of keys was given when
    /// the file was created. All the top level keys on that list must sign transactions to create or
    /// modify the file, but any single one of the top level keys can be used to delete the file. This
    /// transaction must be signed by 1-of-M KeyList keys. If keys contains additional KeyList or
    /// ThresholdKey then 1-of-M secondary KeyList or ThresholdKey signing requirements must be meet.
    pub struct FileDeleteTransactionBody {
        /// The file to delete. It will be marked as deleted until it expires. Then it will disappear.
        #[prost(message, optional, tag = "2")]
        pub file_id: ::core::option::Option<FileId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FileDeleteTransactionBody {
        #[inline]
        fn clone(&self) -> FileDeleteTransactionBody {
            match *self {
                FileDeleteTransactionBody {
                    file_id: ref __self_0_0,
                } => FileDeleteTransactionBody {
                    file_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FileDeleteTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FileDeleteTransactionBody {
        #[inline]
        fn eq(&self, other: &FileDeleteTransactionBody) -> bool {
            match *other {
                FileDeleteTransactionBody {
                    file_id: ref __self_1_0,
                } => match *self {
                    FileDeleteTransactionBody {
                        file_id: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FileDeleteTransactionBody) -> bool {
            match *other {
                FileDeleteTransactionBody {
                    file_id: ref __self_1_0,
                } => match *self {
                    FileDeleteTransactionBody {
                        file_id: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for FileDeleteTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.file_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FileDeleteTransactionBody";
            match tag {
                2u32 => {
                    let mut value = &mut self.file_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "file_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .file_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.file_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for FileDeleteTransactionBody {
        fn default() -> Self {
            FileDeleteTransactionBody {
                file_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for FileDeleteTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FileDeleteTransactionBody");
            let builder = {
                let wrapper = &self.file_id;
                builder.field("file_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Modify the metadata and/or contents of a file. If a field is not set in the transaction body, the
    /// corresponding file attribute will be unchanged. This transaction must be signed by all the keys
    /// in the top level of a key list (M-of-M) of the file being updated. If the keys themselves are
    /// being updated, then the transaction must also be signed by all the new keys. If the keys contain
    /// additional KeyList or ThresholdKey then M-of-M secondary KeyList or ThresholdKey signing
    /// requirements must be meet
    pub struct FileUpdateTransactionBody {
        /// The ID of the file to update
        #[prost(message, optional, tag = "1")]
        pub file_id: ::core::option::Option<FileId>,
        /// The new expiry time (ignored if not later than the current expiry)
        #[prost(message, optional, tag = "2")]
        pub expiration_time: ::core::option::Option<Timestamp>,
        /// The new list of keys that can modify or delete the file
        #[prost(message, optional, tag = "3")]
        pub keys: ::core::option::Option<KeyList>,
        /// The new contents that should overwrite the file's current contents
        #[prost(bytes = "vec", tag = "4")]
        pub contents: ::prost::alloc::vec::Vec<u8>,
        /// If set, the new memo to be associated with the file (UTF-8 encoding max 100 bytes)
        #[prost(message, optional, tag = "5")]
        pub memo: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FileUpdateTransactionBody {
        #[inline]
        fn clone(&self) -> FileUpdateTransactionBody {
            match *self {
                FileUpdateTransactionBody {
                    file_id: ref __self_0_0,
                    expiration_time: ref __self_0_1,
                    keys: ref __self_0_2,
                    contents: ref __self_0_3,
                    memo: ref __self_0_4,
                } => FileUpdateTransactionBody {
                    file_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    expiration_time: ::core::clone::Clone::clone(&(*__self_0_1)),
                    keys: ::core::clone::Clone::clone(&(*__self_0_2)),
                    contents: ::core::clone::Clone::clone(&(*__self_0_3)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FileUpdateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FileUpdateTransactionBody {
        #[inline]
        fn eq(&self, other: &FileUpdateTransactionBody) -> bool {
            match *other {
                FileUpdateTransactionBody {
                    file_id: ref __self_1_0,
                    expiration_time: ref __self_1_1,
                    keys: ref __self_1_2,
                    contents: ref __self_1_3,
                    memo: ref __self_1_4,
                } => match *self {
                    FileUpdateTransactionBody {
                        file_id: ref __self_0_0,
                        expiration_time: ref __self_0_1,
                        keys: ref __self_0_2,
                        contents: ref __self_0_3,
                        memo: ref __self_0_4,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FileUpdateTransactionBody) -> bool {
            match *other {
                FileUpdateTransactionBody {
                    file_id: ref __self_1_0,
                    expiration_time: ref __self_1_1,
                    keys: ref __self_1_2,
                    contents: ref __self_1_3,
                    memo: ref __self_1_4,
                } => match *self {
                    FileUpdateTransactionBody {
                        file_id: ref __self_0_0,
                        expiration_time: ref __self_0_1,
                        keys: ref __self_0_2,
                        contents: ref __self_0_3,
                        memo: ref __self_0_4,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                    }
                },
            }
        }
    }
    impl ::prost::Message for FileUpdateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.file_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.expiration_time {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.keys {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if self.contents != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.contents, buf);
            }
            if let Some(ref msg) = self.memo {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FileUpdateTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.file_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "file_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.expiration_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiration_time");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.keys;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "keys");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.contents;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "contents");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "memo");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .file_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .expiration_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .keys
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + if self.contents != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(4u32, &self.contents)
                } else {
                    0
                }
                + self
                    .memo
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
        }
        fn clear(&mut self) {
            self.file_id = ::core::option::Option::None;
            self.expiration_time = ::core::option::Option::None;
            self.keys = ::core::option::Option::None;
            self.contents.clear();
            self.memo = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for FileUpdateTransactionBody {
        fn default() -> Self {
            FileUpdateTransactionBody {
                file_id: ::core::default::Default::default(),
                expiration_time: ::core::default::Default::default(),
                keys: ::core::default::Default::default(),
                contents: ::core::default::Default::default(),
                memo: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for FileUpdateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FileUpdateTransactionBody");
            let builder = {
                let wrapper = &self.file_id;
                builder.field("file_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiration_time;
                builder.field("expiration_time", &wrapper)
            };
            let builder = {
                let wrapper = &self.keys;
                builder.field("keys", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.contents)
                };
                builder.field("contents", &wrapper)
            };
            let builder = {
                let wrapper = &self.memo;
                builder.field("memo", &wrapper)
            };
            builder.finish()
        }
    }
    /// At consensus, marks a contract as deleted and transfers its remaining hBars, if any, to a
    /// designated receiver. After a contract is deleted, it can no longer be called.
    ///
    /// If the target contract is immutable (that is, was created without an admin key), then this
    /// transaction resolves to MODIFYING_IMMUTABLE_CONTRACT.
    ///
    /// --- Signing Requirements ---
    /// 1. The admin key of the target contract must sign.
    /// 2. If the transfer account or contract has receiverSigRequired, its associated key must also sign
    pub struct ContractDeleteTransactionBody {
        /// The id of the contract to be deleted
        #[prost(message, optional, tag = "1")]
        pub contract_id: ::core::option::Option<ContractId>,
        /// If set to true, means this is a "synthetic" system transaction being used to
        /// alert mirror nodes that the contract is being permanently removed from the ledger.
        /// <b>IMPORTANT:</b> User transactions cannot set this field to true, as permanent
        /// removal is always managed by the ledger itself. Any ContractDeleteTransactionBody
        /// submitted to HAPI with permanent_removal=true will be rejected with precheck status
        /// PERMANENT_REMOVAL_REQUIRES_SYSTEM_INITIATION.
        #[prost(bool, tag = "4")]
        pub permanent_removal: bool,
        #[prost(oneof = "contract_delete_transaction_body::Obtainers", tags = "2, 3")]
        pub obtainers: ::core::option::Option<contract_delete_transaction_body::Obtainers>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractDeleteTransactionBody {
        #[inline]
        fn clone(&self) -> ContractDeleteTransactionBody {
            match *self {
                ContractDeleteTransactionBody {
                    contract_id: ref __self_0_0,
                    permanent_removal: ref __self_0_1,
                    obtainers: ref __self_0_2,
                } => ContractDeleteTransactionBody {
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    permanent_removal: ::core::clone::Clone::clone(&(*__self_0_1)),
                    obtainers: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractDeleteTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractDeleteTransactionBody {
        #[inline]
        fn eq(&self, other: &ContractDeleteTransactionBody) -> bool {
            match *other {
                ContractDeleteTransactionBody {
                    contract_id: ref __self_1_0,
                    permanent_removal: ref __self_1_1,
                    obtainers: ref __self_1_2,
                } => match *self {
                    ContractDeleteTransactionBody {
                        contract_id: ref __self_0_0,
                        permanent_removal: ref __self_0_1,
                        obtainers: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractDeleteTransactionBody) -> bool {
            match *other {
                ContractDeleteTransactionBody {
                    contract_id: ref __self_1_0,
                    permanent_removal: ref __self_1_1,
                    obtainers: ref __self_1_2,
                } => match *self {
                    ContractDeleteTransactionBody {
                        contract_id: ref __self_0_0,
                        permanent_removal: ref __self_0_1,
                        obtainers: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ContractDeleteTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref oneof) = self.obtainers {
                oneof.encode(buf)
            }
            if self.permanent_removal != false {
                ::prost::encoding::bool::encode(4u32, &self.permanent_removal, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractDeleteTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                2u32 | 3u32 => {
                    let mut value = &mut self.obtainers;
                    contract_delete_transaction_body::Obtainers::merge(
                        value, tag, wire_type, buf, ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "obtainers");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.permanent_removal;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "permanent_removal");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .contract_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .obtainers
                    .as_ref()
                    .map_or(0, contract_delete_transaction_body::Obtainers::encoded_len)
                + if self.permanent_removal != false {
                    ::prost::encoding::bool::encoded_len(4u32, &self.permanent_removal)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.contract_id = ::core::option::Option::None;
            self.obtainers = ::core::option::Option::None;
            self.permanent_removal = false;
        }
    }
    impl ::core::default::Default for ContractDeleteTransactionBody {
        fn default() -> Self {
            ContractDeleteTransactionBody {
                contract_id: ::core::default::Default::default(),
                obtainers: ::core::default::Default::default(),
                permanent_removal: false,
            }
        }
    }
    impl ::core::fmt::Debug for ContractDeleteTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractDeleteTransactionBody");
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.permanent_removal)
                };
                builder.field("permanent_removal", &wrapper)
            };
            let builder = {
                let wrapper = &self.obtainers;
                builder.field("obtainers", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `ContractDeleteTransactionBody`.
    pub mod contract_delete_transaction_body {
        pub enum Obtainers {
            /// The id of an account to receive any remaining hBars from the deleted contract
            #[prost(message, tag = "2")]
            TransferAccountId(super::AccountId),
            /// The id of a contract to receive any remaining hBars from the deleted contract
            #[prost(message, tag = "3")]
            TransferContractId(super::ContractId),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Obtainers {
            #[inline]
            fn clone(&self) -> Obtainers {
                match (&*self,) {
                    (&Obtainers::TransferAccountId(ref __self_0),) => {
                        Obtainers::TransferAccountId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Obtainers::TransferContractId(ref __self_0),) => {
                        Obtainers::TransferContractId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Obtainers {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Obtainers {
            #[inline]
            fn eq(&self, other: &Obtainers) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Obtainers::TransferAccountId(ref __self_0),
                                &Obtainers::TransferAccountId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Obtainers::TransferContractId(ref __self_0),
                                &Obtainers::TransferContractId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Obtainers) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Obtainers::TransferAccountId(ref __self_0),
                                &Obtainers::TransferAccountId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Obtainers::TransferContractId(ref __self_0),
                                &Obtainers::TransferContractId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Obtainers {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Obtainers::TransferAccountId(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    Obtainers::TransferContractId(ref value) => {
                        ::prost::encoding::message::encode(3u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Obtainers>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    2u32 => match field {
                        ::core::option::Option::Some(Obtainers::TransferAccountId(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Obtainers::TransferAccountId(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    3u32 => match field {
                        ::core::option::Option::Some(Obtainers::TransferContractId(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Obtainers::TransferContractId(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Obtainers tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Obtainers::TransferAccountId(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                    Obtainers::TransferContractId(ref value) => {
                        ::prost::encoding::message::encoded_len(3u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Obtainers {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Obtainers::TransferAccountId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TransferAccountId").field(&wrapper).finish()
                    }
                    Obtainers::TransferContractId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TransferContractId").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// See \[ConsensusService.createTopic()\](#proto.ConsensusService)
    pub struct ConsensusCreateTopicTransactionBody {
        /// Short publicly visible memo about the topic. No guarantee of uniqueness.
        #[prost(string, tag = "1")]
        pub memo: ::prost::alloc::string::String,
        /// Access control for updateTopic/deleteTopic.
        /// Anyone can increase the topic's expirationTime via ConsensusService.updateTopic(), regardless of the adminKey.
        /// If no adminKey is specified, updateTopic may only be used to extend the topic's expirationTime, and deleteTopic
        /// is disallowed.
        #[prost(message, optional, tag = "2")]
        pub admin_key: ::core::option::Option<Key>,
        /// Access control for submitMessage.
        /// If unspecified, no access control is performed on ConsensusService.submitMessage (all submissions are allowed).
        #[prost(message, optional, tag = "3")]
        pub submit_key: ::core::option::Option<Key>,
        /// The initial lifetime of the topic and the amount of time to attempt to extend the topic's lifetime by
        /// automatically at the topic's expirationTime, if the autoRenewAccount is configured (once autoRenew functionality
        /// is supported by HAPI).
        /// Limited to MIN_AUTORENEW_PERIOD and MAX_AUTORENEW_PERIOD value by server-side configuration.
        /// Required.
        #[prost(message, optional, tag = "6")]
        pub auto_renew_period: ::core::option::Option<Duration>,
        /// Optional account to be used at the topic's expirationTime to extend the life of the topic (once autoRenew
        /// functionality is supported by HAPI).
        /// The topic lifetime will be extended up to a maximum of the autoRenewPeriod or however long the topic
        /// can be extended using all funds on the account (whichever is the smaller duration/amount and if any extension
        /// is possible with the account's funds).
        /// If specified, there must be an adminKey and the autoRenewAccount must sign this transaction.
        #[prost(message, optional, tag = "7")]
        pub auto_renew_account: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ConsensusCreateTopicTransactionBody {
        #[inline]
        fn clone(&self) -> ConsensusCreateTopicTransactionBody {
            match *self {
                ConsensusCreateTopicTransactionBody {
                    memo: ref __self_0_0,
                    admin_key: ref __self_0_1,
                    submit_key: ref __self_0_2,
                    auto_renew_period: ref __self_0_3,
                    auto_renew_account: ref __self_0_4,
                } => ConsensusCreateTopicTransactionBody {
                    memo: ::core::clone::Clone::clone(&(*__self_0_0)),
                    admin_key: ::core::clone::Clone::clone(&(*__self_0_1)),
                    submit_key: ::core::clone::Clone::clone(&(*__self_0_2)),
                    auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_3)),
                    auto_renew_account: ::core::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ConsensusCreateTopicTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ConsensusCreateTopicTransactionBody {
        #[inline]
        fn eq(&self, other: &ConsensusCreateTopicTransactionBody) -> bool {
            match *other {
                ConsensusCreateTopicTransactionBody {
                    memo: ref __self_1_0,
                    admin_key: ref __self_1_1,
                    submit_key: ref __self_1_2,
                    auto_renew_period: ref __self_1_3,
                    auto_renew_account: ref __self_1_4,
                } => match *self {
                    ConsensusCreateTopicTransactionBody {
                        memo: ref __self_0_0,
                        admin_key: ref __self_0_1,
                        submit_key: ref __self_0_2,
                        auto_renew_period: ref __self_0_3,
                        auto_renew_account: ref __self_0_4,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ConsensusCreateTopicTransactionBody) -> bool {
            match *other {
                ConsensusCreateTopicTransactionBody {
                    memo: ref __self_1_0,
                    admin_key: ref __self_1_1,
                    submit_key: ref __self_1_2,
                    auto_renew_period: ref __self_1_3,
                    auto_renew_account: ref __self_1_4,
                } => match *self {
                    ConsensusCreateTopicTransactionBody {
                        memo: ref __self_0_0,
                        admin_key: ref __self_0_1,
                        submit_key: ref __self_0_2,
                        auto_renew_period: ref __self_0_3,
                        auto_renew_account: ref __self_0_4,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ConsensusCreateTopicTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.memo != "" {
                ::prost::encoding::string::encode(1u32, &self.memo, buf);
            }
            if let Some(ref msg) = self.admin_key {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.submit_key {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_period {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_account {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ConsensusCreateTopicTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "admin_key");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.submit_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "submit_key");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.auto_renew_period;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_period");
                        error
                    })
                }
                7u32 => {
                    let mut value = &mut self.auto_renew_account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_account");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.memo != "" {
                ::prost::encoding::string::encoded_len(1u32, &self.memo)
            } else {
                0
            } + self
                .admin_key
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .submit_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .auto_renew_period
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                + self
                    .auto_renew_account
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
        }
        fn clear(&mut self) {
            self.memo.clear();
            self.admin_key = ::core::option::Option::None;
            self.submit_key = ::core::option::Option::None;
            self.auto_renew_period = ::core::option::Option::None;
            self.auto_renew_account = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ConsensusCreateTopicTransactionBody {
        fn default() -> Self {
            ConsensusCreateTopicTransactionBody {
                memo: ::prost::alloc::string::String::new(),
                admin_key: ::core::default::Default::default(),
                submit_key: ::core::default::Default::default(),
                auto_renew_period: ::core::default::Default::default(),
                auto_renew_account: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ConsensusCreateTopicTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ConsensusCreateTopicTransactionBody");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = &self.admin_key;
                builder.field("admin_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.submit_key;
                builder.field("submit_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_period;
                builder.field("auto_renew_period", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_account;
                builder.field("auto_renew_account", &wrapper)
            };
            builder.finish()
        }
    }
    /// All fields left null will not be updated.
    /// See \[ConsensusService.updateTopic()\](#proto.ConsensusService)
    pub struct ConsensusUpdateTopicTransactionBody {
        #[prost(message, optional, tag = "1")]
        pub topic_id: ::core::option::Option<TopicId>,
        /// If set, the new memo to be associated with the topic (UTF-8 encoding max 100 bytes)
        #[prost(message, optional, tag = "2")]
        pub memo: ::core::option::Option<::prost::alloc::string::String>,
        /// Effective consensus timestamp at (and after) which all consensus transactions and queries will fail.
        /// The expirationTime may be no longer than MAX_AUTORENEW_PERIOD (8000001 seconds) from the consensus timestamp of
        /// this transaction.
        /// On topics with no adminKey, extending the expirationTime is the only updateTopic option allowed on the topic.
        /// If unspecified, no change.
        #[prost(message, optional, tag = "4")]
        pub expiration_time: ::core::option::Option<Timestamp>,
        /// Access control for update/delete of the topic.
        /// If unspecified, no change.
        /// If empty keyList - the adminKey is cleared.
        #[prost(message, optional, tag = "6")]
        pub admin_key: ::core::option::Option<Key>,
        /// Access control for ConsensusService.submitMessage.
        /// If unspecified, no change.
        /// If empty keyList - the submitKey is cleared.
        #[prost(message, optional, tag = "7")]
        pub submit_key: ::core::option::Option<Key>,
        ///
        /// The amount of time to extend the topic's lifetime automatically at expirationTime if the autoRenewAccount is
        /// configured and has funds (once autoRenew functionality is supported by HAPI).
        /// Limited to between MIN_AUTORENEW_PERIOD (6999999 seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds) by
        /// servers-side configuration (which may change).
        /// If unspecified, no change.
        #[prost(message, optional, tag = "8")]
        pub auto_renew_period: ::core::option::Option<Duration>,
        /// Optional account to be used at the topic's expirationTime to extend the life of the topic.
        /// Once autoRenew functionality is supported by HAPI, the topic lifetime will be extended up to a maximum of the
        /// autoRenewPeriod or however long the topic can be extended using all funds on the account (whichever is the
        /// smaller duration/amount).
        /// If specified as the default value (0.0.0), the autoRenewAccount will be removed.
        /// If unspecified, no change.
        #[prost(message, optional, tag = "9")]
        pub auto_renew_account: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ConsensusUpdateTopicTransactionBody {
        #[inline]
        fn clone(&self) -> ConsensusUpdateTopicTransactionBody {
            match *self {
                ConsensusUpdateTopicTransactionBody {
                    topic_id: ref __self_0_0,
                    memo: ref __self_0_1,
                    expiration_time: ref __self_0_2,
                    admin_key: ref __self_0_3,
                    submit_key: ref __self_0_4,
                    auto_renew_period: ref __self_0_5,
                    auto_renew_account: ref __self_0_6,
                } => ConsensusUpdateTopicTransactionBody {
                    topic_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_1)),
                    expiration_time: ::core::clone::Clone::clone(&(*__self_0_2)),
                    admin_key: ::core::clone::Clone::clone(&(*__self_0_3)),
                    submit_key: ::core::clone::Clone::clone(&(*__self_0_4)),
                    auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_5)),
                    auto_renew_account: ::core::clone::Clone::clone(&(*__self_0_6)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ConsensusUpdateTopicTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ConsensusUpdateTopicTransactionBody {
        #[inline]
        fn eq(&self, other: &ConsensusUpdateTopicTransactionBody) -> bool {
            match *other {
                ConsensusUpdateTopicTransactionBody {
                    topic_id: ref __self_1_0,
                    memo: ref __self_1_1,
                    expiration_time: ref __self_1_2,
                    admin_key: ref __self_1_3,
                    submit_key: ref __self_1_4,
                    auto_renew_period: ref __self_1_5,
                    auto_renew_account: ref __self_1_6,
                } => match *self {
                    ConsensusUpdateTopicTransactionBody {
                        topic_id: ref __self_0_0,
                        memo: ref __self_0_1,
                        expiration_time: ref __self_0_2,
                        admin_key: ref __self_0_3,
                        submit_key: ref __self_0_4,
                        auto_renew_period: ref __self_0_5,
                        auto_renew_account: ref __self_0_6,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ConsensusUpdateTopicTransactionBody) -> bool {
            match *other {
                ConsensusUpdateTopicTransactionBody {
                    topic_id: ref __self_1_0,
                    memo: ref __self_1_1,
                    expiration_time: ref __self_1_2,
                    admin_key: ref __self_1_3,
                    submit_key: ref __self_1_4,
                    auto_renew_period: ref __self_1_5,
                    auto_renew_account: ref __self_1_6,
                } => match *self {
                    ConsensusUpdateTopicTransactionBody {
                        topic_id: ref __self_0_0,
                        memo: ref __self_0_1,
                        expiration_time: ref __self_0_2,
                        admin_key: ref __self_0_3,
                        submit_key: ref __self_0_4,
                        auto_renew_period: ref __self_0_5,
                        auto_renew_account: ref __self_0_6,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ConsensusUpdateTopicTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.topic_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.memo {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.expiration_time {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            if let Some(ref msg) = self.admin_key {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            if let Some(ref msg) = self.submit_key {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_period {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_account {
                ::prost::encoding::message::encode(9u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ConsensusUpdateTopicTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.topic_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "topic_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "memo");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.expiration_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiration_time");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "admin_key");
                        error
                    })
                }
                7u32 => {
                    let mut value = &mut self.submit_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "submit_key");
                        error
                    })
                }
                8u32 => {
                    let mut value = &mut self.auto_renew_period;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_period");
                        error
                    })
                }
                9u32 => {
                    let mut value = &mut self.auto_renew_account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_account");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .topic_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .memo
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .expiration_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + self
                    .admin_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                + self
                    .submit_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                + self
                    .auto_renew_period
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(8u32, msg))
                + self
                    .auto_renew_account
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(9u32, msg))
        }
        fn clear(&mut self) {
            self.topic_id = ::core::option::Option::None;
            self.memo = ::core::option::Option::None;
            self.expiration_time = ::core::option::Option::None;
            self.admin_key = ::core::option::Option::None;
            self.submit_key = ::core::option::Option::None;
            self.auto_renew_period = ::core::option::Option::None;
            self.auto_renew_account = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ConsensusUpdateTopicTransactionBody {
        fn default() -> Self {
            ConsensusUpdateTopicTransactionBody {
                topic_id: ::core::default::Default::default(),
                memo: ::core::default::Default::default(),
                expiration_time: ::core::default::Default::default(),
                admin_key: ::core::default::Default::default(),
                submit_key: ::core::default::Default::default(),
                auto_renew_period: ::core::default::Default::default(),
                auto_renew_account: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ConsensusUpdateTopicTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ConsensusUpdateTopicTransactionBody");
            let builder = {
                let wrapper = &self.topic_id;
                builder.field("topic_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.memo;
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiration_time;
                builder.field("expiration_time", &wrapper)
            };
            let builder = {
                let wrapper = &self.admin_key;
                builder.field("admin_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.submit_key;
                builder.field("submit_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_period;
                builder.field("auto_renew_period", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_account;
                builder.field("auto_renew_account", &wrapper)
            };
            builder.finish()
        }
    }
    /// See \[ConsensusService.deleteTopic()\](#proto.ConsensusService)
    pub struct ConsensusDeleteTopicTransactionBody {
        /// Topic identifier
        #[prost(message, optional, tag = "1")]
        pub topic_id: ::core::option::Option<TopicId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ConsensusDeleteTopicTransactionBody {
        #[inline]
        fn clone(&self) -> ConsensusDeleteTopicTransactionBody {
            match *self {
                ConsensusDeleteTopicTransactionBody {
                    topic_id: ref __self_0_0,
                } => ConsensusDeleteTopicTransactionBody {
                    topic_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ConsensusDeleteTopicTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ConsensusDeleteTopicTransactionBody {
        #[inline]
        fn eq(&self, other: &ConsensusDeleteTopicTransactionBody) -> bool {
            match *other {
                ConsensusDeleteTopicTransactionBody {
                    topic_id: ref __self_1_0,
                } => match *self {
                    ConsensusDeleteTopicTransactionBody {
                        topic_id: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ConsensusDeleteTopicTransactionBody) -> bool {
            match *other {
                ConsensusDeleteTopicTransactionBody {
                    topic_id: ref __self_1_0,
                } => match *self {
                    ConsensusDeleteTopicTransactionBody {
                        topic_id: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for ConsensusDeleteTopicTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.topic_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ConsensusDeleteTopicTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.topic_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "topic_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .topic_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) {
            self.topic_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ConsensusDeleteTopicTransactionBody {
        fn default() -> Self {
            ConsensusDeleteTopicTransactionBody {
                topic_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ConsensusDeleteTopicTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ConsensusDeleteTopicTransactionBody");
            let builder = {
                let wrapper = &self.topic_id;
                builder.field("topic_id", &wrapper)
            };
            builder.finish()
        }
    }
    pub struct ConsensusMessageChunkInfo {
        /// TransactionID of the first chunk, gets copied to every subsequent chunk in a fragmented message.
        #[prost(message, optional, tag = "1")]
        pub initial_transaction_id: ::core::option::Option<TransactionId>,
        /// The total number of chunks in the message.
        #[prost(int32, tag = "2")]
        pub total: i32,
        /// The sequence number (from 1 to total) of the current chunk in the message.
        #[prost(int32, tag = "3")]
        pub number: i32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ConsensusMessageChunkInfo {
        #[inline]
        fn clone(&self) -> ConsensusMessageChunkInfo {
            match *self {
                ConsensusMessageChunkInfo {
                    initial_transaction_id: ref __self_0_0,
                    total: ref __self_0_1,
                    number: ref __self_0_2,
                } => ConsensusMessageChunkInfo {
                    initial_transaction_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    total: ::core::clone::Clone::clone(&(*__self_0_1)),
                    number: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ConsensusMessageChunkInfo {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ConsensusMessageChunkInfo {
        #[inline]
        fn eq(&self, other: &ConsensusMessageChunkInfo) -> bool {
            match *other {
                ConsensusMessageChunkInfo {
                    initial_transaction_id: ref __self_1_0,
                    total: ref __self_1_1,
                    number: ref __self_1_2,
                } => match *self {
                    ConsensusMessageChunkInfo {
                        initial_transaction_id: ref __self_0_0,
                        total: ref __self_0_1,
                        number: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ConsensusMessageChunkInfo) -> bool {
            match *other {
                ConsensusMessageChunkInfo {
                    initial_transaction_id: ref __self_1_0,
                    total: ref __self_1_1,
                    number: ref __self_1_2,
                } => match *self {
                    ConsensusMessageChunkInfo {
                        initial_transaction_id: ref __self_0_0,
                        total: ref __self_0_1,
                        number: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ConsensusMessageChunkInfo {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.initial_transaction_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.total != 0i32 {
                ::prost::encoding::int32::encode(2u32, &self.total, buf);
            }
            if self.number != 0i32 {
                ::prost::encoding::int32::encode(3u32, &self.number, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ConsensusMessageChunkInfo";
            match tag {
                1u32 => {
                    let mut value = &mut self.initial_transaction_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "initial_transaction_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.total;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "total");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.number;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "number");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .initial_transaction_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.total != 0i32 {
                    ::prost::encoding::int32::encoded_len(2u32, &self.total)
                } else {
                    0
                }
                + if self.number != 0i32 {
                    ::prost::encoding::int32::encoded_len(3u32, &self.number)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.initial_transaction_id = ::core::option::Option::None;
            self.total = 0i32;
            self.number = 0i32;
        }
    }
    impl ::core::default::Default for ConsensusMessageChunkInfo {
        fn default() -> Self {
            ConsensusMessageChunkInfo {
                initial_transaction_id: ::core::default::Default::default(),
                total: 0i32,
                number: 0i32,
            }
        }
    }
    impl ::core::fmt::Debug for ConsensusMessageChunkInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ConsensusMessageChunkInfo");
            let builder = {
                let wrapper = &self.initial_transaction_id;
                builder.field("initial_transaction_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.total)
                };
                builder.field("total", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.number)
                };
                builder.field("number", &wrapper)
            };
            builder.finish()
        }
    }
    pub struct ConsensusSubmitMessageTransactionBody {
        /// Topic to submit message to.
        #[prost(message, optional, tag = "1")]
        pub topic_id: ::core::option::Option<TopicId>,
        /// Message to be submitted. Max size of the Transaction (including signatures) is 6KiB.
        #[prost(bytes = "vec", tag = "2")]
        pub message: ::prost::alloc::vec::Vec<u8>,
        /// Optional information of the current chunk in a fragmented message.
        #[prost(message, optional, tag = "3")]
        pub chunk_info: ::core::option::Option<ConsensusMessageChunkInfo>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ConsensusSubmitMessageTransactionBody {
        #[inline]
        fn clone(&self) -> ConsensusSubmitMessageTransactionBody {
            match *self {
                ConsensusSubmitMessageTransactionBody {
                    topic_id: ref __self_0_0,
                    message: ref __self_0_1,
                    chunk_info: ref __self_0_2,
                } => ConsensusSubmitMessageTransactionBody {
                    topic_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    message: ::core::clone::Clone::clone(&(*__self_0_1)),
                    chunk_info: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ConsensusSubmitMessageTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ConsensusSubmitMessageTransactionBody {
        #[inline]
        fn eq(&self, other: &ConsensusSubmitMessageTransactionBody) -> bool {
            match *other {
                ConsensusSubmitMessageTransactionBody {
                    topic_id: ref __self_1_0,
                    message: ref __self_1_1,
                    chunk_info: ref __self_1_2,
                } => match *self {
                    ConsensusSubmitMessageTransactionBody {
                        topic_id: ref __self_0_0,
                        message: ref __self_0_1,
                        chunk_info: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ConsensusSubmitMessageTransactionBody) -> bool {
            match *other {
                ConsensusSubmitMessageTransactionBody {
                    topic_id: ref __self_1_0,
                    message: ref __self_1_1,
                    chunk_info: ref __self_1_2,
                } => match *self {
                    ConsensusSubmitMessageTransactionBody {
                        topic_id: ref __self_0_0,
                        message: ref __self_0_1,
                        chunk_info: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ConsensusSubmitMessageTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.topic_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.message != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.message, buf);
            }
            if let Some(ref msg) = self.chunk_info {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ConsensusSubmitMessageTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.topic_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "topic_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.message;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "message");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.chunk_info;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "chunk_info");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .topic_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.message != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(2u32, &self.message)
                } else {
                    0
                }
                + self
                    .chunk_info
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
        }
        fn clear(&mut self) {
            self.topic_id = ::core::option::Option::None;
            self.message.clear();
            self.chunk_info = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ConsensusSubmitMessageTransactionBody {
        fn default() -> Self {
            ConsensusSubmitMessageTransactionBody {
                topic_id: ::core::default::Default::default(),
                message: ::core::default::Default::default(),
                chunk_info: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ConsensusSubmitMessageTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ConsensusSubmitMessageTransactionBody");
            let builder = {
                let wrapper = &self.topic_id;
                builder.field("topic_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.message)
                };
                builder.field("message", &wrapper)
            };
            let builder = {
                let wrapper = &self.chunk_info;
                builder.field("chunk_info", &wrapper)
            };
            builder.finish()
        }
    }
    /// Submit an arbitrary (serialized) Transaction to the network without prechecks. Requires superuser
    /// privileges.
    pub struct UncheckedSubmitBody {
        /// The serialized bytes of the Transaction to be submitted without prechecks
        #[prost(bytes = "vec", tag = "1")]
        pub transaction_bytes: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for UncheckedSubmitBody {
        #[inline]
        fn clone(&self) -> UncheckedSubmitBody {
            match *self {
                UncheckedSubmitBody {
                    transaction_bytes: ref __self_0_0,
                } => UncheckedSubmitBody {
                    transaction_bytes: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for UncheckedSubmitBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for UncheckedSubmitBody {
        #[inline]
        fn eq(&self, other: &UncheckedSubmitBody) -> bool {
            match *other {
                UncheckedSubmitBody {
                    transaction_bytes: ref __self_1_0,
                } => match *self {
                    UncheckedSubmitBody {
                        transaction_bytes: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &UncheckedSubmitBody) -> bool {
            match *other {
                UncheckedSubmitBody {
                    transaction_bytes: ref __self_1_0,
                } => match *self {
                    UncheckedSubmitBody {
                        transaction_bytes: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for UncheckedSubmitBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.transaction_bytes != b"" as &[u8] {
                ::prost::encoding::bytes::encode(1u32, &self.transaction_bytes, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "UncheckedSubmitBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.transaction_bytes;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "transaction_bytes");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.transaction_bytes != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(1u32, &self.transaction_bytes)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.transaction_bytes.clear();
        }
    }
    impl ::core::default::Default for UncheckedSubmitBody {
        fn default() -> Self {
            UncheckedSubmitBody {
                transaction_bytes: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for UncheckedSubmitBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("UncheckedSubmitBody");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.transaction_bytes)
                };
                builder.field("transaction_bytes", &wrapper)
            };
            builder.finish()
        }
    }
    /// A fraction of the transferred units of a token to assess as a fee. The amount assessed will never
    /// be less than the given minimum_amount, and never greater than the given maximum_amount.  The
    /// denomination is always units of the token to which this fractional fee is attached.
    pub struct FractionalFee {
        /// The fraction of the transferred units to assess as a fee
        #[prost(message, optional, tag = "1")]
        pub fractional_amount: ::core::option::Option<Fraction>,
        /// The minimum amount to assess
        #[prost(int64, tag = "2")]
        pub minimum_amount: i64,
        /// The maximum amount to assess (zero implies no maximum)
        #[prost(int64, tag = "3")]
        pub maximum_amount: i64,
        /// If true, assesses the fee to the sender, so the receiver gets the full amount from the token
        /// transfer list, and the sender is charged an additional fee; if false, the receiver does NOT get
        /// the full amount, but only what is left over after paying the fractional fee
        #[prost(bool, tag = "4")]
        pub net_of_transfers: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FractionalFee {
        #[inline]
        fn clone(&self) -> FractionalFee {
            match *self {
                FractionalFee {
                    fractional_amount: ref __self_0_0,
                    minimum_amount: ref __self_0_1,
                    maximum_amount: ref __self_0_2,
                    net_of_transfers: ref __self_0_3,
                } => FractionalFee {
                    fractional_amount: ::core::clone::Clone::clone(&(*__self_0_0)),
                    minimum_amount: ::core::clone::Clone::clone(&(*__self_0_1)),
                    maximum_amount: ::core::clone::Clone::clone(&(*__self_0_2)),
                    net_of_transfers: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FractionalFee {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FractionalFee {
        #[inline]
        fn eq(&self, other: &FractionalFee) -> bool {
            match *other {
                FractionalFee {
                    fractional_amount: ref __self_1_0,
                    minimum_amount: ref __self_1_1,
                    maximum_amount: ref __self_1_2,
                    net_of_transfers: ref __self_1_3,
                } => match *self {
                    FractionalFee {
                        fractional_amount: ref __self_0_0,
                        minimum_amount: ref __self_0_1,
                        maximum_amount: ref __self_0_2,
                        net_of_transfers: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FractionalFee) -> bool {
            match *other {
                FractionalFee {
                    fractional_amount: ref __self_1_0,
                    minimum_amount: ref __self_1_1,
                    maximum_amount: ref __self_1_2,
                    net_of_transfers: ref __self_1_3,
                } => match *self {
                    FractionalFee {
                        fractional_amount: ref __self_0_0,
                        minimum_amount: ref __self_0_1,
                        maximum_amount: ref __self_0_2,
                        net_of_transfers: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for FractionalFee {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.fractional_amount {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.minimum_amount != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.minimum_amount, buf);
            }
            if self.maximum_amount != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.maximum_amount, buf);
            }
            if self.net_of_transfers != false {
                ::prost::encoding::bool::encode(4u32, &self.net_of_transfers, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FractionalFee";
            match tag {
                1u32 => {
                    let mut value = &mut self.fractional_amount;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "fractional_amount");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.minimum_amount;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "minimum_amount");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.maximum_amount;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "maximum_amount");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.net_of_transfers;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "net_of_transfers");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .fractional_amount
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.minimum_amount != 0i64 {
                    ::prost::encoding::int64::encoded_len(2u32, &self.minimum_amount)
                } else {
                    0
                }
                + if self.maximum_amount != 0i64 {
                    ::prost::encoding::int64::encoded_len(3u32, &self.maximum_amount)
                } else {
                    0
                }
                + if self.net_of_transfers != false {
                    ::prost::encoding::bool::encoded_len(4u32, &self.net_of_transfers)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.fractional_amount = ::core::option::Option::None;
            self.minimum_amount = 0i64;
            self.maximum_amount = 0i64;
            self.net_of_transfers = false;
        }
    }
    impl ::core::default::Default for FractionalFee {
        fn default() -> Self {
            FractionalFee {
                fractional_amount: ::core::default::Default::default(),
                minimum_amount: 0i64,
                maximum_amount: 0i64,
                net_of_transfers: false,
            }
        }
    }
    impl ::core::fmt::Debug for FractionalFee {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FractionalFee");
            let builder = {
                let wrapper = &self.fractional_amount;
                builder.field("fractional_amount", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.minimum_amount)
                };
                builder.field("minimum_amount", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.maximum_amount)
                };
                builder.field("maximum_amount", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.net_of_transfers)
                };
                builder.field("net_of_transfers", &wrapper)
            };
            builder.finish()
        }
    }
    /// A fixed number of units (hbar or token) to assess as a fee during a CryptoTransfer that transfers
    /// units of the token to which this fixed fee is attached.
    pub struct FixedFee {
        /// The number of units to assess as a fee
        #[prost(int64, tag = "1")]
        pub amount: i64,
        /// The denomination of the fee; taken as hbar if left unset and, in a TokenCreate, taken as the id
        /// of the newly created token if set to the sentinel value of 0.0.0
        #[prost(message, optional, tag = "2")]
        pub denominating_token_id: ::core::option::Option<TokenId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FixedFee {
        #[inline]
        fn clone(&self) -> FixedFee {
            match *self {
                FixedFee {
                    amount: ref __self_0_0,
                    denominating_token_id: ref __self_0_1,
                } => FixedFee {
                    amount: ::core::clone::Clone::clone(&(*__self_0_0)),
                    denominating_token_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FixedFee {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FixedFee {
        #[inline]
        fn eq(&self, other: &FixedFee) -> bool {
            match *other {
                FixedFee {
                    amount: ref __self_1_0,
                    denominating_token_id: ref __self_1_1,
                } => match *self {
                    FixedFee {
                        amount: ref __self_0_0,
                        denominating_token_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FixedFee) -> bool {
            match *other {
                FixedFee {
                    amount: ref __self_1_0,
                    denominating_token_id: ref __self_1_1,
                } => match *self {
                    FixedFee {
                        amount: ref __self_0_0,
                        denominating_token_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for FixedFee {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.amount != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.amount, buf);
            }
            if let Some(ref msg) = self.denominating_token_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FixedFee";
            match tag {
                1u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.denominating_token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "denominating_token_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.amount != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.amount)
            } else {
                0
            } + self
                .denominating_token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.amount = 0i64;
            self.denominating_token_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for FixedFee {
        fn default() -> Self {
            FixedFee {
                amount: 0i64,
                denominating_token_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for FixedFee {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FixedFee");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            let builder = {
                let wrapper = &self.denominating_token_id;
                builder.field("denominating_token_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// A fee to assess during a CryptoTransfer that changes ownership of an NFT. Defines the fraction of
    /// the fungible value exchanged for an NFT that the ledger should collect as a royalty. ("Fungible
    /// value" includes both ℏ and units of fungible HTS tokens.) When the NFT sender does not receive
    /// any fungible value, the ledger will assess the fallback fee, if present, to the new NFT owner.
    /// Royalty fees can only be added to tokens of type type NON_FUNGIBLE_UNIQUE.
    pub struct RoyaltyFee {
        /// The fraction of fungible value exchanged for an NFT to collect as royalty
        #[prost(message, optional, tag = "1")]
        pub exchange_value_fraction: ::core::option::Option<Fraction>,
        /// If present, the fixed fee to assess to the NFT receiver when no fungible value is exchanged
        /// with the sender
        #[prost(message, optional, tag = "2")]
        pub fallback_fee: ::core::option::Option<FixedFee>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for RoyaltyFee {
        #[inline]
        fn clone(&self) -> RoyaltyFee {
            match *self {
                RoyaltyFee {
                    exchange_value_fraction: ref __self_0_0,
                    fallback_fee: ref __self_0_1,
                } => RoyaltyFee {
                    exchange_value_fraction: ::core::clone::Clone::clone(&(*__self_0_0)),
                    fallback_fee: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for RoyaltyFee {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for RoyaltyFee {
        #[inline]
        fn eq(&self, other: &RoyaltyFee) -> bool {
            match *other {
                RoyaltyFee {
                    exchange_value_fraction: ref __self_1_0,
                    fallback_fee: ref __self_1_1,
                } => match *self {
                    RoyaltyFee {
                        exchange_value_fraction: ref __self_0_0,
                        fallback_fee: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &RoyaltyFee) -> bool {
            match *other {
                RoyaltyFee {
                    exchange_value_fraction: ref __self_1_0,
                    fallback_fee: ref __self_1_1,
                } => match *self {
                    RoyaltyFee {
                        exchange_value_fraction: ref __self_0_0,
                        fallback_fee: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for RoyaltyFee {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.exchange_value_fraction {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.fallback_fee {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "RoyaltyFee";
            match tag {
                1u32 => {
                    let mut value = &mut self.exchange_value_fraction;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "exchange_value_fraction");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.fallback_fee;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "fallback_fee");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .exchange_value_fraction
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .fallback_fee
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.exchange_value_fraction = ::core::option::Option::None;
            self.fallback_fee = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for RoyaltyFee {
        fn default() -> Self {
            RoyaltyFee {
                exchange_value_fraction: ::core::default::Default::default(),
                fallback_fee: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for RoyaltyFee {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("RoyaltyFee");
            let builder = {
                let wrapper = &self.exchange_value_fraction;
                builder.field("exchange_value_fraction", &wrapper)
            };
            let builder = {
                let wrapper = &self.fallback_fee;
                builder.field("fallback_fee", &wrapper)
            };
            builder.finish()
        }
    }
    /// A transfer fee to assess during a CryptoTransfer that transfers units of the token to which the
    /// fee is attached. A custom fee may be either fixed or fractional, and must specify a fee collector
    /// account to receive the assessed fees. Only positive fees may be assessed.
    pub struct CustomFee {
        /// The account to receive the custom fee
        #[prost(message, optional, tag = "3")]
        pub fee_collector_account_id: ::core::option::Option<AccountId>,
        #[prost(oneof = "custom_fee::Fee", tags = "1, 2, 4")]
        pub fee: ::core::option::Option<custom_fee::Fee>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CustomFee {
        #[inline]
        fn clone(&self) -> CustomFee {
            match *self {
                CustomFee {
                    fee_collector_account_id: ref __self_0_0,
                    fee: ref __self_0_1,
                } => CustomFee {
                    fee_collector_account_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    fee: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CustomFee {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CustomFee {
        #[inline]
        fn eq(&self, other: &CustomFee) -> bool {
            match *other {
                CustomFee {
                    fee_collector_account_id: ref __self_1_0,
                    fee: ref __self_1_1,
                } => match *self {
                    CustomFee {
                        fee_collector_account_id: ref __self_0_0,
                        fee: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CustomFee) -> bool {
            match *other {
                CustomFee {
                    fee_collector_account_id: ref __self_1_0,
                    fee: ref __self_1_1,
                } => match *self {
                    CustomFee {
                        fee_collector_account_id: ref __self_0_0,
                        fee: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CustomFee {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.fee {
                oneof.encode(buf)
            }
            if let Some(ref msg) = self.fee_collector_account_id {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CustomFee";
            match tag {
                1u32 | 2u32 | 4u32 => {
                    let mut value = &mut self.fee;
                    custom_fee::Fee::merge(value, tag, wire_type, buf, ctx).map_err(|mut error| {
                        error.push(STRUCT_NAME, "fee");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.fee_collector_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "fee_collector_account_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.fee.as_ref().map_or(0, custom_fee::Fee::encoded_len)
                + self
                    .fee_collector_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
        }
        fn clear(&mut self) {
            self.fee = ::core::option::Option::None;
            self.fee_collector_account_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CustomFee {
        fn default() -> Self {
            CustomFee {
                fee: ::core::default::Default::default(),
                fee_collector_account_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CustomFee {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CustomFee");
            let builder = {
                let wrapper = &self.fee_collector_account_id;
                builder.field("fee_collector_account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.fee;
                builder.field("fee", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `CustomFee`.
    pub mod custom_fee {
        pub enum Fee {
            /// Fixed fee to be charged
            #[prost(message, tag = "1")]
            FixedFee(super::FixedFee),
            /// Fractional fee to be charged
            #[prost(message, tag = "2")]
            FractionalFee(super::FractionalFee),
            /// Royalty fee to be charged
            #[prost(message, tag = "4")]
            RoyaltyFee(super::RoyaltyFee),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Fee {
            #[inline]
            fn clone(&self) -> Fee {
                match (&*self,) {
                    (&Fee::FixedFee(ref __self_0),) => {
                        Fee::FixedFee(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Fee::FractionalFee(ref __self_0),) => {
                        Fee::FractionalFee(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Fee::RoyaltyFee(ref __self_0),) => {
                        Fee::RoyaltyFee(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Fee {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Fee {
            #[inline]
            fn eq(&self, other: &Fee) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Fee::FixedFee(ref __self_0), &Fee::FixedFee(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Fee::FractionalFee(ref __self_0),
                                &Fee::FractionalFee(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Fee::RoyaltyFee(ref __self_0), &Fee::RoyaltyFee(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Fee) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Fee::FixedFee(ref __self_0), &Fee::FixedFee(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Fee::FractionalFee(ref __self_0),
                                &Fee::FractionalFee(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Fee::RoyaltyFee(ref __self_0), &Fee::RoyaltyFee(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Fee {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Fee::FixedFee(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                    Fee::FractionalFee(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    Fee::RoyaltyFee(ref value) => {
                        ::prost::encoding::message::encode(4u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Fee>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => match field {
                        ::core::option::Option::Some(Fee::FixedFee(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Fee::FixedFee(owned_value))
                                },
                            )
                        }
                    },
                    2u32 => match field {
                        ::core::option::Option::Some(Fee::FractionalFee(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Fee::FractionalFee(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    4u32 => match field {
                        ::core::option::Option::Some(Fee::RoyaltyFee(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Fee::RoyaltyFee(owned_value))
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Fee tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Fee::FixedFee(ref value) => {
                        ::prost::encoding::message::encoded_len(1u32, &*value)
                    }
                    Fee::FractionalFee(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                    Fee::RoyaltyFee(ref value) => {
                        ::prost::encoding::message::encoded_len(4u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Fee {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Fee::FixedFee(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FixedFee").field(&wrapper).finish()
                    }
                    Fee::FractionalFee(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FractionalFee").field(&wrapper).finish()
                    }
                    Fee::RoyaltyFee(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("RoyaltyFee").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// A custom transfer fee that was assessed during handling of a CryptoTransfer.
    pub struct AssessedCustomFee {
        /// The number of units assessed for the fee
        #[prost(int64, tag = "1")]
        pub amount: i64,
        /// The denomination of the fee; taken as hbar if left unset
        #[prost(message, optional, tag = "2")]
        pub token_id: ::core::option::Option<TokenId>,
        /// The account to receive the assessed fee
        #[prost(message, optional, tag = "3")]
        pub fee_collector_account_id: ::core::option::Option<AccountId>,
        /// The account(s) whose final balances would have been higher in the absence of this assessed fee
        #[prost(message, repeated, tag = "4")]
        pub effective_payer_account_id: ::prost::alloc::vec::Vec<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for AssessedCustomFee {
        #[inline]
        fn clone(&self) -> AssessedCustomFee {
            match *self {
                AssessedCustomFee {
                    amount: ref __self_0_0,
                    token_id: ref __self_0_1,
                    fee_collector_account_id: ref __self_0_2,
                    effective_payer_account_id: ref __self_0_3,
                } => AssessedCustomFee {
                    amount: ::core::clone::Clone::clone(&(*__self_0_0)),
                    token_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    fee_collector_account_id: ::core::clone::Clone::clone(&(*__self_0_2)),
                    effective_payer_account_id: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for AssessedCustomFee {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for AssessedCustomFee {
        #[inline]
        fn eq(&self, other: &AssessedCustomFee) -> bool {
            match *other {
                AssessedCustomFee {
                    amount: ref __self_1_0,
                    token_id: ref __self_1_1,
                    fee_collector_account_id: ref __self_1_2,
                    effective_payer_account_id: ref __self_1_3,
                } => match *self {
                    AssessedCustomFee {
                        amount: ref __self_0_0,
                        token_id: ref __self_0_1,
                        fee_collector_account_id: ref __self_0_2,
                        effective_payer_account_id: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &AssessedCustomFee) -> bool {
            match *other {
                AssessedCustomFee {
                    amount: ref __self_1_0,
                    token_id: ref __self_1_1,
                    fee_collector_account_id: ref __self_1_2,
                    effective_payer_account_id: ref __self_1_3,
                } => match *self {
                    AssessedCustomFee {
                        amount: ref __self_0_0,
                        token_id: ref __self_0_1,
                        fee_collector_account_id: ref __self_0_2,
                        effective_payer_account_id: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for AssessedCustomFee {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.amount != 0i64 {
                ::prost::encoding::int64::encode(1u32, &self.amount, buf);
            }
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.fee_collector_account_id {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            for msg in &self.effective_payer_account_id {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "AssessedCustomFee";
            match tag {
                1u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.fee_collector_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "fee_collector_account_id");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.effective_payer_account_id;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "effective_payer_account_id");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.amount != 0i64 {
                ::prost::encoding::int64::encoded_len(1u32, &self.amount)
            } else {
                0
            } + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .fee_collector_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(
                    4u32,
                    &self.effective_payer_account_id,
                )
        }
        fn clear(&mut self) {
            self.amount = 0i64;
            self.token_id = ::core::option::Option::None;
            self.fee_collector_account_id = ::core::option::Option::None;
            self.effective_payer_account_id.clear();
        }
    }
    impl ::core::default::Default for AssessedCustomFee {
        fn default() -> Self {
            AssessedCustomFee {
                amount: 0i64,
                token_id: ::core::default::Default::default(),
                fee_collector_account_id: ::core::default::Default::default(),
                effective_payer_account_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for AssessedCustomFee {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("AssessedCustomFee");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.fee_collector_account_id;
                builder.field("fee_collector_account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.effective_payer_account_id;
                builder.field("effective_payer_account_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Create a new token. After the token is created, the Token ID for it is in the receipt.
    /// The specified Treasury Account is receiving the initial supply of tokens as-well as the tokens
    /// from the Token Mint operation once executed. The balance of the treasury account is decreased
    /// when the Token Burn operation is executed.
    ///
    /// The <tt>initialSupply</tt> is the initial supply of the smallest parts of a token (like a
    /// tinybar, not an hbar). These are the smallest units of the token which may be transferred.
    ///
    /// The supply can change over time. If the total supply at some moment is <i>S</i> parts of tokens,
    /// and the token is using <i>D</i> decimals, then <i>S</i> must be less than or equal to
    /// 2<sup>63</sup>-1, which is 9,223,372,036,854,775,807. The number of whole tokens (not parts) will
    /// be <i>S / 10<sup>D</sup></i>.
    ///
    /// If decimals is 8 or 11, then the number of whole tokens can be at most a few billions or
    /// millions, respectively. For example, it could match Bitcoin (21 million whole tokens with 8
    /// decimals) or hbars (50 billion whole tokens with 8 decimals). It could even match Bitcoin with
    /// milli-satoshis (21 million whole tokens with 11 decimals).
    ///
    /// Note that a created token is <i>immutable</i> if the <tt>adminKey</tt> is omitted. No property of
    /// an immutable token can ever change, with the sole exception of its expiry. Anyone can pay to
    /// extend the expiry time of an immutable token.
    ///
    /// A token can be either <i>FUNGIBLE_COMMON</i> or <i>NON_FUNGIBLE_UNIQUE</i>, based on its
    /// <i>TokenType</i>. If it has been omitted, <i>FUNGIBLE_COMMON</i> type is used.
    ///
    /// A token can have either <i>INFINITE</i> or <i>FINITE</i> supply type, based on its
    /// <i>TokenType</i>. If it has been omitted, <i>INFINITE</i> type is used.
    ///
    /// If a <i>FUNGIBLE</i> TokenType is used, <i>initialSupply</i> should explicitly be set to a
    /// non-negative. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
    ///
    /// If a <i>NON_FUNGIBLE_UNIQUE</i> TokenType is used, <i>initialSupply</i> should explicitly be set
    /// to 0. If not, the transaction will resolve to INVALID_TOKEN_INITIAL_SUPPLY.
    ///
    /// If an <i>INFINITE</i> TokenSupplyType is used, <i>maxSupply</i> should explicitly be set to 0. If
    /// it is not 0, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
    ///
    /// If a <i>FINITE</i> TokenSupplyType is used, <i>maxSupply</i> should be explicitly set to a
    /// non-negative value. If it is not, the transaction will resolve to INVALID_TOKEN_MAX_SUPPLY.
    pub struct TokenCreateTransactionBody {
        /// The publicly visible name of the token. The token name is specified as a Unicode string.
        /// Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The publicly visible token symbol. The token symbol is specified as a Unicode string.
        /// Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
        #[prost(string, tag = "2")]
        pub symbol: ::prost::alloc::string::String,
        /// For tokens of type FUNGIBLE_COMMON - the number of decimal places a
        /// token is divisible by. For tokens of type NON_FUNGIBLE_UNIQUE - value
        /// must be 0
        #[prost(uint32, tag = "3")]
        pub decimals: u32,
        /// Specifies the initial supply of tokens to be put in circulation. The
        /// initial supply is sent to the Treasury Account. The supply is in the
        /// lowest denomination possible. In the case for NON_FUNGIBLE_UNIQUE Type
        /// the value must be 0
        #[prost(uint64, tag = "4")]
        pub initial_supply: u64,
        /// The account which will act as a treasury for the token. This account
        /// will receive the specified initial supply or the newly minted NFTs in
        /// the case for NON_FUNGIBLE_UNIQUE Type
        #[prost(message, optional, tag = "5")]
        pub treasury: ::core::option::Option<AccountId>,
        /// The key which can perform update/delete operations on the token. If empty, the token can be
        /// perceived as immutable (not being able to be updated/deleted)
        #[prost(message, optional, tag = "6")]
        pub admin_key: ::core::option::Option<Key>,
        /// The key which can grant or revoke KYC of an account for the token's transactions. If empty,
        /// KYC is not required, and KYC grant or revoke operations are not possible.
        #[prost(message, optional, tag = "7")]
        pub kyc_key: ::core::option::Option<Key>,
        /// The key which can sign to freeze or unfreeze an account for token transactions. If empty,
        /// freezing is not possible
        #[prost(message, optional, tag = "8")]
        pub freeze_key: ::core::option::Option<Key>,
        /// The key which can wipe the token balance of an account. If empty, wipe is not possible
        #[prost(message, optional, tag = "9")]
        pub wipe_key: ::core::option::Option<Key>,
        /// The key which can change the supply of a token. The key is used to sign Token Mint/Burn
        /// operations
        #[prost(message, optional, tag = "10")]
        pub supply_key: ::core::option::Option<Key>,
        /// The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If
        /// true, an account must be unfrozen before it can receive the token
        #[prost(bool, tag = "11")]
        pub freeze_default: bool,
        /// The epoch second at which the token should expire; if an auto-renew account and period are
        /// specified, this is coerced to the current epoch second plus the autoRenewPeriod
        #[prost(message, optional, tag = "13")]
        pub expiry: ::core::option::Option<Timestamp>,
        /// An account which will be automatically charged to renew the token's expiration, at
        /// autoRenewPeriod interval
        #[prost(message, optional, tag = "14")]
        pub auto_renew_account: ::core::option::Option<AccountId>,
        /// The interval at which the auto-renew account will be charged to extend the token's expiry
        #[prost(message, optional, tag = "15")]
        pub auto_renew_period: ::core::option::Option<Duration>,
        /// The memo associated with the token (UTF-8 encoding max 100 bytes)
        #[prost(string, tag = "16")]
        pub memo: ::prost::alloc::string::String,
        /// IWA compatibility. Specifies the token type. Defaults to FUNGIBLE_COMMON
        #[prost(enumeration = "TokenType", tag = "17")]
        pub token_type: i32,
        /// IWA compatibility. Specified the token supply type. Defaults to INFINITE
        #[prost(enumeration = "TokenSupplyType", tag = "18")]
        pub supply_type: i32,
        /// IWA Compatibility. Depends on TokenSupplyType. For tokens of type FUNGIBLE_COMMON - the
        /// maximum number of tokens that can be in circulation. For tokens of type NON_FUNGIBLE_UNIQUE -
        /// the maximum number of NFTs (serial numbers) that can be minted. This field can never be
        /// changed!
        #[prost(int64, tag = "19")]
        pub max_supply: i64,
        /// The key which can change the token's custom fee schedule; must sign a TokenFeeScheduleUpdate
        /// transaction
        #[prost(message, optional, tag = "20")]
        pub fee_schedule_key: ::core::option::Option<Key>,
        /// The custom fees to be assessed during a CryptoTransfer that transfers units of this token
        #[prost(message, repeated, tag = "21")]
        pub custom_fees: ::prost::alloc::vec::Vec<CustomFee>,
        /// The Key which can pause and unpause the Token.
        /// If Empty the token pause status defaults to PauseNotApplicable, otherwise Unpaused.
        #[prost(message, optional, tag = "22")]
        pub pause_key: ::core::option::Option<Key>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenCreateTransactionBody {
        #[inline]
        fn clone(&self) -> TokenCreateTransactionBody {
            match *self {
                TokenCreateTransactionBody {
                    name: ref __self_0_0,
                    symbol: ref __self_0_1,
                    decimals: ref __self_0_2,
                    initial_supply: ref __self_0_3,
                    treasury: ref __self_0_4,
                    admin_key: ref __self_0_5,
                    kyc_key: ref __self_0_6,
                    freeze_key: ref __self_0_7,
                    wipe_key: ref __self_0_8,
                    supply_key: ref __self_0_9,
                    freeze_default: ref __self_0_10,
                    expiry: ref __self_0_11,
                    auto_renew_account: ref __self_0_12,
                    auto_renew_period: ref __self_0_13,
                    memo: ref __self_0_14,
                    token_type: ref __self_0_15,
                    supply_type: ref __self_0_16,
                    max_supply: ref __self_0_17,
                    fee_schedule_key: ref __self_0_18,
                    custom_fees: ref __self_0_19,
                    pause_key: ref __self_0_20,
                } => TokenCreateTransactionBody {
                    name: ::core::clone::Clone::clone(&(*__self_0_0)),
                    symbol: ::core::clone::Clone::clone(&(*__self_0_1)),
                    decimals: ::core::clone::Clone::clone(&(*__self_0_2)),
                    initial_supply: ::core::clone::Clone::clone(&(*__self_0_3)),
                    treasury: ::core::clone::Clone::clone(&(*__self_0_4)),
                    admin_key: ::core::clone::Clone::clone(&(*__self_0_5)),
                    kyc_key: ::core::clone::Clone::clone(&(*__self_0_6)),
                    freeze_key: ::core::clone::Clone::clone(&(*__self_0_7)),
                    wipe_key: ::core::clone::Clone::clone(&(*__self_0_8)),
                    supply_key: ::core::clone::Clone::clone(&(*__self_0_9)),
                    freeze_default: ::core::clone::Clone::clone(&(*__self_0_10)),
                    expiry: ::core::clone::Clone::clone(&(*__self_0_11)),
                    auto_renew_account: ::core::clone::Clone::clone(&(*__self_0_12)),
                    auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_13)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_14)),
                    token_type: ::core::clone::Clone::clone(&(*__self_0_15)),
                    supply_type: ::core::clone::Clone::clone(&(*__self_0_16)),
                    max_supply: ::core::clone::Clone::clone(&(*__self_0_17)),
                    fee_schedule_key: ::core::clone::Clone::clone(&(*__self_0_18)),
                    custom_fees: ::core::clone::Clone::clone(&(*__self_0_19)),
                    pause_key: ::core::clone::Clone::clone(&(*__self_0_20)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenCreateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenCreateTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenCreateTransactionBody) -> bool {
            match *other {
                TokenCreateTransactionBody {
                    name: ref __self_1_0,
                    symbol: ref __self_1_1,
                    decimals: ref __self_1_2,
                    initial_supply: ref __self_1_3,
                    treasury: ref __self_1_4,
                    admin_key: ref __self_1_5,
                    kyc_key: ref __self_1_6,
                    freeze_key: ref __self_1_7,
                    wipe_key: ref __self_1_8,
                    supply_key: ref __self_1_9,
                    freeze_default: ref __self_1_10,
                    expiry: ref __self_1_11,
                    auto_renew_account: ref __self_1_12,
                    auto_renew_period: ref __self_1_13,
                    memo: ref __self_1_14,
                    token_type: ref __self_1_15,
                    supply_type: ref __self_1_16,
                    max_supply: ref __self_1_17,
                    fee_schedule_key: ref __self_1_18,
                    custom_fees: ref __self_1_19,
                    pause_key: ref __self_1_20,
                } => match *self {
                    TokenCreateTransactionBody {
                        name: ref __self_0_0,
                        symbol: ref __self_0_1,
                        decimals: ref __self_0_2,
                        initial_supply: ref __self_0_3,
                        treasury: ref __self_0_4,
                        admin_key: ref __self_0_5,
                        kyc_key: ref __self_0_6,
                        freeze_key: ref __self_0_7,
                        wipe_key: ref __self_0_8,
                        supply_key: ref __self_0_9,
                        freeze_default: ref __self_0_10,
                        expiry: ref __self_0_11,
                        auto_renew_account: ref __self_0_12,
                        auto_renew_period: ref __self_0_13,
                        memo: ref __self_0_14,
                        token_type: ref __self_0_15,
                        supply_type: ref __self_0_16,
                        max_supply: ref __self_0_17,
                        fee_schedule_key: ref __self_0_18,
                        custom_fees: ref __self_0_19,
                        pause_key: ref __self_0_20,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                            && (*__self_0_11) == (*__self_1_11)
                            && (*__self_0_12) == (*__self_1_12)
                            && (*__self_0_13) == (*__self_1_13)
                            && (*__self_0_14) == (*__self_1_14)
                            && (*__self_0_15) == (*__self_1_15)
                            && (*__self_0_16) == (*__self_1_16)
                            && (*__self_0_17) == (*__self_1_17)
                            && (*__self_0_18) == (*__self_1_18)
                            && (*__self_0_19) == (*__self_1_19)
                            && (*__self_0_20) == (*__self_1_20)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenCreateTransactionBody) -> bool {
            match *other {
                TokenCreateTransactionBody {
                    name: ref __self_1_0,
                    symbol: ref __self_1_1,
                    decimals: ref __self_1_2,
                    initial_supply: ref __self_1_3,
                    treasury: ref __self_1_4,
                    admin_key: ref __self_1_5,
                    kyc_key: ref __self_1_6,
                    freeze_key: ref __self_1_7,
                    wipe_key: ref __self_1_8,
                    supply_key: ref __self_1_9,
                    freeze_default: ref __self_1_10,
                    expiry: ref __self_1_11,
                    auto_renew_account: ref __self_1_12,
                    auto_renew_period: ref __self_1_13,
                    memo: ref __self_1_14,
                    token_type: ref __self_1_15,
                    supply_type: ref __self_1_16,
                    max_supply: ref __self_1_17,
                    fee_schedule_key: ref __self_1_18,
                    custom_fees: ref __self_1_19,
                    pause_key: ref __self_1_20,
                } => match *self {
                    TokenCreateTransactionBody {
                        name: ref __self_0_0,
                        symbol: ref __self_0_1,
                        decimals: ref __self_0_2,
                        initial_supply: ref __self_0_3,
                        treasury: ref __self_0_4,
                        admin_key: ref __self_0_5,
                        kyc_key: ref __self_0_6,
                        freeze_key: ref __self_0_7,
                        wipe_key: ref __self_0_8,
                        supply_key: ref __self_0_9,
                        freeze_default: ref __self_0_10,
                        expiry: ref __self_0_11,
                        auto_renew_account: ref __self_0_12,
                        auto_renew_period: ref __self_0_13,
                        memo: ref __self_0_14,
                        token_type: ref __self_0_15,
                        supply_type: ref __self_0_16,
                        max_supply: ref __self_0_17,
                        fee_schedule_key: ref __self_0_18,
                        custom_fees: ref __self_0_19,
                        pause_key: ref __self_0_20,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                            || (*__self_0_11) != (*__self_1_11)
                            || (*__self_0_12) != (*__self_1_12)
                            || (*__self_0_13) != (*__self_1_13)
                            || (*__self_0_14) != (*__self_1_14)
                            || (*__self_0_15) != (*__self_1_15)
                            || (*__self_0_16) != (*__self_1_16)
                            || (*__self_0_17) != (*__self_1_17)
                            || (*__self_0_18) != (*__self_1_18)
                            || (*__self_0_19) != (*__self_1_19)
                            || (*__self_0_20) != (*__self_1_20)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenCreateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.name != "" {
                ::prost::encoding::string::encode(1u32, &self.name, buf);
            }
            if self.symbol != "" {
                ::prost::encoding::string::encode(2u32, &self.symbol, buf);
            }
            if self.decimals != 0u32 {
                ::prost::encoding::uint32::encode(3u32, &self.decimals, buf);
            }
            if self.initial_supply != 0u64 {
                ::prost::encoding::uint64::encode(4u32, &self.initial_supply, buf);
            }
            if let Some(ref msg) = self.treasury {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
            if let Some(ref msg) = self.admin_key {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            if let Some(ref msg) = self.kyc_key {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            if let Some(ref msg) = self.freeze_key {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
            if let Some(ref msg) = self.wipe_key {
                ::prost::encoding::message::encode(9u32, msg, buf);
            }
            if let Some(ref msg) = self.supply_key {
                ::prost::encoding::message::encode(10u32, msg, buf);
            }
            if self.freeze_default != false {
                ::prost::encoding::bool::encode(11u32, &self.freeze_default, buf);
            }
            if let Some(ref msg) = self.expiry {
                ::prost::encoding::message::encode(13u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_account {
                ::prost::encoding::message::encode(14u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_period {
                ::prost::encoding::message::encode(15u32, msg, buf);
            }
            if self.memo != "" {
                ::prost::encoding::string::encode(16u32, &self.memo, buf);
            }
            if self.token_type != TokenType::default() as i32 {
                ::prost::encoding::int32::encode(17u32, &self.token_type, buf);
            }
            if self.supply_type != TokenSupplyType::default() as i32 {
                ::prost::encoding::int32::encode(18u32, &self.supply_type, buf);
            }
            if self.max_supply != 0i64 {
                ::prost::encoding::int64::encode(19u32, &self.max_supply, buf);
            }
            if let Some(ref msg) = self.fee_schedule_key {
                ::prost::encoding::message::encode(20u32, msg, buf);
            }
            for msg in &self.custom_fees {
                ::prost::encoding::message::encode(21u32, msg, buf);
            }
            if let Some(ref msg) = self.pause_key {
                ::prost::encoding::message::encode(22u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenCreateTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.name;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "name");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.symbol;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "symbol");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.decimals;
                    ::prost::encoding::uint32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "decimals");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.initial_supply;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "initial_supply");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.treasury;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "treasury");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "admin_key");
                        error
                    })
                }
                7u32 => {
                    let mut value = &mut self.kyc_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "kyc_key");
                        error
                    })
                }
                8u32 => {
                    let mut value = &mut self.freeze_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "freeze_key");
                        error
                    })
                }
                9u32 => {
                    let mut value = &mut self.wipe_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "wipe_key");
                        error
                    })
                }
                10u32 => {
                    let mut value = &mut self.supply_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "supply_key");
                        error
                    })
                }
                11u32 => {
                    let mut value = &mut self.freeze_default;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "freeze_default");
                            error
                        },
                    )
                }
                13u32 => {
                    let mut value = &mut self.expiry;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiry");
                        error
                    })
                }
                14u32 => {
                    let mut value = &mut self.auto_renew_account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_account");
                        error
                    })
                }
                15u32 => {
                    let mut value = &mut self.auto_renew_period;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_period");
                        error
                    })
                }
                16u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                17u32 => {
                    let mut value = &mut self.token_type;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "token_type");
                            error
                        },
                    )
                }
                18u32 => {
                    let mut value = &mut self.supply_type;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "supply_type");
                            error
                        },
                    )
                }
                19u32 => {
                    let mut value = &mut self.max_supply;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "max_supply");
                            error
                        },
                    )
                }
                20u32 => {
                    let mut value = &mut self.fee_schedule_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "fee_schedule_key");
                        error
                    })
                }
                21u32 => {
                    let mut value = &mut self.custom_fees;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "custom_fees");
                            error
                        },
                    )
                }
                22u32 => {
                    let mut value = &mut self.pause_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "pause_key");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.name != "" {
                ::prost::encoding::string::encoded_len(1u32, &self.name)
            } else {
                0
            } + if self.symbol != "" {
                ::prost::encoding::string::encoded_len(2u32, &self.symbol)
            } else {
                0
            } + if self.decimals != 0u32 {
                ::prost::encoding::uint32::encoded_len(3u32, &self.decimals)
            } else {
                0
            } + if self.initial_supply != 0u64 {
                ::prost::encoding::uint64::encoded_len(4u32, &self.initial_supply)
            } else {
                0
            } + self
                .treasury
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                + self
                    .admin_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                + self
                    .kyc_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                + self
                    .freeze_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(8u32, msg))
                + self
                    .wipe_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(9u32, msg))
                + self
                    .supply_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(10u32, msg))
                + if self.freeze_default != false {
                    ::prost::encoding::bool::encoded_len(11u32, &self.freeze_default)
                } else {
                    0
                }
                + self
                    .expiry
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(13u32, msg))
                + self
                    .auto_renew_account
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(14u32, msg))
                + self
                    .auto_renew_period
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(15u32, msg))
                + if self.memo != "" {
                    ::prost::encoding::string::encoded_len(16u32, &self.memo)
                } else {
                    0
                }
                + if self.token_type != TokenType::default() as i32 {
                    ::prost::encoding::int32::encoded_len(17u32, &self.token_type)
                } else {
                    0
                }
                + if self.supply_type != TokenSupplyType::default() as i32 {
                    ::prost::encoding::int32::encoded_len(18u32, &self.supply_type)
                } else {
                    0
                }
                + if self.max_supply != 0i64 {
                    ::prost::encoding::int64::encoded_len(19u32, &self.max_supply)
                } else {
                    0
                }
                + self
                    .fee_schedule_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(20u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(21u32, &self.custom_fees)
                + self
                    .pause_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(22u32, msg))
        }
        fn clear(&mut self) {
            self.name.clear();
            self.symbol.clear();
            self.decimals = 0u32;
            self.initial_supply = 0u64;
            self.treasury = ::core::option::Option::None;
            self.admin_key = ::core::option::Option::None;
            self.kyc_key = ::core::option::Option::None;
            self.freeze_key = ::core::option::Option::None;
            self.wipe_key = ::core::option::Option::None;
            self.supply_key = ::core::option::Option::None;
            self.freeze_default = false;
            self.expiry = ::core::option::Option::None;
            self.auto_renew_account = ::core::option::Option::None;
            self.auto_renew_period = ::core::option::Option::None;
            self.memo.clear();
            self.token_type = TokenType::default() as i32;
            self.supply_type = TokenSupplyType::default() as i32;
            self.max_supply = 0i64;
            self.fee_schedule_key = ::core::option::Option::None;
            self.custom_fees.clear();
            self.pause_key = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenCreateTransactionBody {
        fn default() -> Self {
            TokenCreateTransactionBody {
                name: ::prost::alloc::string::String::new(),
                symbol: ::prost::alloc::string::String::new(),
                decimals: 0u32,
                initial_supply: 0u64,
                treasury: ::core::default::Default::default(),
                admin_key: ::core::default::Default::default(),
                kyc_key: ::core::default::Default::default(),
                freeze_key: ::core::default::Default::default(),
                wipe_key: ::core::default::Default::default(),
                supply_key: ::core::default::Default::default(),
                freeze_default: false,
                expiry: ::core::default::Default::default(),
                auto_renew_account: ::core::default::Default::default(),
                auto_renew_period: ::core::default::Default::default(),
                memo: ::prost::alloc::string::String::new(),
                token_type: TokenType::default() as i32,
                supply_type: TokenSupplyType::default() as i32,
                max_supply: 0i64,
                fee_schedule_key: ::core::default::Default::default(),
                custom_fees: ::core::default::Default::default(),
                pause_key: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenCreateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenCreateTransactionBody");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.name)
                };
                builder.field("name", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.symbol)
                };
                builder.field("symbol", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.decimals)
                };
                builder.field("decimals", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.initial_supply)
                };
                builder.field("initial_supply", &wrapper)
            };
            let builder = {
                let wrapper = &self.treasury;
                builder.field("treasury", &wrapper)
            };
            let builder = {
                let wrapper = &self.admin_key;
                builder.field("admin_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.kyc_key;
                builder.field("kyc_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.freeze_key;
                builder.field("freeze_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.wipe_key;
                builder.field("wipe_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.supply_key;
                builder.field("supply_key", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.freeze_default)
                };
                builder.field("freeze_default", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiry;
                builder.field("expiry", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_account;
                builder.field("auto_renew_account", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_period;
                builder.field("auto_renew_period", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match TokenType::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.token_type)
                };
                builder.field("token_type", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match TokenSupplyType::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.supply_type)
                };
                builder.field("supply_type", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.max_supply)
                };
                builder.field("max_supply", &wrapper)
            };
            let builder = {
                let wrapper = &self.fee_schedule_key;
                builder.field("fee_schedule_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.custom_fees;
                builder.field("custom_fees", &wrapper)
            };
            let builder = {
                let wrapper = &self.pause_key;
                builder.field("pause_key", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl TokenCreateTransactionBody {
        ///Returns the enum value of `token_type`, or the default if the field is set to an invalid enum value.
        pub fn token_type(&self) -> TokenType {
            TokenType::from_i32(self.token_type).unwrap_or(TokenType::default())
        }
        ///Sets `token_type` to the provided enum value.
        pub fn set_token_type(&mut self, value: TokenType) {
            self.token_type = value as i32;
        }
        ///Returns the enum value of `supply_type`, or the default if the field is set to an invalid enum value.
        pub fn supply_type(&self) -> TokenSupplyType {
            TokenSupplyType::from_i32(self.supply_type).unwrap_or(TokenSupplyType::default())
        }
        ///Sets `supply_type` to the provided enum value.
        pub fn set_supply_type(&mut self, value: TokenSupplyType) {
            self.supply_type = value as i32;
        }
    }
    /// Freezes transfers of the specified token for the account. Must be signed by the Token's freezeKey.
    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
    /// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
    /// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
    /// If an Association between the provided token and account is not found, the transaction will
    /// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
    /// If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
    /// Once executed the Account is marked as Frozen and will not be able to receive or send tokens
    /// unless unfrozen. The operation is idempotent.
    pub struct TokenFreezeAccountTransactionBody {
        /// The token for which this account will be frozen. If token does not exist, transaction results
        /// in INVALID_TOKEN_ID
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
        /// The account to be frozen
        #[prost(message, optional, tag = "2")]
        pub account: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenFreezeAccountTransactionBody {
        #[inline]
        fn clone(&self) -> TokenFreezeAccountTransactionBody {
            match *self {
                TokenFreezeAccountTransactionBody {
                    token: ref __self_0_0,
                    account: ref __self_0_1,
                } => TokenFreezeAccountTransactionBody {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenFreezeAccountTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenFreezeAccountTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenFreezeAccountTransactionBody) -> bool {
            match *other {
                TokenFreezeAccountTransactionBody {
                    token: ref __self_1_0,
                    account: ref __self_1_1,
                } => match *self {
                    TokenFreezeAccountTransactionBody {
                        token: ref __self_0_0,
                        account: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenFreezeAccountTransactionBody) -> bool {
            match *other {
                TokenFreezeAccountTransactionBody {
                    token: ref __self_1_0,
                    account: ref __self_1_1,
                } => match *self {
                    TokenFreezeAccountTransactionBody {
                        token: ref __self_0_0,
                        account: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenFreezeAccountTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenFreezeAccountTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
            self.account = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenFreezeAccountTransactionBody {
        fn default() -> Self {
            TokenFreezeAccountTransactionBody {
                token: ::core::default::Default::default(),
                account: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenFreezeAccountTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenFreezeAccountTransactionBody");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            let builder = {
                let wrapper = &self.account;
                builder.field("account", &wrapper)
            };
            builder.finish()
        }
    }
    /// Unfreezes transfers of the specified token for the account. Must be signed by the Token's
    /// freezeKey.
    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
    /// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
    /// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
    /// If an Association between the provided token and account is not found, the transaction will
    /// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
    /// If no Freeze Key is defined, the transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
    /// Once executed the Account is marked as Unfrozen and will be able to receive or send tokens. The
    /// operation is idempotent.
    pub struct TokenUnfreezeAccountTransactionBody {
        /// The token for which this account will be unfrozen. If token does not exist, transaction
        /// results in INVALID_TOKEN_ID
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
        /// The account to be unfrozen
        #[prost(message, optional, tag = "2")]
        pub account: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenUnfreezeAccountTransactionBody {
        #[inline]
        fn clone(&self) -> TokenUnfreezeAccountTransactionBody {
            match *self {
                TokenUnfreezeAccountTransactionBody {
                    token: ref __self_0_0,
                    account: ref __self_0_1,
                } => TokenUnfreezeAccountTransactionBody {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenUnfreezeAccountTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenUnfreezeAccountTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenUnfreezeAccountTransactionBody) -> bool {
            match *other {
                TokenUnfreezeAccountTransactionBody {
                    token: ref __self_1_0,
                    account: ref __self_1_1,
                } => match *self {
                    TokenUnfreezeAccountTransactionBody {
                        token: ref __self_0_0,
                        account: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenUnfreezeAccountTransactionBody) -> bool {
            match *other {
                TokenUnfreezeAccountTransactionBody {
                    token: ref __self_1_0,
                    account: ref __self_1_1,
                } => match *self {
                    TokenUnfreezeAccountTransactionBody {
                        token: ref __self_0_0,
                        account: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenUnfreezeAccountTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenUnfreezeAccountTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
            self.account = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenUnfreezeAccountTransactionBody {
        fn default() -> Self {
            TokenUnfreezeAccountTransactionBody {
                token: ::core::default::Default::default(),
                account: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenUnfreezeAccountTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenUnfreezeAccountTransactionBody");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            let builder = {
                let wrapper = &self.account;
                builder.field("account", &wrapper)
            };
            builder.finish()
        }
    }
    /// Grants KYC to the account for the given token. Must be signed by the Token's kycKey.
    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
    /// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
    /// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
    /// If an Association between the provided token and account is not found, the transaction will
    /// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
    /// If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
    /// Once executed the Account is marked as KYC Granted.
    pub struct TokenGrantKycTransactionBody {
        /// The token for which this account will be granted KYC. If token does not exist, transaction
        /// results in INVALID_TOKEN_ID
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
        /// The account to be KYCed
        #[prost(message, optional, tag = "2")]
        pub account: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenGrantKycTransactionBody {
        #[inline]
        fn clone(&self) -> TokenGrantKycTransactionBody {
            match *self {
                TokenGrantKycTransactionBody {
                    token: ref __self_0_0,
                    account: ref __self_0_1,
                } => TokenGrantKycTransactionBody {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenGrantKycTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenGrantKycTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenGrantKycTransactionBody) -> bool {
            match *other {
                TokenGrantKycTransactionBody {
                    token: ref __self_1_0,
                    account: ref __self_1_1,
                } => match *self {
                    TokenGrantKycTransactionBody {
                        token: ref __self_0_0,
                        account: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenGrantKycTransactionBody) -> bool {
            match *other {
                TokenGrantKycTransactionBody {
                    token: ref __self_1_0,
                    account: ref __self_1_1,
                } => match *self {
                    TokenGrantKycTransactionBody {
                        token: ref __self_0_0,
                        account: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenGrantKycTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenGrantKycTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
            self.account = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenGrantKycTransactionBody {
        fn default() -> Self {
            TokenGrantKycTransactionBody {
                token: ::core::default::Default::default(),
                account: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenGrantKycTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenGrantKycTransactionBody");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            let builder = {
                let wrapper = &self.account;
                builder.field("account", &wrapper)
            };
            builder.finish()
        }
    }
    /// Revokes KYC to the account for the given token. Must be signed by the Token's kycKey.
    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
    /// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
    /// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
    /// If an Association between the provided token and account is not found, the transaction will
    /// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
    /// If no KYC Key is defined, the transaction will resolve to TOKEN_HAS_NO_KYC_KEY.
    /// Once executed the Account is marked as KYC Revoked
    pub struct TokenRevokeKycTransactionBody {
        /// The token for which this account will get his KYC revoked. If token does not exist,
        /// transaction results in INVALID_TOKEN_ID
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
        /// The account to be KYC Revoked
        #[prost(message, optional, tag = "2")]
        pub account: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenRevokeKycTransactionBody {
        #[inline]
        fn clone(&self) -> TokenRevokeKycTransactionBody {
            match *self {
                TokenRevokeKycTransactionBody {
                    token: ref __self_0_0,
                    account: ref __self_0_1,
                } => TokenRevokeKycTransactionBody {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenRevokeKycTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenRevokeKycTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenRevokeKycTransactionBody) -> bool {
            match *other {
                TokenRevokeKycTransactionBody {
                    token: ref __self_1_0,
                    account: ref __self_1_1,
                } => match *self {
                    TokenRevokeKycTransactionBody {
                        token: ref __self_0_0,
                        account: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenRevokeKycTransactionBody) -> bool {
            match *other {
                TokenRevokeKycTransactionBody {
                    token: ref __self_1_0,
                    account: ref __self_1_1,
                } => match *self {
                    TokenRevokeKycTransactionBody {
                        token: ref __self_0_0,
                        account: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenRevokeKycTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenRevokeKycTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
            self.account = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenRevokeKycTransactionBody {
        fn default() -> Self {
            TokenRevokeKycTransactionBody {
                token: ::core::default::Default::default(),
                account: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenRevokeKycTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenRevokeKycTransactionBody");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            let builder = {
                let wrapper = &self.account;
                builder.field("account", &wrapper)
            };
            builder.finish()
        }
    }
    /// Marks a token as deleted, though it will remain in the ledger.
    /// The operation must be signed by the specified Admin Key of the Token. If
    /// admin key is not set, Transaction will result in TOKEN_IS_IMMUTABlE.
    /// Once deleted update, mint, burn, wipe, freeze, unfreeze, grant kyc, revoke
    /// kyc and token transfer transactions will resolve to TOKEN_WAS_DELETED.
    pub struct TokenDeleteTransactionBody {
        /// The token to be deleted. If invalid token is specified, transaction will
        /// result in INVALID_TOKEN_ID
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenDeleteTransactionBody {
        #[inline]
        fn clone(&self) -> TokenDeleteTransactionBody {
            match *self {
                TokenDeleteTransactionBody {
                    token: ref __self_0_0,
                } => TokenDeleteTransactionBody {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenDeleteTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenDeleteTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenDeleteTransactionBody) -> bool {
            match *other {
                TokenDeleteTransactionBody {
                    token: ref __self_1_0,
                } => match *self {
                    TokenDeleteTransactionBody {
                        token: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenDeleteTransactionBody) -> bool {
            match *other {
                TokenDeleteTransactionBody {
                    token: ref __self_1_0,
                } => match *self {
                    TokenDeleteTransactionBody {
                        token: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for TokenDeleteTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenDeleteTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenDeleteTransactionBody {
        fn default() -> Self {
            TokenDeleteTransactionBody {
                token: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenDeleteTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenDeleteTransactionBody");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            builder.finish()
        }
    }
    /// At consensus, updates an already created token to the given values.
    ///
    /// If no value is given for a field, that field is left unchanged. For an immutable tokens (that is,
    /// a token without an admin key), only the expiry may be updated. Setting any other field in that
    /// case will cause the transaction status to resolve to TOKEN_IS_IMMUTABLE.
    ///
    /// --- Signing Requirements ---
    /// 1. Whether or not a token has an admin key, its expiry can be extended with only the transaction
    ///    payer's signature.
    /// 2. Updating any other field of a mutable token requires the admin key's signature.
    /// 3. If a new admin key is set, this new key must sign <b>unless</b> it is exactly an empty
    ///    <tt>KeyList</tt>. This special sentinel key removes the existing admin key and causes the
    ///    token to become immutable. (Other <tt>Key</tt> structures without a constituent
    ///    <tt>Ed25519</tt> key will be rejected with <tt>INVALID_ADMIN_KEY</tt>.)
    /// 4. If a new treasury is set, the new treasury account's key must sign the transaction.
    ///
    /// --- Nft Requirements ---
    /// 1. If a non fungible token has a positive treasury balance, the operation will abort with
    ///    CURRENT_TREASURY_STILL_OWNS_NFTS.
    pub struct TokenUpdateTransactionBody {
        /// The Token to be updated
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
        /// The new publicly visible token symbol. The token symbol is specified as a Unicode string.
        /// Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
        #[prost(string, tag = "2")]
        pub symbol: ::prost::alloc::string::String,
        /// The new publicly visible name of the token. The token name is specified as a Unicode string.
        /// Its UTF-8 encoding cannot exceed 100 bytes, and cannot contain the 0 byte (NUL).
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
        /// The new Treasury account of the Token. If the provided treasury account is not existing or
        /// deleted, the response will be INVALID_TREASURY_ACCOUNT_FOR_TOKEN. If successful, the Token
        /// balance held in the previous Treasury Account is transferred to the new one.
        #[prost(message, optional, tag = "4")]
        pub treasury: ::core::option::Option<AccountId>,
        /// The new admin key of the Token. If Token is immutable, transaction will resolve to
        /// TOKEN_IS_IMMUTABlE.
        #[prost(message, optional, tag = "5")]
        pub admin_key: ::core::option::Option<Key>,
        /// The new KYC key of the Token. If Token does not have currently a KYC key, transaction will
        /// resolve to TOKEN_HAS_NO_KYC_KEY.
        #[prost(message, optional, tag = "6")]
        pub kyc_key: ::core::option::Option<Key>,
        /// The new Freeze key of the Token. If the Token does not have currently a Freeze key,
        /// transaction will resolve to TOKEN_HAS_NO_FREEZE_KEY.
        #[prost(message, optional, tag = "7")]
        pub freeze_key: ::core::option::Option<Key>,
        /// The new Wipe key of the Token. If the Token does not have currently a Wipe key, transaction
        /// will resolve to TOKEN_HAS_NO_WIPE_KEY.
        #[prost(message, optional, tag = "8")]
        pub wipe_key: ::core::option::Option<Key>,
        /// The new Supply key of the Token. If the Token does not have currently a Supply key,
        /// transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY.
        #[prost(message, optional, tag = "9")]
        pub supply_key: ::core::option::Option<Key>,
        /// The new account which will be automatically charged to renew the token's expiration, at
        /// autoRenewPeriod interval.
        #[prost(message, optional, tag = "10")]
        pub auto_renew_account: ::core::option::Option<AccountId>,
        /// The new interval at which the auto-renew account will be charged to extend the token's
        /// expiry.
        #[prost(message, optional, tag = "11")]
        pub auto_renew_period: ::core::option::Option<Duration>,
        /// The new expiry time of the token. Expiry can be updated even if admin key is not set. If the
        /// provided expiry is earlier than the current token expiry, transaction wil resolve to
        /// INVALID_EXPIRATION_TIME
        #[prost(message, optional, tag = "12")]
        pub expiry: ::core::option::Option<Timestamp>,
        /// If set, the new memo to be associated with the token (UTF-8 encoding max 100 bytes)
        #[prost(message, optional, tag = "13")]
        pub memo: ::core::option::Option<::prost::alloc::string::String>,
        /// If set, the new key to use to update the token's custom fee schedule; if the token does not
        /// currently have this key, transaction will resolve to TOKEN_HAS_NO_FEE_SCHEDULE_KEY
        #[prost(message, optional, tag = "14")]
        pub fee_schedule_key: ::core::option::Option<Key>,
        /// The Key which can pause and unpause the Token. If the Token does not currently have a pause key,
        /// transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY
        #[prost(message, optional, tag = "15")]
        pub pause_key: ::core::option::Option<Key>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenUpdateTransactionBody {
        #[inline]
        fn clone(&self) -> TokenUpdateTransactionBody {
            match *self {
                TokenUpdateTransactionBody {
                    token: ref __self_0_0,
                    symbol: ref __self_0_1,
                    name: ref __self_0_2,
                    treasury: ref __self_0_3,
                    admin_key: ref __self_0_4,
                    kyc_key: ref __self_0_5,
                    freeze_key: ref __self_0_6,
                    wipe_key: ref __self_0_7,
                    supply_key: ref __self_0_8,
                    auto_renew_account: ref __self_0_9,
                    auto_renew_period: ref __self_0_10,
                    expiry: ref __self_0_11,
                    memo: ref __self_0_12,
                    fee_schedule_key: ref __self_0_13,
                    pause_key: ref __self_0_14,
                } => TokenUpdateTransactionBody {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    symbol: ::core::clone::Clone::clone(&(*__self_0_1)),
                    name: ::core::clone::Clone::clone(&(*__self_0_2)),
                    treasury: ::core::clone::Clone::clone(&(*__self_0_3)),
                    admin_key: ::core::clone::Clone::clone(&(*__self_0_4)),
                    kyc_key: ::core::clone::Clone::clone(&(*__self_0_5)),
                    freeze_key: ::core::clone::Clone::clone(&(*__self_0_6)),
                    wipe_key: ::core::clone::Clone::clone(&(*__self_0_7)),
                    supply_key: ::core::clone::Clone::clone(&(*__self_0_8)),
                    auto_renew_account: ::core::clone::Clone::clone(&(*__self_0_9)),
                    auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_10)),
                    expiry: ::core::clone::Clone::clone(&(*__self_0_11)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_12)),
                    fee_schedule_key: ::core::clone::Clone::clone(&(*__self_0_13)),
                    pause_key: ::core::clone::Clone::clone(&(*__self_0_14)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenUpdateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenUpdateTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenUpdateTransactionBody) -> bool {
            match *other {
                TokenUpdateTransactionBody {
                    token: ref __self_1_0,
                    symbol: ref __self_1_1,
                    name: ref __self_1_2,
                    treasury: ref __self_1_3,
                    admin_key: ref __self_1_4,
                    kyc_key: ref __self_1_5,
                    freeze_key: ref __self_1_6,
                    wipe_key: ref __self_1_7,
                    supply_key: ref __self_1_8,
                    auto_renew_account: ref __self_1_9,
                    auto_renew_period: ref __self_1_10,
                    expiry: ref __self_1_11,
                    memo: ref __self_1_12,
                    fee_schedule_key: ref __self_1_13,
                    pause_key: ref __self_1_14,
                } => match *self {
                    TokenUpdateTransactionBody {
                        token: ref __self_0_0,
                        symbol: ref __self_0_1,
                        name: ref __self_0_2,
                        treasury: ref __self_0_3,
                        admin_key: ref __self_0_4,
                        kyc_key: ref __self_0_5,
                        freeze_key: ref __self_0_6,
                        wipe_key: ref __self_0_7,
                        supply_key: ref __self_0_8,
                        auto_renew_account: ref __self_0_9,
                        auto_renew_period: ref __self_0_10,
                        expiry: ref __self_0_11,
                        memo: ref __self_0_12,
                        fee_schedule_key: ref __self_0_13,
                        pause_key: ref __self_0_14,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                            && (*__self_0_11) == (*__self_1_11)
                            && (*__self_0_12) == (*__self_1_12)
                            && (*__self_0_13) == (*__self_1_13)
                            && (*__self_0_14) == (*__self_1_14)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenUpdateTransactionBody) -> bool {
            match *other {
                TokenUpdateTransactionBody {
                    token: ref __self_1_0,
                    symbol: ref __self_1_1,
                    name: ref __self_1_2,
                    treasury: ref __self_1_3,
                    admin_key: ref __self_1_4,
                    kyc_key: ref __self_1_5,
                    freeze_key: ref __self_1_6,
                    wipe_key: ref __self_1_7,
                    supply_key: ref __self_1_8,
                    auto_renew_account: ref __self_1_9,
                    auto_renew_period: ref __self_1_10,
                    expiry: ref __self_1_11,
                    memo: ref __self_1_12,
                    fee_schedule_key: ref __self_1_13,
                    pause_key: ref __self_1_14,
                } => match *self {
                    TokenUpdateTransactionBody {
                        token: ref __self_0_0,
                        symbol: ref __self_0_1,
                        name: ref __self_0_2,
                        treasury: ref __self_0_3,
                        admin_key: ref __self_0_4,
                        kyc_key: ref __self_0_5,
                        freeze_key: ref __self_0_6,
                        wipe_key: ref __self_0_7,
                        supply_key: ref __self_0_8,
                        auto_renew_account: ref __self_0_9,
                        auto_renew_period: ref __self_0_10,
                        expiry: ref __self_0_11,
                        memo: ref __self_0_12,
                        fee_schedule_key: ref __self_0_13,
                        pause_key: ref __self_0_14,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                            || (*__self_0_11) != (*__self_1_11)
                            || (*__self_0_12) != (*__self_1_12)
                            || (*__self_0_13) != (*__self_1_13)
                            || (*__self_0_14) != (*__self_1_14)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenUpdateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.symbol != "" {
                ::prost::encoding::string::encode(2u32, &self.symbol, buf);
            }
            if self.name != "" {
                ::prost::encoding::string::encode(3u32, &self.name, buf);
            }
            if let Some(ref msg) = self.treasury {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            if let Some(ref msg) = self.admin_key {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
            if let Some(ref msg) = self.kyc_key {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            if let Some(ref msg) = self.freeze_key {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            if let Some(ref msg) = self.wipe_key {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
            if let Some(ref msg) = self.supply_key {
                ::prost::encoding::message::encode(9u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_account {
                ::prost::encoding::message::encode(10u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_period {
                ::prost::encoding::message::encode(11u32, msg, buf);
            }
            if let Some(ref msg) = self.expiry {
                ::prost::encoding::message::encode(12u32, msg, buf);
            }
            if let Some(ref msg) = self.memo {
                ::prost::encoding::message::encode(13u32, msg, buf);
            }
            if let Some(ref msg) = self.fee_schedule_key {
                ::prost::encoding::message::encode(14u32, msg, buf);
            }
            if let Some(ref msg) = self.pause_key {
                ::prost::encoding::message::encode(15u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenUpdateTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.symbol;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "symbol");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.name;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "name");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.treasury;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "treasury");
                        error
                    })
                }
                5u32 => {
                    let mut value = &mut self.admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "admin_key");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.kyc_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "kyc_key");
                        error
                    })
                }
                7u32 => {
                    let mut value = &mut self.freeze_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "freeze_key");
                        error
                    })
                }
                8u32 => {
                    let mut value = &mut self.wipe_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "wipe_key");
                        error
                    })
                }
                9u32 => {
                    let mut value = &mut self.supply_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "supply_key");
                        error
                    })
                }
                10u32 => {
                    let mut value = &mut self.auto_renew_account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_account");
                        error
                    })
                }
                11u32 => {
                    let mut value = &mut self.auto_renew_period;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_period");
                        error
                    })
                }
                12u32 => {
                    let mut value = &mut self.expiry;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiry");
                        error
                    })
                }
                13u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "memo");
                        error
                    })
                }
                14u32 => {
                    let mut value = &mut self.fee_schedule_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "fee_schedule_key");
                        error
                    })
                }
                15u32 => {
                    let mut value = &mut self.pause_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "pause_key");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.symbol != "" {
                    ::prost::encoding::string::encoded_len(2u32, &self.symbol)
                } else {
                    0
                }
                + if self.name != "" {
                    ::prost::encoding::string::encoded_len(3u32, &self.name)
                } else {
                    0
                }
                + self
                    .treasury
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + self
                    .admin_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                + self
                    .kyc_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                + self
                    .freeze_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                + self
                    .wipe_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(8u32, msg))
                + self
                    .supply_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(9u32, msg))
                + self
                    .auto_renew_account
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(10u32, msg))
                + self
                    .auto_renew_period
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(11u32, msg))
                + self
                    .expiry
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(12u32, msg))
                + self
                    .memo
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(13u32, msg))
                + self
                    .fee_schedule_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(14u32, msg))
                + self
                    .pause_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(15u32, msg))
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
            self.symbol.clear();
            self.name.clear();
            self.treasury = ::core::option::Option::None;
            self.admin_key = ::core::option::Option::None;
            self.kyc_key = ::core::option::Option::None;
            self.freeze_key = ::core::option::Option::None;
            self.wipe_key = ::core::option::Option::None;
            self.supply_key = ::core::option::Option::None;
            self.auto_renew_account = ::core::option::Option::None;
            self.auto_renew_period = ::core::option::Option::None;
            self.expiry = ::core::option::Option::None;
            self.memo = ::core::option::Option::None;
            self.fee_schedule_key = ::core::option::Option::None;
            self.pause_key = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenUpdateTransactionBody {
        fn default() -> Self {
            TokenUpdateTransactionBody {
                token: ::core::default::Default::default(),
                symbol: ::prost::alloc::string::String::new(),
                name: ::prost::alloc::string::String::new(),
                treasury: ::core::default::Default::default(),
                admin_key: ::core::default::Default::default(),
                kyc_key: ::core::default::Default::default(),
                freeze_key: ::core::default::Default::default(),
                wipe_key: ::core::default::Default::default(),
                supply_key: ::core::default::Default::default(),
                auto_renew_account: ::core::default::Default::default(),
                auto_renew_period: ::core::default::Default::default(),
                expiry: ::core::default::Default::default(),
                memo: ::core::default::Default::default(),
                fee_schedule_key: ::core::default::Default::default(),
                pause_key: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenUpdateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenUpdateTransactionBody");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.symbol)
                };
                builder.field("symbol", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.name)
                };
                builder.field("name", &wrapper)
            };
            let builder = {
                let wrapper = &self.treasury;
                builder.field("treasury", &wrapper)
            };
            let builder = {
                let wrapper = &self.admin_key;
                builder.field("admin_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.kyc_key;
                builder.field("kyc_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.freeze_key;
                builder.field("freeze_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.wipe_key;
                builder.field("wipe_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.supply_key;
                builder.field("supply_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_account;
                builder.field("auto_renew_account", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_period;
                builder.field("auto_renew_period", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiry;
                builder.field("expiry", &wrapper)
            };
            let builder = {
                let wrapper = &self.memo;
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = &self.fee_schedule_key;
                builder.field("fee_schedule_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.pause_key;
                builder.field("pause_key", &wrapper)
            };
            builder.finish()
        }
    }
    /// Mints tokens to the Token's treasury Account. If no Supply Key is defined, the transaction will
    /// resolve to TOKEN_HAS_NO_SUPPLY_KEY.
    /// The operation increases the Total Supply of the Token. The maximum total supply a token can have
    /// is 2^63-1.
    /// The amount provided must be in the lowest denomination possible. Example:
    /// Token A has 2 decimals. In order to mint 100 tokens, one must provide amount of 10000. In order
    /// to mint 100.55 tokens, one must provide amount of 10055.
    /// If both amount and metadata list get filled, a INVALID_TRANSACTION_BODY response code will be
    /// returned.
    /// If the metadata list contains metadata which is too large, a METADATA_TOO_LONG response code will
    /// be returned.
    /// If neither the amount nor the metadata list get filled, a INVALID_TOKEN_MINT_AMOUNT response code
    /// will be returned.
    /// If the metadata list count is greater than the batch size limit global dynamic property, a
    /// BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.
    pub struct TokenMintTransactionBody {
        /// The token for which to mint tokens. If token does not exist, transaction results in
        /// INVALID_TOKEN_ID
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
        /// Applicable to tokens of type FUNGIBLE_COMMON. The amount to mint to the Treasury Account.
        /// Amount must be a positive non-zero number represented in the lowest denomination of the
        /// token. The new supply must be lower than 2^63.
        #[prost(uint64, tag = "2")]
        pub amount: u64,
        /// Applicable to tokens of type NON_FUNGIBLE_UNIQUE. A list of metadata that are being created.
        /// Maximum allowed size of each metadata is 100 bytes
        #[prost(bytes = "vec", repeated, tag = "3")]
        pub metadata: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenMintTransactionBody {
        #[inline]
        fn clone(&self) -> TokenMintTransactionBody {
            match *self {
                TokenMintTransactionBody {
                    token: ref __self_0_0,
                    amount: ref __self_0_1,
                    metadata: ref __self_0_2,
                } => TokenMintTransactionBody {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    amount: ::core::clone::Clone::clone(&(*__self_0_1)),
                    metadata: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenMintTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenMintTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenMintTransactionBody) -> bool {
            match *other {
                TokenMintTransactionBody {
                    token: ref __self_1_0,
                    amount: ref __self_1_1,
                    metadata: ref __self_1_2,
                } => match *self {
                    TokenMintTransactionBody {
                        token: ref __self_0_0,
                        amount: ref __self_0_1,
                        metadata: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenMintTransactionBody) -> bool {
            match *other {
                TokenMintTransactionBody {
                    token: ref __self_1_0,
                    amount: ref __self_1_1,
                    metadata: ref __self_1_2,
                } => match *self {
                    TokenMintTransactionBody {
                        token: ref __self_0_0,
                        amount: ref __self_0_1,
                        metadata: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenMintTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.amount != 0u64 {
                ::prost::encoding::uint64::encode(2u32, &self.amount, buf);
            }
            ::prost::encoding::bytes::encode_repeated(3u32, &self.metadata, buf);
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenMintTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.metadata;
                    ::prost::encoding::bytes::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "metadata");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.amount != 0u64 {
                    ::prost::encoding::uint64::encoded_len(2u32, &self.amount)
                } else {
                    0
                }
                + ::prost::encoding::bytes::encoded_len_repeated(3u32, &self.metadata)
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
            self.amount = 0u64;
            self.metadata.clear();
        }
    }
    impl ::core::default::Default for TokenMintTransactionBody {
        fn default() -> Self {
            TokenMintTransactionBody {
                token: ::core::default::Default::default(),
                amount: 0u64,
                metadata: ::prost::alloc::vec::Vec::new(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenMintTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenMintTransactionBody");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(
                        &'a ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
                    );
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.metadata)
                };
                builder.field("metadata", &wrapper)
            };
            builder.finish()
        }
    }
    /// Burns tokens from the Token's treasury Account. If no Supply Key is defined, the transaction will
    /// resolve to TOKEN_HAS_NO_SUPPLY_KEY.
    /// The operation decreases the Total Supply of the Token. Total supply cannot go below zero.
    /// The amount provided must be in the lowest denomination possible. Example:
    /// Token A has 2 decimals. In order to burn 100 tokens, one must provide amount of 10000. In order
    /// to burn 100.55 tokens, one must provide amount of 10055.
    /// For non fungible tokens the transaction body accepts serialNumbers list of integers as a parameter.
    ///
    /// If neither the amount nor the serialNumbers get filled, a INVALID_TOKEN_BURN_AMOUNT response code
    /// will be returned.
    /// If both amount and serialNumbers get filled, a INVALID_TRANSACTION_BODY response code will be
    /// returned.
    /// If the serialNumbers' list count is greater than the batch size limit global dynamic property, a
    /// BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.
    /// If the serialNumbers list contains a non-positive integer as a serial number, a INVALID_NFT_ID
    /// response code will be returned.
    pub struct TokenBurnTransactionBody {
        /// The token for which to burn tokens. If token does not exist, transaction results in
        /// INVALID_TOKEN_ID
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
        /// Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the Treasury Account.
        /// Amount must be a positive non-zero number, not bigger than the token balance of the treasury
        /// account (0; balance], represented in the lowest denomination.
        #[prost(uint64, tag = "2")]
        pub amount: u64,
        /// Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be burned.
        #[prost(int64, repeated, tag = "3")]
        pub serial_numbers: ::prost::alloc::vec::Vec<i64>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenBurnTransactionBody {
        #[inline]
        fn clone(&self) -> TokenBurnTransactionBody {
            match *self {
                TokenBurnTransactionBody {
                    token: ref __self_0_0,
                    amount: ref __self_0_1,
                    serial_numbers: ref __self_0_2,
                } => TokenBurnTransactionBody {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    amount: ::core::clone::Clone::clone(&(*__self_0_1)),
                    serial_numbers: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenBurnTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenBurnTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenBurnTransactionBody) -> bool {
            match *other {
                TokenBurnTransactionBody {
                    token: ref __self_1_0,
                    amount: ref __self_1_1,
                    serial_numbers: ref __self_1_2,
                } => match *self {
                    TokenBurnTransactionBody {
                        token: ref __self_0_0,
                        amount: ref __self_0_1,
                        serial_numbers: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenBurnTransactionBody) -> bool {
            match *other {
                TokenBurnTransactionBody {
                    token: ref __self_1_0,
                    amount: ref __self_1_1,
                    serial_numbers: ref __self_1_2,
                } => match *self {
                    TokenBurnTransactionBody {
                        token: ref __self_0_0,
                        amount: ref __self_0_1,
                        serial_numbers: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenBurnTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.amount != 0u64 {
                ::prost::encoding::uint64::encode(2u32, &self.amount, buf);
            }
            ::prost::encoding::int64::encode_packed(3u32, &self.serial_numbers, buf);
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenBurnTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.serial_numbers;
                    ::prost::encoding::int64::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "serial_numbers");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.amount != 0u64 {
                    ::prost::encoding::uint64::encoded_len(2u32, &self.amount)
                } else {
                    0
                }
                + ::prost::encoding::int64::encoded_len_packed(3u32, &self.serial_numbers)
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
            self.amount = 0u64;
            self.serial_numbers.clear();
        }
    }
    impl ::core::default::Default for TokenBurnTransactionBody {
        fn default() -> Self {
            TokenBurnTransactionBody {
                token: ::core::default::Default::default(),
                amount: 0u64,
                serial_numbers: ::prost::alloc::vec::Vec::new(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenBurnTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenBurnTransactionBody");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i64>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.serial_numbers)
                };
                builder.field("serial_numbers", &wrapper)
            };
            builder.finish()
        }
    }
    /// Wipes the provided amount of tokens from the specified Account. Must be signed by the Token's
    /// Wipe key.
    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
    /// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
    /// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
    /// If an Association between the provided token and account is not found, the transaction will
    /// resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
    /// If Wipe Key is not present in the Token, transaction results in TOKEN_HAS_NO_WIPE_KEY.
    /// If the provided account is the Token's Treasury Account, transaction results in
    /// CANNOT_WIPE_TOKEN_TREASURY_ACCOUNT
    /// On success, tokens are removed from the account and the total supply of the token is decreased by
    /// the wiped amount.
    ///
    /// If both amount and serialNumbers get filled, a INVALID_TRANSACTION_BODY response code will be
    /// returned.
    /// If neither the amount nor the serialNumbers get filled, a INVALID_WIPING_AMOUNT response code
    /// will be returned.
    /// If the serialNumbers list contains a non-positive integer as a serial number, a INVALID_NFT_ID
    /// response code will be returned.
    /// If the serialNumbers' list count is greater than the batch size limit global dynamic property, a
    /// BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.
    ///
    /// The amount provided is in the lowest denomination possible. Example:
    /// Token A has 2 decimals. In order to wipe 100 tokens from account, one must provide amount of
    /// 10000. In order to wipe 100.55 tokens, one must provide amount of 10055.
    pub struct TokenWipeAccountTransactionBody {
        /// The token for which the account will be wiped. If token does not exist, transaction results
        /// in INVALID_TOKEN_ID
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
        /// The account to be wiped
        #[prost(message, optional, tag = "2")]
        pub account: ::core::option::Option<AccountId>,
        /// Applicable to tokens of type FUNGIBLE_COMMON. The amount of tokens to wipe from the specified
        /// account. Amount must be a positive non-zero number in the lowest denomination possible, not
        /// bigger than the token balance of the account (0; balance]
        #[prost(uint64, tag = "3")]
        pub amount: u64,
        /// Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial numbers to be wiped.
        #[prost(int64, repeated, tag = "4")]
        pub serial_numbers: ::prost::alloc::vec::Vec<i64>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenWipeAccountTransactionBody {
        #[inline]
        fn clone(&self) -> TokenWipeAccountTransactionBody {
            match *self {
                TokenWipeAccountTransactionBody {
                    token: ref __self_0_0,
                    account: ref __self_0_1,
                    amount: ref __self_0_2,
                    serial_numbers: ref __self_0_3,
                } => TokenWipeAccountTransactionBody {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account: ::core::clone::Clone::clone(&(*__self_0_1)),
                    amount: ::core::clone::Clone::clone(&(*__self_0_2)),
                    serial_numbers: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenWipeAccountTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenWipeAccountTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenWipeAccountTransactionBody) -> bool {
            match *other {
                TokenWipeAccountTransactionBody {
                    token: ref __self_1_0,
                    account: ref __self_1_1,
                    amount: ref __self_1_2,
                    serial_numbers: ref __self_1_3,
                } => match *self {
                    TokenWipeAccountTransactionBody {
                        token: ref __self_0_0,
                        account: ref __self_0_1,
                        amount: ref __self_0_2,
                        serial_numbers: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenWipeAccountTransactionBody) -> bool {
            match *other {
                TokenWipeAccountTransactionBody {
                    token: ref __self_1_0,
                    account: ref __self_1_1,
                    amount: ref __self_1_2,
                    serial_numbers: ref __self_1_3,
                } => match *self {
                    TokenWipeAccountTransactionBody {
                        token: ref __self_0_0,
                        account: ref __self_0_1,
                        amount: ref __self_0_2,
                        serial_numbers: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenWipeAccountTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.amount != 0u64 {
                ::prost::encoding::uint64::encode(3u32, &self.amount, buf);
            }
            ::prost::encoding::int64::encode_packed(4u32, &self.serial_numbers, buf);
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenWipeAccountTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.serial_numbers;
                    ::prost::encoding::int64::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "serial_numbers");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.amount != 0u64 {
                    ::prost::encoding::uint64::encoded_len(3u32, &self.amount)
                } else {
                    0
                }
                + ::prost::encoding::int64::encoded_len_packed(4u32, &self.serial_numbers)
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
            self.account = ::core::option::Option::None;
            self.amount = 0u64;
            self.serial_numbers.clear();
        }
    }
    impl ::core::default::Default for TokenWipeAccountTransactionBody {
        fn default() -> Self {
            TokenWipeAccountTransactionBody {
                token: ::core::default::Default::default(),
                account: ::core::default::Default::default(),
                amount: 0u64,
                serial_numbers: ::prost::alloc::vec::Vec::new(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenWipeAccountTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenWipeAccountTransactionBody");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            let builder = {
                let wrapper = &self.account;
                builder.field("account", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i64>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.serial_numbers)
                };
                builder.field("serial_numbers", &wrapper)
            };
            builder.finish()
        }
    }
    /// Associates the provided account with the provided tokens. Must be signed by the provided
    /// Account's key.
    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.
    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
    /// If an association between the provided account and any of the tokens already exists, the
    /// transaction will resolve to TOKEN_ALREADY_ASSOCIATED_TO_ACCOUNT.
    /// If the provided account's associations count exceed the constraint of maximum token associations
    /// per account, the transaction will resolve to TOKENS_PER_ACCOUNT_LIMIT_EXCEEDED.
    /// On success, associations between the provided account and tokens are made and the account is
    /// ready to interact with the tokens.
    pub struct TokenAssociateTransactionBody {
        /// The account to be associated with the provided tokens
        #[prost(message, optional, tag = "1")]
        pub account: ::core::option::Option<AccountId>,
        /// The tokens to be associated with the provided account. In the case of NON_FUNGIBLE_UNIQUE
        /// Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that
        /// token type
        #[prost(message, repeated, tag = "2")]
        pub tokens: ::prost::alloc::vec::Vec<TokenId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenAssociateTransactionBody {
        #[inline]
        fn clone(&self) -> TokenAssociateTransactionBody {
            match *self {
                TokenAssociateTransactionBody {
                    account: ref __self_0_0,
                    tokens: ref __self_0_1,
                } => TokenAssociateTransactionBody {
                    account: ::core::clone::Clone::clone(&(*__self_0_0)),
                    tokens: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenAssociateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenAssociateTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenAssociateTransactionBody) -> bool {
            match *other {
                TokenAssociateTransactionBody {
                    account: ref __self_1_0,
                    tokens: ref __self_1_1,
                } => match *self {
                    TokenAssociateTransactionBody {
                        account: ref __self_0_0,
                        tokens: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenAssociateTransactionBody) -> bool {
            match *other {
                TokenAssociateTransactionBody {
                    account: ref __self_1_0,
                    tokens: ref __self_1_1,
                } => match *self {
                    TokenAssociateTransactionBody {
                        account: ref __self_0_0,
                        tokens: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenAssociateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.account {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.tokens {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenAssociateTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.tokens;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "tokens");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .account
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.tokens)
        }
        fn clear(&mut self) {
            self.account = ::core::option::Option::None;
            self.tokens.clear();
        }
    }
    impl ::core::default::Default for TokenAssociateTransactionBody {
        fn default() -> Self {
            TokenAssociateTransactionBody {
                account: ::core::default::Default::default(),
                tokens: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenAssociateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenAssociateTransactionBody");
            let builder = {
                let wrapper = &self.account;
                builder.field("account", &wrapper)
            };
            let builder = {
                let wrapper = &self.tokens;
                builder.field("tokens", &wrapper)
            };
            builder.finish()
        }
    }
    /// Dissociates the provided account with the provided tokens. Must be signed by the provided
    /// Account's key.
    /// If the provided account is not found, the transaction will resolve to INVALID_ACCOUNT_ID.
    /// If the provided account has been deleted, the transaction will resolve to ACCOUNT_DELETED.
    /// If any of the provided tokens is not found, the transaction will resolve to INVALID_TOKEN_REF.
    /// If any of the provided tokens has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
    /// If an association between the provided account and any of the tokens does not exist, the
    /// transaction will resolve to TOKEN_NOT_ASSOCIATED_TO_ACCOUNT.
    /// If a token has not been deleted and has not expired, and the user has a nonzero balance, the
    /// transaction will resolve to TRANSACTION_REQUIRES_ZERO_TOKEN_BALANCES.
    /// If a <b>fungible token</b> has expired, the user can disassociate even if their token balance is
    /// not zero.
    /// If a <b>non fungible token</b> has expired, the user can <b>not</b> disassociate if their token
    /// balance is not zero. The transaction will resolve to TRANSACTION_REQUIRED_ZERO_TOKEN_BALANCES.
    /// On success, associations between the provided account and tokens are removed.
    pub struct TokenDissociateTransactionBody {
        /// The account to be dissociated with the provided tokens
        #[prost(message, optional, tag = "1")]
        pub account: ::core::option::Option<AccountId>,
        /// The tokens to be dissociated with the provided account
        #[prost(message, repeated, tag = "2")]
        pub tokens: ::prost::alloc::vec::Vec<TokenId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenDissociateTransactionBody {
        #[inline]
        fn clone(&self) -> TokenDissociateTransactionBody {
            match *self {
                TokenDissociateTransactionBody {
                    account: ref __self_0_0,
                    tokens: ref __self_0_1,
                } => TokenDissociateTransactionBody {
                    account: ::core::clone::Clone::clone(&(*__self_0_0)),
                    tokens: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenDissociateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenDissociateTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenDissociateTransactionBody) -> bool {
            match *other {
                TokenDissociateTransactionBody {
                    account: ref __self_1_0,
                    tokens: ref __self_1_1,
                } => match *self {
                    TokenDissociateTransactionBody {
                        account: ref __self_0_0,
                        tokens: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenDissociateTransactionBody) -> bool {
            match *other {
                TokenDissociateTransactionBody {
                    account: ref __self_1_0,
                    tokens: ref __self_1_1,
                } => match *self {
                    TokenDissociateTransactionBody {
                        account: ref __self_0_0,
                        tokens: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenDissociateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.account {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.tokens {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenDissociateTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.tokens;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "tokens");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .account
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.tokens)
        }
        fn clear(&mut self) {
            self.account = ::core::option::Option::None;
            self.tokens.clear();
        }
    }
    impl ::core::default::Default for TokenDissociateTransactionBody {
        fn default() -> Self {
            TokenDissociateTransactionBody {
                account: ::core::default::Default::default(),
                tokens: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenDissociateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenDissociateTransactionBody");
            let builder = {
                let wrapper = &self.account;
                builder.field("account", &wrapper)
            };
            let builder = {
                let wrapper = &self.tokens;
                builder.field("tokens", &wrapper)
            };
            builder.finish()
        }
    }
    /// At consensus, updates a token type's fee schedule to the given list of custom fees.
    ///
    /// If the target token type has no fee_schedule_key, resolves to TOKEN_HAS_NO_FEE_SCHEDULE_KEY.
    /// Otherwise this transaction must be signed to the fee_schedule_key, or the transaction will
    /// resolve to INVALID_SIGNATURE.
    ///
    /// If the custom_fees list is empty, clears the fee schedule or resolves to
    /// CUSTOM_SCHEDULE_ALREADY_HAS_NO_FEES if the fee schedule was already empty.
    pub struct TokenFeeScheduleUpdateTransactionBody {
        /// The token whose fee schedule is to be updated
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<TokenId>,
        /// The new custom fees to be assessed during a CryptoTransfer that transfers units of this token
        #[prost(message, repeated, tag = "2")]
        pub custom_fees: ::prost::alloc::vec::Vec<CustomFee>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenFeeScheduleUpdateTransactionBody {
        #[inline]
        fn clone(&self) -> TokenFeeScheduleUpdateTransactionBody {
            match *self {
                TokenFeeScheduleUpdateTransactionBody {
                    token_id: ref __self_0_0,
                    custom_fees: ref __self_0_1,
                } => TokenFeeScheduleUpdateTransactionBody {
                    token_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    custom_fees: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenFeeScheduleUpdateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenFeeScheduleUpdateTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenFeeScheduleUpdateTransactionBody) -> bool {
            match *other {
                TokenFeeScheduleUpdateTransactionBody {
                    token_id: ref __self_1_0,
                    custom_fees: ref __self_1_1,
                } => match *self {
                    TokenFeeScheduleUpdateTransactionBody {
                        token_id: ref __self_0_0,
                        custom_fees: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenFeeScheduleUpdateTransactionBody) -> bool {
            match *other {
                TokenFeeScheduleUpdateTransactionBody {
                    token_id: ref __self_1_0,
                    custom_fees: ref __self_1_1,
                } => match *self {
                    TokenFeeScheduleUpdateTransactionBody {
                        token_id: ref __self_0_0,
                        custom_fees: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenFeeScheduleUpdateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.custom_fees {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenFeeScheduleUpdateTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.custom_fees;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "custom_fees");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.custom_fees)
        }
        fn clear(&mut self) {
            self.token_id = ::core::option::Option::None;
            self.custom_fees.clear();
        }
    }
    impl ::core::default::Default for TokenFeeScheduleUpdateTransactionBody {
        fn default() -> Self {
            TokenFeeScheduleUpdateTransactionBody {
                token_id: ::core::default::Default::default(),
                custom_fees: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenFeeScheduleUpdateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenFeeScheduleUpdateTransactionBody");
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.custom_fees;
                builder.field("custom_fees", &wrapper)
            };
            builder.finish()
        }
    }
    /// Pauses the Token from being involved in any kind of Transaction until it is unpaused.
    /// Must be signed with the Token's pause key.
    /// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
    /// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
    /// If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.
    /// Once executed the Token is marked as paused and will be not able to be a part of any transaction.
    /// The operation is idempotent - becomes a no-op if the Token is already Paused.
    pub struct TokenPauseTransactionBody {
        /// The token to be paused.
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenPauseTransactionBody {
        #[inline]
        fn clone(&self) -> TokenPauseTransactionBody {
            match *self {
                TokenPauseTransactionBody {
                    token: ref __self_0_0,
                } => TokenPauseTransactionBody {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenPauseTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenPauseTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenPauseTransactionBody) -> bool {
            match *other {
                TokenPauseTransactionBody {
                    token: ref __self_1_0,
                } => match *self {
                    TokenPauseTransactionBody {
                        token: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenPauseTransactionBody) -> bool {
            match *other {
                TokenPauseTransactionBody {
                    token: ref __self_1_0,
                } => match *self {
                    TokenPauseTransactionBody {
                        token: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for TokenPauseTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenPauseTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenPauseTransactionBody {
        fn default() -> Self {
            TokenPauseTransactionBody {
                token: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenPauseTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenPauseTransactionBody");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            builder.finish()
        }
    }
    /// Unpauses the Token. Must be signed with the Token's pause key.
    /// If the provided token is not found, the transaction will resolve to INVALID_TOKEN_ID.
    /// If the provided token has been deleted, the transaction will resolve to TOKEN_WAS_DELETED.
    /// If no Pause Key is defined, the transaction will resolve to TOKEN_HAS_NO_PAUSE_KEY.
    /// Once executed the Token is marked as Unpaused and can be used in Transactions.
    /// The operation is idempotent - becomes a no-op if the Token is already unpaused.
    pub struct TokenUnpauseTransactionBody {
        /// The token to be unpaused.
        #[prost(message, optional, tag = "1")]
        pub token: ::core::option::Option<TokenId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenUnpauseTransactionBody {
        #[inline]
        fn clone(&self) -> TokenUnpauseTransactionBody {
            match *self {
                TokenUnpauseTransactionBody {
                    token: ref __self_0_0,
                } => TokenUnpauseTransactionBody {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenUnpauseTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenUnpauseTransactionBody {
        #[inline]
        fn eq(&self, other: &TokenUnpauseTransactionBody) -> bool {
            match *other {
                TokenUnpauseTransactionBody {
                    token: ref __self_1_0,
                } => match *self {
                    TokenUnpauseTransactionBody {
                        token: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenUnpauseTransactionBody) -> bool {
            match *other {
                TokenUnpauseTransactionBody {
                    token: ref __self_1_0,
                } => match *self {
                    TokenUnpauseTransactionBody {
                        token: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for TokenUnpauseTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenUnpauseTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) {
            self.token = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenUnpauseTransactionBody {
        fn default() -> Self {
            TokenUnpauseTransactionBody {
                token: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenUnpauseTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenUnpauseTransactionBody");
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            builder.finish()
        }
    }
    /// Marks a schedule in the network's action queue as deleted. Must be signed by the admin key of the
    /// target schedule.  A deleted schedule cannot receive any additional signing keys, nor will it be
    /// executed.
    ///
    /// Other notable response codes include, <tt>INVALID_SCHEDULE_ID</tt>, <tt>SCHEDULE_PENDING_EXPIRATION</tt>,
    /// <tt>SCHEDULE_ALREADY_DELETED</tt>, <tt>SCHEDULE_ALREADY_EXECUTED</tt>, <tt>SCHEDULE_IS_IMMUTABLE</tt>.
    /// For more information please see the section of this documentation on the <tt>ResponseCode</tt>
    /// enum.
    pub struct ScheduleDeleteTransactionBody {
        /// The ID of the Scheduled Entity
        #[prost(message, optional, tag = "1")]
        pub schedule_id: ::core::option::Option<ScheduleId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ScheduleDeleteTransactionBody {
        #[inline]
        fn clone(&self) -> ScheduleDeleteTransactionBody {
            match *self {
                ScheduleDeleteTransactionBody {
                    schedule_id: ref __self_0_0,
                } => ScheduleDeleteTransactionBody {
                    schedule_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ScheduleDeleteTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ScheduleDeleteTransactionBody {
        #[inline]
        fn eq(&self, other: &ScheduleDeleteTransactionBody) -> bool {
            match *other {
                ScheduleDeleteTransactionBody {
                    schedule_id: ref __self_1_0,
                } => match *self {
                    ScheduleDeleteTransactionBody {
                        schedule_id: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ScheduleDeleteTransactionBody) -> bool {
            match *other {
                ScheduleDeleteTransactionBody {
                    schedule_id: ref __self_1_0,
                } => match *self {
                    ScheduleDeleteTransactionBody {
                        schedule_id: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for ScheduleDeleteTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.schedule_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ScheduleDeleteTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.schedule_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "schedule_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .schedule_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) {
            self.schedule_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ScheduleDeleteTransactionBody {
        fn default() -> Self {
            ScheduleDeleteTransactionBody {
                schedule_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ScheduleDeleteTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ScheduleDeleteTransactionBody");
            let builder = {
                let wrapper = &self.schedule_id;
                builder.field("schedule_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// A schedulable transaction. Note that the global/dynamic system property
    /// <tt>scheduling.whitelist</tt> controls which transaction types may be scheduled. As of Hedera
    /// Services 0.24.0 this list includes <tt>ConsensusSubmitMessage</tt>, <tt>CryptoTransfer</tt>, <tt>TokenMint</tt>, and <tt>TokenBurn</tt>
    /// functions.
    pub struct SchedulableTransactionBody {
        /// The maximum transaction fee the client is willing to pay
        #[prost(uint64, tag = "1")]
        pub transaction_fee: u64,
        /// A memo to include the execution record; the UTF-8 encoding may be up to 100 bytes and must not
        /// include the zero byte
        #[prost(string, tag = "2")]
        pub memo: ::prost::alloc::string::String,
        /// The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation.
        #[prost(
            oneof = "schedulable_transaction_body::Data",
            tags = "3, 4, 5, 6, 37, 38, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 39, 35, 36, 34"
        )]
        pub data: ::core::option::Option<schedulable_transaction_body::Data>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SchedulableTransactionBody {
        #[inline]
        fn clone(&self) -> SchedulableTransactionBody {
            match *self {
                SchedulableTransactionBody {
                    transaction_fee: ref __self_0_0,
                    memo: ref __self_0_1,
                    data: ref __self_0_2,
                } => SchedulableTransactionBody {
                    transaction_fee: ::core::clone::Clone::clone(&(*__self_0_0)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_1)),
                    data: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for SchedulableTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for SchedulableTransactionBody {
        #[inline]
        fn eq(&self, other: &SchedulableTransactionBody) -> bool {
            match *other {
                SchedulableTransactionBody {
                    transaction_fee: ref __self_1_0,
                    memo: ref __self_1_1,
                    data: ref __self_1_2,
                } => match *self {
                    SchedulableTransactionBody {
                        transaction_fee: ref __self_0_0,
                        memo: ref __self_0_1,
                        data: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &SchedulableTransactionBody) -> bool {
            match *other {
                SchedulableTransactionBody {
                    transaction_fee: ref __self_1_0,
                    memo: ref __self_1_1,
                    data: ref __self_1_2,
                } => match *self {
                    SchedulableTransactionBody {
                        transaction_fee: ref __self_0_0,
                        memo: ref __self_0_1,
                        data: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for SchedulableTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.transaction_fee != 0u64 {
                ::prost::encoding::uint64::encode(1u32, &self.transaction_fee, buf);
            }
            if self.memo != "" {
                ::prost::encoding::string::encode(2u32, &self.memo, buf);
            }
            if let Some(ref oneof) = self.data {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "SchedulableTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.transaction_fee;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "transaction_fee");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                3u32 | 4u32 | 5u32 | 6u32 | 37u32 | 38u32 | 7u32 | 8u32 | 9u32 | 10u32 | 11u32
                | 12u32 | 13u32 | 14u32 | 15u32 | 16u32 | 17u32 | 18u32 | 19u32 | 20u32 | 21u32
                | 22u32 | 23u32 | 24u32 | 25u32 | 26u32 | 27u32 | 28u32 | 29u32 | 30u32 | 31u32
                | 32u32 | 33u32 | 39u32 | 35u32 | 36u32 | 34u32 => {
                    let mut value = &mut self.data;
                    schedulable_transaction_body::Data::merge(value, tag, wire_type, buf, ctx)
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "data");
                            error
                        })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.transaction_fee != 0u64 {
                ::prost::encoding::uint64::encoded_len(1u32, &self.transaction_fee)
            } else {
                0
            } + if self.memo != "" {
                ::prost::encoding::string::encoded_len(2u32, &self.memo)
            } else {
                0
            } + self
                .data
                .as_ref()
                .map_or(0, schedulable_transaction_body::Data::encoded_len)
        }
        fn clear(&mut self) {
            self.transaction_fee = 0u64;
            self.memo.clear();
            self.data = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for SchedulableTransactionBody {
        fn default() -> Self {
            SchedulableTransactionBody {
                transaction_fee: 0u64,
                memo: ::prost::alloc::string::String::new(),
                data: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for SchedulableTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("SchedulableTransactionBody");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.transaction_fee)
                };
                builder.field("transaction_fee", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = &self.data;
                builder.field("data", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `SchedulableTransactionBody`.
    pub mod schedulable_transaction_body {
        /// The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation.
        pub enum Data {
            /// Calls a function of a contract instance
            #[prost(message, tag = "3")]
            ContractCall(super::ContractCallTransactionBody),
            /// Creates a contract instance
            #[prost(message, tag = "4")]
            ContractCreateInstance(super::ContractCreateTransactionBody),
            /// Updates a contract
            #[prost(message, tag = "5")]
            ContractUpdateInstance(super::ContractUpdateTransactionBody),
            /// Delete contract and transfer remaining balance into specified account
            #[prost(message, tag = "6")]
            ContractDeleteInstance(super::ContractDeleteTransactionBody),
            /// Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
            #[prost(message, tag = "37")]
            CryptoApproveAllowance(super::CryptoApproveAllowanceTransactionBody),
            /// Deletes one or more of the specific approved NFT serial numbers on an owner account.
            #[prost(message, tag = "38")]
            CryptoDeleteAllowance(super::CryptoDeleteAllowanceTransactionBody),
            /// Create a new cryptocurrency account
            #[prost(message, tag = "7")]
            CryptoCreateAccount(super::CryptoCreateTransactionBody),
            /// Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
            #[prost(message, tag = "8")]
            CryptoDelete(super::CryptoDeleteTransactionBody),
            /// Transfer amount between accounts
            #[prost(message, tag = "9")]
            CryptoTransfer(super::CryptoTransferTransactionBody),
            /// Modify information such as the expiration date for an account
            #[prost(message, tag = "10")]
            CryptoUpdateAccount(super::CryptoUpdateTransactionBody),
            /// Add bytes to the end of the contents of a file
            #[prost(message, tag = "11")]
            FileAppend(super::FileAppendTransactionBody),
            /// Create a new file
            #[prost(message, tag = "12")]
            FileCreate(super::FileCreateTransactionBody),
            /// Delete a file (remove contents and mark as deleted until it expires)
            #[prost(message, tag = "13")]
            FileDelete(super::FileDeleteTransactionBody),
            /// Modify information such as the expiration date for a file
            #[prost(message, tag = "14")]
            FileUpdate(super::FileUpdateTransactionBody),
            /// Hedera administrative deletion of a file or smart contract
            #[prost(message, tag = "15")]
            SystemDelete(super::SystemDeleteTransactionBody),
            /// To undelete an entity deleted by SystemDelete
            #[prost(message, tag = "16")]
            SystemUndelete(super::SystemUndeleteTransactionBody),
            /// Freeze the nodes
            #[prost(message, tag = "17")]
            Freeze(super::FreezeTransactionBody),
            /// Creates a topic
            #[prost(message, tag = "18")]
            ConsensusCreateTopic(super::ConsensusCreateTopicTransactionBody),
            /// Updates a topic
            #[prost(message, tag = "19")]
            ConsensusUpdateTopic(super::ConsensusUpdateTopicTransactionBody),
            /// Deletes a topic
            #[prost(message, tag = "20")]
            ConsensusDeleteTopic(super::ConsensusDeleteTopicTransactionBody),
            /// Submits message to a topic
            #[prost(message, tag = "21")]
            ConsensusSubmitMessage(super::ConsensusSubmitMessageTransactionBody),
            /// Creates a token instance
            #[prost(message, tag = "22")]
            TokenCreation(super::TokenCreateTransactionBody),
            /// Freezes account not to be able to transact with a token
            #[prost(message, tag = "23")]
            TokenFreeze(super::TokenFreezeAccountTransactionBody),
            /// Unfreezes account for a token
            #[prost(message, tag = "24")]
            TokenUnfreeze(super::TokenUnfreezeAccountTransactionBody),
            /// Grants KYC to an account for a token
            #[prost(message, tag = "25")]
            TokenGrantKyc(super::TokenGrantKycTransactionBody),
            /// Revokes KYC of an account for a token
            #[prost(message, tag = "26")]
            TokenRevokeKyc(super::TokenRevokeKycTransactionBody),
            /// Deletes a token instance
            #[prost(message, tag = "27")]
            TokenDeletion(super::TokenDeleteTransactionBody),
            /// Updates a token instance
            #[prost(message, tag = "28")]
            TokenUpdate(super::TokenUpdateTransactionBody),
            /// Mints new tokens to a token's treasury account
            #[prost(message, tag = "29")]
            TokenMint(super::TokenMintTransactionBody),
            /// Burns tokens from a token's treasury account
            #[prost(message, tag = "30")]
            TokenBurn(super::TokenBurnTransactionBody),
            /// Wipes amount of tokens from an account
            #[prost(message, tag = "31")]
            TokenWipe(super::TokenWipeAccountTransactionBody),
            /// Associate tokens to an account
            #[prost(message, tag = "32")]
            TokenAssociate(super::TokenAssociateTransactionBody),
            /// Dissociate tokens from an account
            #[prost(message, tag = "33")]
            TokenDissociate(super::TokenDissociateTransactionBody),
            /// Updates a token's custom fee schedule
            #[prost(message, tag = "39")]
            TokenFeeScheduleUpdate(super::TokenFeeScheduleUpdateTransactionBody),
            /// Pauses the Token
            #[prost(message, tag = "35")]
            TokenPause(super::TokenPauseTransactionBody),
            /// Unpauses the Token
            #[prost(message, tag = "36")]
            TokenUnpause(super::TokenUnpauseTransactionBody),
            /// Marks a schedule in the network's action queue as deleted, preventing it from executing
            #[prost(message, tag = "34")]
            ScheduleDelete(super::ScheduleDeleteTransactionBody),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Data {
            #[inline]
            fn clone(&self) -> Data {
                match (&*self,) {
                    (&Data::ContractCall(ref __self_0),) => {
                        Data::ContractCall(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ContractCreateInstance(ref __self_0),) => {
                        Data::ContractCreateInstance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ContractUpdateInstance(ref __self_0),) => {
                        Data::ContractUpdateInstance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ContractDeleteInstance(ref __self_0),) => {
                        Data::ContractDeleteInstance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoApproveAllowance(ref __self_0),) => {
                        Data::CryptoApproveAllowance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoDeleteAllowance(ref __self_0),) => {
                        Data::CryptoDeleteAllowance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoCreateAccount(ref __self_0),) => {
                        Data::CryptoCreateAccount(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoDelete(ref __self_0),) => {
                        Data::CryptoDelete(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoTransfer(ref __self_0),) => {
                        Data::CryptoTransfer(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoUpdateAccount(ref __self_0),) => {
                        Data::CryptoUpdateAccount(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::FileAppend(ref __self_0),) => {
                        Data::FileAppend(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::FileCreate(ref __self_0),) => {
                        Data::FileCreate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::FileDelete(ref __self_0),) => {
                        Data::FileDelete(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::FileUpdate(ref __self_0),) => {
                        Data::FileUpdate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::SystemDelete(ref __self_0),) => {
                        Data::SystemDelete(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::SystemUndelete(ref __self_0),) => {
                        Data::SystemUndelete(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::Freeze(ref __self_0),) => {
                        Data::Freeze(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ConsensusCreateTopic(ref __self_0),) => {
                        Data::ConsensusCreateTopic(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ConsensusUpdateTopic(ref __self_0),) => {
                        Data::ConsensusUpdateTopic(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ConsensusDeleteTopic(ref __self_0),) => {
                        Data::ConsensusDeleteTopic(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ConsensusSubmitMessage(ref __self_0),) => {
                        Data::ConsensusSubmitMessage(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenCreation(ref __self_0),) => {
                        Data::TokenCreation(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenFreeze(ref __self_0),) => {
                        Data::TokenFreeze(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenUnfreeze(ref __self_0),) => {
                        Data::TokenUnfreeze(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenGrantKyc(ref __self_0),) => {
                        Data::TokenGrantKyc(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenRevokeKyc(ref __self_0),) => {
                        Data::TokenRevokeKyc(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenDeletion(ref __self_0),) => {
                        Data::TokenDeletion(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenUpdate(ref __self_0),) => {
                        Data::TokenUpdate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenMint(ref __self_0),) => {
                        Data::TokenMint(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenBurn(ref __self_0),) => {
                        Data::TokenBurn(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenWipe(ref __self_0),) => {
                        Data::TokenWipe(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenAssociate(ref __self_0),) => {
                        Data::TokenAssociate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenDissociate(ref __self_0),) => {
                        Data::TokenDissociate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenFeeScheduleUpdate(ref __self_0),) => {
                        Data::TokenFeeScheduleUpdate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenPause(ref __self_0),) => {
                        Data::TokenPause(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenUnpause(ref __self_0),) => {
                        Data::TokenUnpause(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ScheduleDelete(ref __self_0),) => {
                        Data::ScheduleDelete(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Data {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Data {
            #[inline]
            fn eq(&self, other: &Data) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Data::ContractCall(ref __self_0),
                                &Data::ContractCall(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ContractCreateInstance(ref __self_0),
                                &Data::ContractCreateInstance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ContractUpdateInstance(ref __self_0),
                                &Data::ContractUpdateInstance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ContractDeleteInstance(ref __self_0),
                                &Data::ContractDeleteInstance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoApproveAllowance(ref __self_0),
                                &Data::CryptoApproveAllowance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoDeleteAllowance(ref __self_0),
                                &Data::CryptoDeleteAllowance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoCreateAccount(ref __self_0),
                                &Data::CryptoCreateAccount(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoDelete(ref __self_0),
                                &Data::CryptoDelete(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoTransfer(ref __self_0),
                                &Data::CryptoTransfer(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoUpdateAccount(ref __self_0),
                                &Data::CryptoUpdateAccount(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Data::FileAppend(ref __self_0), &Data::FileAppend(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Data::FileCreate(ref __self_0), &Data::FileCreate(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Data::FileDelete(ref __self_0), &Data::FileDelete(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Data::FileUpdate(ref __self_0), &Data::FileUpdate(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Data::SystemDelete(ref __self_0),
                                &Data::SystemDelete(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::SystemUndelete(ref __self_0),
                                &Data::SystemUndelete(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Data::Freeze(ref __self_0), &Data::Freeze(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Data::ConsensusCreateTopic(ref __self_0),
                                &Data::ConsensusCreateTopic(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ConsensusUpdateTopic(ref __self_0),
                                &Data::ConsensusUpdateTopic(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ConsensusDeleteTopic(ref __self_0),
                                &Data::ConsensusDeleteTopic(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ConsensusSubmitMessage(ref __self_0),
                                &Data::ConsensusSubmitMessage(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenCreation(ref __self_0),
                                &Data::TokenCreation(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenFreeze(ref __self_0),
                                &Data::TokenFreeze(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenUnfreeze(ref __self_0),
                                &Data::TokenUnfreeze(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenGrantKyc(ref __self_0),
                                &Data::TokenGrantKyc(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenRevokeKyc(ref __self_0),
                                &Data::TokenRevokeKyc(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenDeletion(ref __self_0),
                                &Data::TokenDeletion(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenUpdate(ref __self_0),
                                &Data::TokenUpdate(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Data::TokenMint(ref __self_0), &Data::TokenMint(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Data::TokenBurn(ref __self_0), &Data::TokenBurn(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Data::TokenWipe(ref __self_0), &Data::TokenWipe(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Data::TokenAssociate(ref __self_0),
                                &Data::TokenAssociate(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenDissociate(ref __self_0),
                                &Data::TokenDissociate(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenFeeScheduleUpdate(ref __self_0),
                                &Data::TokenFeeScheduleUpdate(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Data::TokenPause(ref __self_0), &Data::TokenPause(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Data::TokenUnpause(ref __self_0),
                                &Data::TokenUnpause(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ScheduleDelete(ref __self_0),
                                &Data::ScheduleDelete(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Data) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Data::ContractCall(ref __self_0),
                                &Data::ContractCall(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ContractCreateInstance(ref __self_0),
                                &Data::ContractCreateInstance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ContractUpdateInstance(ref __self_0),
                                &Data::ContractUpdateInstance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ContractDeleteInstance(ref __self_0),
                                &Data::ContractDeleteInstance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoApproveAllowance(ref __self_0),
                                &Data::CryptoApproveAllowance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoDeleteAllowance(ref __self_0),
                                &Data::CryptoDeleteAllowance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoCreateAccount(ref __self_0),
                                &Data::CryptoCreateAccount(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoDelete(ref __self_0),
                                &Data::CryptoDelete(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoTransfer(ref __self_0),
                                &Data::CryptoTransfer(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoUpdateAccount(ref __self_0),
                                &Data::CryptoUpdateAccount(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Data::FileAppend(ref __self_0), &Data::FileAppend(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Data::FileCreate(ref __self_0), &Data::FileCreate(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Data::FileDelete(ref __self_0), &Data::FileDelete(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Data::FileUpdate(ref __self_0), &Data::FileUpdate(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Data::SystemDelete(ref __self_0),
                                &Data::SystemDelete(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::SystemUndelete(ref __self_0),
                                &Data::SystemUndelete(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Data::Freeze(ref __self_0), &Data::Freeze(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Data::ConsensusCreateTopic(ref __self_0),
                                &Data::ConsensusCreateTopic(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ConsensusUpdateTopic(ref __self_0),
                                &Data::ConsensusUpdateTopic(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ConsensusDeleteTopic(ref __self_0),
                                &Data::ConsensusDeleteTopic(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ConsensusSubmitMessage(ref __self_0),
                                &Data::ConsensusSubmitMessage(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenCreation(ref __self_0),
                                &Data::TokenCreation(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenFreeze(ref __self_0),
                                &Data::TokenFreeze(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenUnfreeze(ref __self_0),
                                &Data::TokenUnfreeze(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenGrantKyc(ref __self_0),
                                &Data::TokenGrantKyc(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenRevokeKyc(ref __self_0),
                                &Data::TokenRevokeKyc(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenDeletion(ref __self_0),
                                &Data::TokenDeletion(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenUpdate(ref __self_0),
                                &Data::TokenUpdate(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Data::TokenMint(ref __self_0), &Data::TokenMint(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Data::TokenBurn(ref __self_0), &Data::TokenBurn(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Data::TokenWipe(ref __self_0), &Data::TokenWipe(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Data::TokenAssociate(ref __self_0),
                                &Data::TokenAssociate(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenDissociate(ref __self_0),
                                &Data::TokenDissociate(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenFeeScheduleUpdate(ref __self_0),
                                &Data::TokenFeeScheduleUpdate(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Data::TokenPause(ref __self_0), &Data::TokenPause(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Data::TokenUnpause(ref __self_0),
                                &Data::TokenUnpause(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ScheduleDelete(ref __self_0),
                                &Data::ScheduleDelete(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Data {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Data::ContractCall(ref value) => {
                        ::prost::encoding::message::encode(3u32, &*value, buf);
                    }
                    Data::ContractCreateInstance(ref value) => {
                        ::prost::encoding::message::encode(4u32, &*value, buf);
                    }
                    Data::ContractUpdateInstance(ref value) => {
                        ::prost::encoding::message::encode(5u32, &*value, buf);
                    }
                    Data::ContractDeleteInstance(ref value) => {
                        ::prost::encoding::message::encode(6u32, &*value, buf);
                    }
                    Data::CryptoApproveAllowance(ref value) => {
                        ::prost::encoding::message::encode(37u32, &*value, buf);
                    }
                    Data::CryptoDeleteAllowance(ref value) => {
                        ::prost::encoding::message::encode(38u32, &*value, buf);
                    }
                    Data::CryptoCreateAccount(ref value) => {
                        ::prost::encoding::message::encode(7u32, &*value, buf);
                    }
                    Data::CryptoDelete(ref value) => {
                        ::prost::encoding::message::encode(8u32, &*value, buf);
                    }
                    Data::CryptoTransfer(ref value) => {
                        ::prost::encoding::message::encode(9u32, &*value, buf);
                    }
                    Data::CryptoUpdateAccount(ref value) => {
                        ::prost::encoding::message::encode(10u32, &*value, buf);
                    }
                    Data::FileAppend(ref value) => {
                        ::prost::encoding::message::encode(11u32, &*value, buf);
                    }
                    Data::FileCreate(ref value) => {
                        ::prost::encoding::message::encode(12u32, &*value, buf);
                    }
                    Data::FileDelete(ref value) => {
                        ::prost::encoding::message::encode(13u32, &*value, buf);
                    }
                    Data::FileUpdate(ref value) => {
                        ::prost::encoding::message::encode(14u32, &*value, buf);
                    }
                    Data::SystemDelete(ref value) => {
                        ::prost::encoding::message::encode(15u32, &*value, buf);
                    }
                    Data::SystemUndelete(ref value) => {
                        ::prost::encoding::message::encode(16u32, &*value, buf);
                    }
                    Data::Freeze(ref value) => {
                        ::prost::encoding::message::encode(17u32, &*value, buf);
                    }
                    Data::ConsensusCreateTopic(ref value) => {
                        ::prost::encoding::message::encode(18u32, &*value, buf);
                    }
                    Data::ConsensusUpdateTopic(ref value) => {
                        ::prost::encoding::message::encode(19u32, &*value, buf);
                    }
                    Data::ConsensusDeleteTopic(ref value) => {
                        ::prost::encoding::message::encode(20u32, &*value, buf);
                    }
                    Data::ConsensusSubmitMessage(ref value) => {
                        ::prost::encoding::message::encode(21u32, &*value, buf);
                    }
                    Data::TokenCreation(ref value) => {
                        ::prost::encoding::message::encode(22u32, &*value, buf);
                    }
                    Data::TokenFreeze(ref value) => {
                        ::prost::encoding::message::encode(23u32, &*value, buf);
                    }
                    Data::TokenUnfreeze(ref value) => {
                        ::prost::encoding::message::encode(24u32, &*value, buf);
                    }
                    Data::TokenGrantKyc(ref value) => {
                        ::prost::encoding::message::encode(25u32, &*value, buf);
                    }
                    Data::TokenRevokeKyc(ref value) => {
                        ::prost::encoding::message::encode(26u32, &*value, buf);
                    }
                    Data::TokenDeletion(ref value) => {
                        ::prost::encoding::message::encode(27u32, &*value, buf);
                    }
                    Data::TokenUpdate(ref value) => {
                        ::prost::encoding::message::encode(28u32, &*value, buf);
                    }
                    Data::TokenMint(ref value) => {
                        ::prost::encoding::message::encode(29u32, &*value, buf);
                    }
                    Data::TokenBurn(ref value) => {
                        ::prost::encoding::message::encode(30u32, &*value, buf);
                    }
                    Data::TokenWipe(ref value) => {
                        ::prost::encoding::message::encode(31u32, &*value, buf);
                    }
                    Data::TokenAssociate(ref value) => {
                        ::prost::encoding::message::encode(32u32, &*value, buf);
                    }
                    Data::TokenDissociate(ref value) => {
                        ::prost::encoding::message::encode(33u32, &*value, buf);
                    }
                    Data::TokenFeeScheduleUpdate(ref value) => {
                        ::prost::encoding::message::encode(39u32, &*value, buf);
                    }
                    Data::TokenPause(ref value) => {
                        ::prost::encoding::message::encode(35u32, &*value, buf);
                    }
                    Data::TokenUnpause(ref value) => {
                        ::prost::encoding::message::encode(36u32, &*value, buf);
                    }
                    Data::ScheduleDelete(ref value) => {
                        ::prost::encoding::message::encode(34u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Data>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    3u32 => match field {
                        ::core::option::Option::Some(Data::ContractCall(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::ContractCall(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    4u32 => match field {
                        ::core::option::Option::Some(Data::ContractCreateInstance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ContractCreateInstance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    5u32 => match field {
                        ::core::option::Option::Some(Data::ContractUpdateInstance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ContractUpdateInstance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    6u32 => match field {
                        ::core::option::Option::Some(Data::ContractDeleteInstance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ContractDeleteInstance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    37u32 => match field {
                        ::core::option::Option::Some(Data::CryptoApproveAllowance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::CryptoApproveAllowance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    38u32 => match field {
                        ::core::option::Option::Some(Data::CryptoDeleteAllowance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::CryptoDeleteAllowance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    7u32 => match field {
                        ::core::option::Option::Some(Data::CryptoCreateAccount(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::CryptoCreateAccount(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    8u32 => match field {
                        ::core::option::Option::Some(Data::CryptoDelete(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::CryptoDelete(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    9u32 => match field {
                        ::core::option::Option::Some(Data::CryptoTransfer(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::CryptoTransfer(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    10u32 => match field {
                        ::core::option::Option::Some(Data::CryptoUpdateAccount(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::CryptoUpdateAccount(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    11u32 => match field {
                        ::core::option::Option::Some(Data::FileAppend(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::FileAppend(owned_value))
                                },
                            )
                        }
                    },
                    12u32 => match field {
                        ::core::option::Option::Some(Data::FileCreate(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::FileCreate(owned_value))
                                },
                            )
                        }
                    },
                    13u32 => match field {
                        ::core::option::Option::Some(Data::FileDelete(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::FileDelete(owned_value))
                                },
                            )
                        }
                    },
                    14u32 => match field {
                        ::core::option::Option::Some(Data::FileUpdate(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::FileUpdate(owned_value))
                                },
                            )
                        }
                    },
                    15u32 => match field {
                        ::core::option::Option::Some(Data::SystemDelete(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::SystemDelete(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    16u32 => match field {
                        ::core::option::Option::Some(Data::SystemUndelete(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::SystemUndelete(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    17u32 => match field {
                        ::core::option::Option::Some(Data::Freeze(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::Freeze(owned_value))
                                },
                            )
                        }
                    },
                    18u32 => match field {
                        ::core::option::Option::Some(Data::ConsensusCreateTopic(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ConsensusCreateTopic(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    19u32 => match field {
                        ::core::option::Option::Some(Data::ConsensusUpdateTopic(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ConsensusUpdateTopic(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    20u32 => match field {
                        ::core::option::Option::Some(Data::ConsensusDeleteTopic(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ConsensusDeleteTopic(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    21u32 => match field {
                        ::core::option::Option::Some(Data::ConsensusSubmitMessage(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ConsensusSubmitMessage(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    22u32 => match field {
                        ::core::option::Option::Some(Data::TokenCreation(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenCreation(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    23u32 => match field {
                        ::core::option::Option::Some(Data::TokenFreeze(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenFreeze(owned_value))
                                },
                            )
                        }
                    },
                    24u32 => match field {
                        ::core::option::Option::Some(Data::TokenUnfreeze(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenUnfreeze(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    25u32 => match field {
                        ::core::option::Option::Some(Data::TokenGrantKyc(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenGrantKyc(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    26u32 => match field {
                        ::core::option::Option::Some(Data::TokenRevokeKyc(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenRevokeKyc(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    27u32 => match field {
                        ::core::option::Option::Some(Data::TokenDeletion(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenDeletion(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    28u32 => match field {
                        ::core::option::Option::Some(Data::TokenUpdate(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenUpdate(owned_value))
                                },
                            )
                        }
                    },
                    29u32 => match field {
                        ::core::option::Option::Some(Data::TokenMint(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenMint(owned_value))
                                },
                            )
                        }
                    },
                    30u32 => match field {
                        ::core::option::Option::Some(Data::TokenBurn(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenBurn(owned_value))
                                },
                            )
                        }
                    },
                    31u32 => match field {
                        ::core::option::Option::Some(Data::TokenWipe(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenWipe(owned_value))
                                },
                            )
                        }
                    },
                    32u32 => match field {
                        ::core::option::Option::Some(Data::TokenAssociate(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenAssociate(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    33u32 => match field {
                        ::core::option::Option::Some(Data::TokenDissociate(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenDissociate(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    39u32 => match field {
                        ::core::option::Option::Some(Data::TokenFeeScheduleUpdate(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::TokenFeeScheduleUpdate(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    35u32 => match field {
                        ::core::option::Option::Some(Data::TokenPause(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenPause(owned_value))
                                },
                            )
                        }
                    },
                    36u32 => match field {
                        ::core::option::Option::Some(Data::TokenUnpause(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenUnpause(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    34u32 => match field {
                        ::core::option::Option::Some(Data::ScheduleDelete(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::ScheduleDelete(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Data tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Data::ContractCall(ref value) => {
                        ::prost::encoding::message::encoded_len(3u32, &*value)
                    }
                    Data::ContractCreateInstance(ref value) => {
                        ::prost::encoding::message::encoded_len(4u32, &*value)
                    }
                    Data::ContractUpdateInstance(ref value) => {
                        ::prost::encoding::message::encoded_len(5u32, &*value)
                    }
                    Data::ContractDeleteInstance(ref value) => {
                        ::prost::encoding::message::encoded_len(6u32, &*value)
                    }
                    Data::CryptoApproveAllowance(ref value) => {
                        ::prost::encoding::message::encoded_len(37u32, &*value)
                    }
                    Data::CryptoDeleteAllowance(ref value) => {
                        ::prost::encoding::message::encoded_len(38u32, &*value)
                    }
                    Data::CryptoCreateAccount(ref value) => {
                        ::prost::encoding::message::encoded_len(7u32, &*value)
                    }
                    Data::CryptoDelete(ref value) => {
                        ::prost::encoding::message::encoded_len(8u32, &*value)
                    }
                    Data::CryptoTransfer(ref value) => {
                        ::prost::encoding::message::encoded_len(9u32, &*value)
                    }
                    Data::CryptoUpdateAccount(ref value) => {
                        ::prost::encoding::message::encoded_len(10u32, &*value)
                    }
                    Data::FileAppend(ref value) => {
                        ::prost::encoding::message::encoded_len(11u32, &*value)
                    }
                    Data::FileCreate(ref value) => {
                        ::prost::encoding::message::encoded_len(12u32, &*value)
                    }
                    Data::FileDelete(ref value) => {
                        ::prost::encoding::message::encoded_len(13u32, &*value)
                    }
                    Data::FileUpdate(ref value) => {
                        ::prost::encoding::message::encoded_len(14u32, &*value)
                    }
                    Data::SystemDelete(ref value) => {
                        ::prost::encoding::message::encoded_len(15u32, &*value)
                    }
                    Data::SystemUndelete(ref value) => {
                        ::prost::encoding::message::encoded_len(16u32, &*value)
                    }
                    Data::Freeze(ref value) => {
                        ::prost::encoding::message::encoded_len(17u32, &*value)
                    }
                    Data::ConsensusCreateTopic(ref value) => {
                        ::prost::encoding::message::encoded_len(18u32, &*value)
                    }
                    Data::ConsensusUpdateTopic(ref value) => {
                        ::prost::encoding::message::encoded_len(19u32, &*value)
                    }
                    Data::ConsensusDeleteTopic(ref value) => {
                        ::prost::encoding::message::encoded_len(20u32, &*value)
                    }
                    Data::ConsensusSubmitMessage(ref value) => {
                        ::prost::encoding::message::encoded_len(21u32, &*value)
                    }
                    Data::TokenCreation(ref value) => {
                        ::prost::encoding::message::encoded_len(22u32, &*value)
                    }
                    Data::TokenFreeze(ref value) => {
                        ::prost::encoding::message::encoded_len(23u32, &*value)
                    }
                    Data::TokenUnfreeze(ref value) => {
                        ::prost::encoding::message::encoded_len(24u32, &*value)
                    }
                    Data::TokenGrantKyc(ref value) => {
                        ::prost::encoding::message::encoded_len(25u32, &*value)
                    }
                    Data::TokenRevokeKyc(ref value) => {
                        ::prost::encoding::message::encoded_len(26u32, &*value)
                    }
                    Data::TokenDeletion(ref value) => {
                        ::prost::encoding::message::encoded_len(27u32, &*value)
                    }
                    Data::TokenUpdate(ref value) => {
                        ::prost::encoding::message::encoded_len(28u32, &*value)
                    }
                    Data::TokenMint(ref value) => {
                        ::prost::encoding::message::encoded_len(29u32, &*value)
                    }
                    Data::TokenBurn(ref value) => {
                        ::prost::encoding::message::encoded_len(30u32, &*value)
                    }
                    Data::TokenWipe(ref value) => {
                        ::prost::encoding::message::encoded_len(31u32, &*value)
                    }
                    Data::TokenAssociate(ref value) => {
                        ::prost::encoding::message::encoded_len(32u32, &*value)
                    }
                    Data::TokenDissociate(ref value) => {
                        ::prost::encoding::message::encoded_len(33u32, &*value)
                    }
                    Data::TokenFeeScheduleUpdate(ref value) => {
                        ::prost::encoding::message::encoded_len(39u32, &*value)
                    }
                    Data::TokenPause(ref value) => {
                        ::prost::encoding::message::encoded_len(35u32, &*value)
                    }
                    Data::TokenUnpause(ref value) => {
                        ::prost::encoding::message::encoded_len(36u32, &*value)
                    }
                    Data::ScheduleDelete(ref value) => {
                        ::prost::encoding::message::encoded_len(34u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Data {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Data::ContractCall(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractCall").field(&wrapper).finish()
                    }
                    Data::ContractCreateInstance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractCreateInstance")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::ContractUpdateInstance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractUpdateInstance")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::ContractDeleteInstance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractDeleteInstance")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::CryptoApproveAllowance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoApproveAllowance")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::CryptoDeleteAllowance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoDeleteAllowance")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::CryptoCreateAccount(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoCreateAccount")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::CryptoDelete(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoDelete").field(&wrapper).finish()
                    }
                    Data::CryptoTransfer(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoTransfer").field(&wrapper).finish()
                    }
                    Data::CryptoUpdateAccount(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoUpdateAccount")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::FileAppend(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileAppend").field(&wrapper).finish()
                    }
                    Data::FileCreate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileCreate").field(&wrapper).finish()
                    }
                    Data::FileDelete(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileDelete").field(&wrapper).finish()
                    }
                    Data::FileUpdate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileUpdate").field(&wrapper).finish()
                    }
                    Data::SystemDelete(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("SystemDelete").field(&wrapper).finish()
                    }
                    Data::SystemUndelete(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("SystemUndelete").field(&wrapper).finish()
                    }
                    Data::Freeze(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("Freeze").field(&wrapper).finish()
                    }
                    Data::ConsensusCreateTopic(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ConsensusCreateTopic")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::ConsensusUpdateTopic(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ConsensusUpdateTopic")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::ConsensusDeleteTopic(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ConsensusDeleteTopic")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::ConsensusSubmitMessage(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ConsensusSubmitMessage")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::TokenCreation(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenCreation").field(&wrapper).finish()
                    }
                    Data::TokenFreeze(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenFreeze").field(&wrapper).finish()
                    }
                    Data::TokenUnfreeze(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenUnfreeze").field(&wrapper).finish()
                    }
                    Data::TokenGrantKyc(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenGrantKyc").field(&wrapper).finish()
                    }
                    Data::TokenRevokeKyc(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenRevokeKyc").field(&wrapper).finish()
                    }
                    Data::TokenDeletion(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenDeletion").field(&wrapper).finish()
                    }
                    Data::TokenUpdate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenUpdate").field(&wrapper).finish()
                    }
                    Data::TokenMint(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenMint").field(&wrapper).finish()
                    }
                    Data::TokenBurn(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenBurn").field(&wrapper).finish()
                    }
                    Data::TokenWipe(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenWipe").field(&wrapper).finish()
                    }
                    Data::TokenAssociate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenAssociate").field(&wrapper).finish()
                    }
                    Data::TokenDissociate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenDissociate").field(&wrapper).finish()
                    }
                    Data::TokenFeeScheduleUpdate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenFeeScheduleUpdate")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::TokenPause(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenPause").field(&wrapper).finish()
                    }
                    Data::TokenUnpause(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenUnpause").field(&wrapper).finish()
                    }
                    Data::ScheduleDelete(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ScheduleDelete").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// Create a new <i>schedule entity</i> (or simply, <i>schedule</i>) in the network's action queue.
    /// Upon <tt>SUCCESS</tt>, the receipt contains the `ScheduleID` of the created schedule. A schedule
    /// entity includes a <tt>scheduledTransactionBody</tt> to be executed.
    /// When the schedule has collected enough signing Ed25519 keys to satisfy the schedule's signing
    /// requirements, the schedule can be executed.
    ///
    /// If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> is set to <tt>true</tt>, then the schedule
    /// will execute at it's <tt>expiration_time</tt>.
    ///
    /// Otherwise it will execute immediately after the transaction that provided enough Ed25519 keys, a <tt>ScheduleCreate</tt>
    /// or <tt>ScheduleSign</tt>.
    ///
    /// Upon `SUCCESS`, the receipt also includes the <tt>scheduledTransactionID</tt> to
    /// use to query for the record of the scheduled transaction's execution (if it occurs).
    ///
    /// The expiration time of a schedule is controlled by it's <tt>expiration_time</tt>. It remains in state and can be queried
    /// using <tt>GetScheduleInfo</tt> until expiration, no matter if the scheduled transaction has
    /// executed or marked deleted. If Long Term Scheduled Transactions are disabled, the <tt>expiration_time</tt> is always
    /// 30 minutes in the future.
    ///
    /// If the <tt>adminKey</tt> field is omitted, the resulting schedule is immutable. If the
    /// <tt>adminKey</tt> is set, the <tt>ScheduleDelete</tt> transaction can be used to mark it as
    /// deleted. The creator may also specify an optional <tt>memo</tt> whose UTF-8 encoding is at most
    /// 100 bytes and does not include the zero byte is also supported.
    ///
    /// When a <tt>scheduledTransactionBody</tt> is executed, the
    /// network only charges its payer the service fee, and not the node and network fees. If the
    /// optional <tt>payerAccountID</tt> is set, the network charges this account. Otherwise it charges
    /// the payer of the originating <tt>ScheduleCreate</tt>.  
    ///
    /// Two <tt>ScheduleCreate</tt> transactions are <i>identical</i> if they are equal in all their
    /// fields other than <tt>payerAccountID</tt>.  (For the <tt>scheduledTransactionBody</tt> field,
    /// "equal" should be understood in the sense of
    /// gRPC object equality in the network software runtime. In particular, a gRPC object with <a
    /// href="<https://developers.google.com/protocol-buffers/docs/proto3#unknowns">unknown> fields</a> is
    /// not equal to a gRPC object without unknown fields, even if they agree on all known fields.)
    ///
    /// A <tt>ScheduleCreate</tt> transaction that attempts to re-create an identical schedule already in
    /// state will receive a receipt with status <tt>IDENTICAL_SCHEDULE_ALREADY_CREATED</tt>; the receipt
    /// will include the <tt>ScheduleID</tt> of the extant schedule, which may be used in a subsequent
    /// <tt>ScheduleSign</tt> transaction. (The receipt will also include the <tt>TransactionID</tt> to
    /// use in querying for the receipt or record of the scheduled transaction.)
    ///
    /// Other notable response codes include, <tt>INVALID_ACCOUNT_ID</tt>,
    /// <tt>UNSCHEDULABLE_TRANSACTION</tt>, <tt>UNRESOLVABLE_REQUIRED_SIGNERS</tt>,
    /// <tt>INVALID_SIGNATURE</tt>. For more information please see the section of this documentation on
    /// the <tt>ResponseCode</tt> enum.
    pub struct ScheduleCreateTransactionBody {
        /// The scheduled transaction
        #[prost(message, optional, tag = "1")]
        pub scheduled_transaction_body: ::core::option::Option<SchedulableTransactionBody>,
        /// An optional memo with a UTF-8 encoding of no more than 100 bytes which does not contain the
        /// zero byte
        #[prost(string, tag = "2")]
        pub memo: ::prost::alloc::string::String,
        /// An optional Hedera key which can be used to sign a ScheduleDelete and remove the schedule
        #[prost(message, optional, tag = "3")]
        pub admin_key: ::core::option::Option<Key>,
        /// An optional id of the account to be charged the service fee for the scheduled transaction at
        /// the consensus time that it executes (if ever); defaults to the ScheduleCreate payer if not
        /// given
        #[prost(message, optional, tag = "4")]
        pub payer_account_id: ::core::option::Option<AccountId>,
        /// An optional timestamp for specifying when the transaction should be evaluated for execution and then expire.
        /// Defaults to 30 minutes after the transaction's consensus timestamp.
        ///
        /// Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled - Transactions will always
        ///       expire in 30 minutes if Long Term Scheduled Transactions are not enabled.
        #[prost(message, optional, tag = "5")]
        pub expiration_time: ::core::option::Option<Timestamp>,
        /// When set to true, the transaction will be evaluated for execution at expiration_time instead
        /// of when all required signatures are received.
        /// When set to false, the transaction will execute immediately after sufficient signatures are received
        /// to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
        ///
        /// Defaults to false.
        ///
        /// Setting this to false does not necessarily mean that the transaction will never execute at expiration_time.
        ///  For Example - If the signature requirements for a Scheduled Transaction change via external means (e.g. CryptoUpdate)
        ///  such that the Scheduled Transaction would be allowed to execute, it will do so autonomously at expiration_time, unless a
        ///  ScheduleSign comes in to “poke” it and force it to go through immediately.
        ///
        /// Note: This field is unused and forced to be unset until Long Term Scheduled Transactions are enabled. Before Long Term
        ///       Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration  - they will _only_
        ///       execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
        ///       expire at expiration_time.
        #[prost(bool, tag = "13")]
        pub wait_for_expiry: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ScheduleCreateTransactionBody {
        #[inline]
        fn clone(&self) -> ScheduleCreateTransactionBody {
            match *self {
                ScheduleCreateTransactionBody {
                    scheduled_transaction_body: ref __self_0_0,
                    memo: ref __self_0_1,
                    admin_key: ref __self_0_2,
                    payer_account_id: ref __self_0_3,
                    expiration_time: ref __self_0_4,
                    wait_for_expiry: ref __self_0_5,
                } => ScheduleCreateTransactionBody {
                    scheduled_transaction_body: ::core::clone::Clone::clone(&(*__self_0_0)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_1)),
                    admin_key: ::core::clone::Clone::clone(&(*__self_0_2)),
                    payer_account_id: ::core::clone::Clone::clone(&(*__self_0_3)),
                    expiration_time: ::core::clone::Clone::clone(&(*__self_0_4)),
                    wait_for_expiry: ::core::clone::Clone::clone(&(*__self_0_5)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ScheduleCreateTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ScheduleCreateTransactionBody {
        #[inline]
        fn eq(&self, other: &ScheduleCreateTransactionBody) -> bool {
            match *other {
                ScheduleCreateTransactionBody {
                    scheduled_transaction_body: ref __self_1_0,
                    memo: ref __self_1_1,
                    admin_key: ref __self_1_2,
                    payer_account_id: ref __self_1_3,
                    expiration_time: ref __self_1_4,
                    wait_for_expiry: ref __self_1_5,
                } => match *self {
                    ScheduleCreateTransactionBody {
                        scheduled_transaction_body: ref __self_0_0,
                        memo: ref __self_0_1,
                        admin_key: ref __self_0_2,
                        payer_account_id: ref __self_0_3,
                        expiration_time: ref __self_0_4,
                        wait_for_expiry: ref __self_0_5,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ScheduleCreateTransactionBody) -> bool {
            match *other {
                ScheduleCreateTransactionBody {
                    scheduled_transaction_body: ref __self_1_0,
                    memo: ref __self_1_1,
                    admin_key: ref __self_1_2,
                    payer_account_id: ref __self_1_3,
                    expiration_time: ref __self_1_4,
                    wait_for_expiry: ref __self_1_5,
                } => match *self {
                    ScheduleCreateTransactionBody {
                        scheduled_transaction_body: ref __self_0_0,
                        memo: ref __self_0_1,
                        admin_key: ref __self_0_2,
                        payer_account_id: ref __self_0_3,
                        expiration_time: ref __self_0_4,
                        wait_for_expiry: ref __self_0_5,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ScheduleCreateTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.scheduled_transaction_body {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.memo != "" {
                ::prost::encoding::string::encode(2u32, &self.memo, buf);
            }
            if let Some(ref msg) = self.admin_key {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.payer_account_id {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            if let Some(ref msg) = self.expiration_time {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
            if self.wait_for_expiry != false {
                ::prost::encoding::bool::encode(13u32, &self.wait_for_expiry, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ScheduleCreateTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.scheduled_transaction_body;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "scheduled_transaction_body");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "admin_key");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.payer_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "payer_account_id");
                        error
                    })
                }
                5u32 => {
                    let mut value = &mut self.expiration_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiration_time");
                        error
                    })
                }
                13u32 => {
                    let mut value = &mut self.wait_for_expiry;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "wait_for_expiry");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .scheduled_transaction_body
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.memo != "" {
                    ::prost::encoding::string::encoded_len(2u32, &self.memo)
                } else {
                    0
                }
                + self
                    .admin_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .payer_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + self
                    .expiration_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                + if self.wait_for_expiry != false {
                    ::prost::encoding::bool::encoded_len(13u32, &self.wait_for_expiry)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.scheduled_transaction_body = ::core::option::Option::None;
            self.memo.clear();
            self.admin_key = ::core::option::Option::None;
            self.payer_account_id = ::core::option::Option::None;
            self.expiration_time = ::core::option::Option::None;
            self.wait_for_expiry = false;
        }
    }
    impl ::core::default::Default for ScheduleCreateTransactionBody {
        fn default() -> Self {
            ScheduleCreateTransactionBody {
                scheduled_transaction_body: ::core::default::Default::default(),
                memo: ::prost::alloc::string::String::new(),
                admin_key: ::core::default::Default::default(),
                payer_account_id: ::core::default::Default::default(),
                expiration_time: ::core::default::Default::default(),
                wait_for_expiry: false,
            }
        }
    }
    impl ::core::fmt::Debug for ScheduleCreateTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ScheduleCreateTransactionBody");
            let builder = {
                let wrapper = &self.scheduled_transaction_body;
                builder.field("scheduled_transaction_body", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = &self.admin_key;
                builder.field("admin_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.payer_account_id;
                builder.field("payer_account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiration_time;
                builder.field("expiration_time", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.wait_for_expiry)
                };
                builder.field("wait_for_expiry", &wrapper)
            };
            builder.finish()
        }
    }
    /// Adds zero or more signing keys to a schedule.
    ///
    /// If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> was set to <tt>true</tt> on the
    /// <tt>ScheduleCreate</tt> then the transaction will always wait till it's `expiration_time` to execute.
    ///
    /// Otherwise, if the resulting set of signing keys satisfy the
    /// scheduled transaction's signing requirements, it will be executed immediately after the
    /// triggering <tt>ScheduleSign</tt>.
    ///
    /// Upon <tt>SUCCESS</tt>, the receipt includes the <tt>scheduledTransactionID</tt> to use to query
    /// for the record of the scheduled transaction's execution (if it occurs).
    ///
    /// Other notable response codes include <tt>INVALID_SCHEDULE_ID</tt>, <tt>SCHEDULE_ALREADY_DELETED</tt>,
    /// <tt>SCHEDULE_PENDING_EXPIRATION</tt>, <tt>SCHEDULE_ALREADY_EXPIRED</tt>,
    /// <tt>INVALID_ACCOUNT_ID</tt>, <tt>UNRESOLVABLE_REQUIRED_SIGNERS</tt>,
    /// <tt>SOME_SIGNATURES_WERE_INVALID</tt>, and <tt>NO_NEW_VALID_SIGNATURES</tt>. For more information
    /// please see the section of this documentation on the <tt>ResponseCode</tt> enum.
    pub struct ScheduleSignTransactionBody {
        /// The id of the schedule to add signing keys to
        #[prost(message, optional, tag = "1")]
        pub schedule_id: ::core::option::Option<ScheduleId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ScheduleSignTransactionBody {
        #[inline]
        fn clone(&self) -> ScheduleSignTransactionBody {
            match *self {
                ScheduleSignTransactionBody {
                    schedule_id: ref __self_0_0,
                } => ScheduleSignTransactionBody {
                    schedule_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ScheduleSignTransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ScheduleSignTransactionBody {
        #[inline]
        fn eq(&self, other: &ScheduleSignTransactionBody) -> bool {
            match *other {
                ScheduleSignTransactionBody {
                    schedule_id: ref __self_1_0,
                } => match *self {
                    ScheduleSignTransactionBody {
                        schedule_id: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ScheduleSignTransactionBody) -> bool {
            match *other {
                ScheduleSignTransactionBody {
                    schedule_id: ref __self_1_0,
                } => match *self {
                    ScheduleSignTransactionBody {
                        schedule_id: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for ScheduleSignTransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.schedule_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ScheduleSignTransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.schedule_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "schedule_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .schedule_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) {
            self.schedule_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ScheduleSignTransactionBody {
        fn default() -> Self {
            ScheduleSignTransactionBody {
                schedule_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ScheduleSignTransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ScheduleSignTransactionBody");
            let builder = {
                let wrapper = &self.schedule_id;
                builder.field("schedule_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// A single transaction. All transaction types are possible here.
    pub struct TransactionBody {
        /// The ID for this transaction, which includes the payer's account (the account paying the
        /// transaction fee). If two transactions have the same transactionID, they won't both have an
        /// effect
        #[prost(message, optional, tag = "1")]
        pub transaction_id: ::core::option::Option<TransactionId>,
        /// The account of the node that submits the client's transaction to the network
        #[prost(message, optional, tag = "2")]
        pub node_account_id: ::core::option::Option<AccountId>,
        /// The maximum transaction fee the client is willing to pay
        #[prost(uint64, tag = "3")]
        pub transaction_fee: u64,
        /// The transaction is invalid if consensusTimestamp > transactionID.transactionValidStart +
        /// transactionValidDuration
        #[prost(message, optional, tag = "4")]
        pub transaction_valid_duration: ::core::option::Option<Duration>,
        /// Should a record of this transaction be generated? (A receipt is always generated, but the
        /// record is optional)
        #[deprecated]
        #[prost(bool, tag = "5")]
        pub generate_record: bool,
        /// Any notes or descriptions that should be put into the record (max length 100)
        #[prost(string, tag = "6")]
        pub memo: ::prost::alloc::string::String,
        /// The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation.
        #[prost(
            oneof = "transaction_body::Data",
            tags = "7, 8, 9, 22, 50, 10, 48, 49, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 26, 27, 28, 29, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 45, 46, 47, 42, 43, 44"
        )]
        pub data: ::core::option::Option<transaction_body::Data>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionBody {
        #[inline]
        fn clone(&self) -> TransactionBody {
            match *self {
                TransactionBody {
                    transaction_id: ref __self_0_0,
                    node_account_id: ref __self_0_1,
                    transaction_fee: ref __self_0_2,
                    transaction_valid_duration: ref __self_0_3,
                    generate_record: ref __self_0_4,
                    memo: ref __self_0_5,
                    data: ref __self_0_6,
                } => TransactionBody {
                    transaction_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    node_account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    transaction_fee: ::core::clone::Clone::clone(&(*__self_0_2)),
                    transaction_valid_duration: ::core::clone::Clone::clone(&(*__self_0_3)),
                    generate_record: ::core::clone::Clone::clone(&(*__self_0_4)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_5)),
                    data: ::core::clone::Clone::clone(&(*__self_0_6)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionBody {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionBody {
        #[inline]
        fn eq(&self, other: &TransactionBody) -> bool {
            match *other {
                TransactionBody {
                    transaction_id: ref __self_1_0,
                    node_account_id: ref __self_1_1,
                    transaction_fee: ref __self_1_2,
                    transaction_valid_duration: ref __self_1_3,
                    generate_record: ref __self_1_4,
                    memo: ref __self_1_5,
                    data: ref __self_1_6,
                } => match *self {
                    TransactionBody {
                        transaction_id: ref __self_0_0,
                        node_account_id: ref __self_0_1,
                        transaction_fee: ref __self_0_2,
                        transaction_valid_duration: ref __self_0_3,
                        generate_record: ref __self_0_4,
                        memo: ref __self_0_5,
                        data: ref __self_0_6,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionBody) -> bool {
            match *other {
                TransactionBody {
                    transaction_id: ref __self_1_0,
                    node_account_id: ref __self_1_1,
                    transaction_fee: ref __self_1_2,
                    transaction_valid_duration: ref __self_1_3,
                    generate_record: ref __self_1_4,
                    memo: ref __self_1_5,
                    data: ref __self_1_6,
                } => match *self {
                    TransactionBody {
                        transaction_id: ref __self_0_0,
                        node_account_id: ref __self_0_1,
                        transaction_fee: ref __self_0_2,
                        transaction_valid_duration: ref __self_0_3,
                        generate_record: ref __self_0_4,
                        memo: ref __self_0_5,
                        data: ref __self_0_6,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TransactionBody {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.transaction_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.node_account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.transaction_fee != 0u64 {
                ::prost::encoding::uint64::encode(3u32, &self.transaction_fee, buf);
            }
            if let Some(ref msg) = self.transaction_valid_duration {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            if self.generate_record != false {
                ::prost::encoding::bool::encode(5u32, &self.generate_record, buf);
            }
            if self.memo != "" {
                ::prost::encoding::string::encode(6u32, &self.memo, buf);
            }
            if let Some(ref oneof) = self.data {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionBody";
            match tag {
                1u32 => {
                    let mut value = &mut self.transaction_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transaction_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.node_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "node_account_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.transaction_fee;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "transaction_fee");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.transaction_valid_duration;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transaction_valid_duration");
                        error
                    })
                }
                5u32 => {
                    let mut value = &mut self.generate_record;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "generate_record");
                            error
                        },
                    )
                }
                6u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                7u32 | 8u32 | 9u32 | 22u32 | 50u32 | 10u32 | 48u32 | 49u32 | 11u32 | 12u32
                | 13u32 | 14u32 | 15u32 | 16u32 | 17u32 | 18u32 | 19u32 | 20u32 | 21u32 | 23u32
                | 24u32 | 25u32 | 26u32 | 27u32 | 28u32 | 29u32 | 31u32 | 32u32 | 33u32 | 34u32
                | 35u32 | 36u32 | 37u32 | 38u32 | 39u32 | 40u32 | 41u32 | 45u32 | 46u32 | 47u32
                | 42u32 | 43u32 | 44u32 => {
                    let mut value = &mut self.data;
                    transaction_body::Data::merge(value, tag, wire_type, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "data");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .transaction_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .node_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.transaction_fee != 0u64 {
                    ::prost::encoding::uint64::encoded_len(3u32, &self.transaction_fee)
                } else {
                    0
                }
                + self
                    .transaction_valid_duration
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + if self.generate_record != false {
                    ::prost::encoding::bool::encoded_len(5u32, &self.generate_record)
                } else {
                    0
                }
                + if self.memo != "" {
                    ::prost::encoding::string::encoded_len(6u32, &self.memo)
                } else {
                    0
                }
                + self
                    .data
                    .as_ref()
                    .map_or(0, transaction_body::Data::encoded_len)
        }
        fn clear(&mut self) {
            self.transaction_id = ::core::option::Option::None;
            self.node_account_id = ::core::option::Option::None;
            self.transaction_fee = 0u64;
            self.transaction_valid_duration = ::core::option::Option::None;
            self.generate_record = false;
            self.memo.clear();
            self.data = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TransactionBody {
        fn default() -> Self {
            TransactionBody {
                transaction_id: ::core::default::Default::default(),
                node_account_id: ::core::default::Default::default(),
                transaction_fee: 0u64,
                transaction_valid_duration: ::core::default::Default::default(),
                generate_record: false,
                memo: ::prost::alloc::string::String::new(),
                data: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TransactionBody {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionBody");
            let builder = {
                let wrapper = &self.transaction_id;
                builder.field("transaction_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.node_account_id;
                builder.field("node_account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.transaction_fee)
                };
                builder.field("transaction_fee", &wrapper)
            };
            let builder = {
                let wrapper = &self.transaction_valid_duration;
                builder.field("transaction_valid_duration", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.generate_record)
                };
                builder.field("generate_record", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = &self.data;
                builder.field("data", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `TransactionBody`.
    pub mod transaction_body {
        /// The choices here are arranged by service in roughly lexicographical order. The field ordinals are non-sequential, and a result of the historical order of implementation.
        pub enum Data {
            /// Calls a function of a contract instance
            #[prost(message, tag = "7")]
            ContractCall(super::ContractCallTransactionBody),
            /// Creates a contract instance
            #[prost(message, tag = "8")]
            ContractCreateInstance(super::ContractCreateTransactionBody),
            /// Updates a contract
            #[prost(message, tag = "9")]
            ContractUpdateInstance(super::ContractUpdateTransactionBody),
            /// Delete contract and transfer remaining balance into specified account
            #[prost(message, tag = "22")]
            ContractDeleteInstance(super::ContractDeleteTransactionBody),
            /// An Ethereum encoded transaction.
            #[prost(message, tag = "50")]
            EthereumTransaction(super::EthereumTransactionBody),
            /// Attach a new livehash to an account
            #[prost(message, tag = "10")]
            CryptoAddLiveHash(super::CryptoAddLiveHashTransactionBody),
            /// Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
            #[prost(message, tag = "48")]
            CryptoApproveAllowance(super::CryptoApproveAllowanceTransactionBody),
            /// Deletes one or more of the specific approved NFT serial numbers on an owner account.
            #[prost(message, tag = "49")]
            CryptoDeleteAllowance(super::CryptoDeleteAllowanceTransactionBody),
            /// Create a new cryptocurrency account
            #[prost(message, tag = "11")]
            CryptoCreateAccount(super::CryptoCreateTransactionBody),
            /// Delete a cryptocurrency account (mark as deleted, and transfer hbars out)
            #[prost(message, tag = "12")]
            CryptoDelete(super::CryptoDeleteTransactionBody),
            /// Remove a livehash from an account
            #[prost(message, tag = "13")]
            CryptoDeleteLiveHash(super::CryptoDeleteLiveHashTransactionBody),
            /// Transfer amount between accounts
            #[prost(message, tag = "14")]
            CryptoTransfer(super::CryptoTransferTransactionBody),
            /// Modify information such as the expiration date for an account
            #[prost(message, tag = "15")]
            CryptoUpdateAccount(super::CryptoUpdateTransactionBody),
            /// Add bytes to the end of the contents of a file
            #[prost(message, tag = "16")]
            FileAppend(super::FileAppendTransactionBody),
            /// Create a new file
            #[prost(message, tag = "17")]
            FileCreate(super::FileCreateTransactionBody),
            /// Delete a file (remove contents and mark as deleted until it expires)
            #[prost(message, tag = "18")]
            FileDelete(super::FileDeleteTransactionBody),
            /// Modify information such as the expiration date for a file
            #[prost(message, tag = "19")]
            FileUpdate(super::FileUpdateTransactionBody),
            /// Hedera administrative deletion of a file or smart contract
            #[prost(message, tag = "20")]
            SystemDelete(super::SystemDeleteTransactionBody),
            /// To undelete an entity deleted by SystemDelete
            #[prost(message, tag = "21")]
            SystemUndelete(super::SystemUndeleteTransactionBody),
            /// Freeze the nodes
            #[prost(message, tag = "23")]
            Freeze(super::FreezeTransactionBody),
            /// Creates a topic
            #[prost(message, tag = "24")]
            ConsensusCreateTopic(super::ConsensusCreateTopicTransactionBody),
            /// Updates a topic
            #[prost(message, tag = "25")]
            ConsensusUpdateTopic(super::ConsensusUpdateTopicTransactionBody),
            /// Deletes a topic
            #[prost(message, tag = "26")]
            ConsensusDeleteTopic(super::ConsensusDeleteTopicTransactionBody),
            /// Submits message to a topic
            #[prost(message, tag = "27")]
            ConsensusSubmitMessage(super::ConsensusSubmitMessageTransactionBody),
            #[prost(message, tag = "28")]
            UncheckedSubmit(super::UncheckedSubmitBody),
            /// Creates a token instance
            #[prost(message, tag = "29")]
            TokenCreation(super::TokenCreateTransactionBody),
            /// Freezes account not to be able to transact with a token
            #[prost(message, tag = "31")]
            TokenFreeze(super::TokenFreezeAccountTransactionBody),
            /// Unfreezes account for a token
            #[prost(message, tag = "32")]
            TokenUnfreeze(super::TokenUnfreezeAccountTransactionBody),
            /// Grants KYC to an account for a token
            #[prost(message, tag = "33")]
            TokenGrantKyc(super::TokenGrantKycTransactionBody),
            /// Revokes KYC of an account for a token
            #[prost(message, tag = "34")]
            TokenRevokeKyc(super::TokenRevokeKycTransactionBody),
            /// Deletes a token instance
            #[prost(message, tag = "35")]
            TokenDeletion(super::TokenDeleteTransactionBody),
            /// Updates a token instance
            #[prost(message, tag = "36")]
            TokenUpdate(super::TokenUpdateTransactionBody),
            /// Mints new tokens to a token's treasury account
            #[prost(message, tag = "37")]
            TokenMint(super::TokenMintTransactionBody),
            /// Burns tokens from a token's treasury account
            #[prost(message, tag = "38")]
            TokenBurn(super::TokenBurnTransactionBody),
            /// Wipes amount of tokens from an account
            #[prost(message, tag = "39")]
            TokenWipe(super::TokenWipeAccountTransactionBody),
            /// Associate tokens to an account
            #[prost(message, tag = "40")]
            TokenAssociate(super::TokenAssociateTransactionBody),
            /// Dissociate tokens from an account
            #[prost(message, tag = "41")]
            TokenDissociate(super::TokenDissociateTransactionBody),
            /// Updates a token's custom fee schedule
            #[prost(message, tag = "45")]
            TokenFeeScheduleUpdate(super::TokenFeeScheduleUpdateTransactionBody),
            /// Pauses the Token
            #[prost(message, tag = "46")]
            TokenPause(super::TokenPauseTransactionBody),
            /// Unpauses the Token
            #[prost(message, tag = "47")]
            TokenUnpause(super::TokenUnpauseTransactionBody),
            /// Creates a schedule in the network's action queue
            #[prost(message, tag = "42")]
            ScheduleCreate(super::ScheduleCreateTransactionBody),
            /// Deletes a schedule from the network's action queue
            #[prost(message, tag = "43")]
            ScheduleDelete(super::ScheduleDeleteTransactionBody),
            /// Adds one or more Ed25519 keys to the affirmed signers of a scheduled transaction
            #[prost(message, tag = "44")]
            ScheduleSign(super::ScheduleSignTransactionBody),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Data {
            #[inline]
            fn clone(&self) -> Data {
                match (&*self,) {
                    (&Data::ContractCall(ref __self_0),) => {
                        Data::ContractCall(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ContractCreateInstance(ref __self_0),) => {
                        Data::ContractCreateInstance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ContractUpdateInstance(ref __self_0),) => {
                        Data::ContractUpdateInstance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ContractDeleteInstance(ref __self_0),) => {
                        Data::ContractDeleteInstance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::EthereumTransaction(ref __self_0),) => {
                        Data::EthereumTransaction(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoAddLiveHash(ref __self_0),) => {
                        Data::CryptoAddLiveHash(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoApproveAllowance(ref __self_0),) => {
                        Data::CryptoApproveAllowance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoDeleteAllowance(ref __self_0),) => {
                        Data::CryptoDeleteAllowance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoCreateAccount(ref __self_0),) => {
                        Data::CryptoCreateAccount(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoDelete(ref __self_0),) => {
                        Data::CryptoDelete(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoDeleteLiveHash(ref __self_0),) => {
                        Data::CryptoDeleteLiveHash(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoTransfer(ref __self_0),) => {
                        Data::CryptoTransfer(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::CryptoUpdateAccount(ref __self_0),) => {
                        Data::CryptoUpdateAccount(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::FileAppend(ref __self_0),) => {
                        Data::FileAppend(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::FileCreate(ref __self_0),) => {
                        Data::FileCreate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::FileDelete(ref __self_0),) => {
                        Data::FileDelete(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::FileUpdate(ref __self_0),) => {
                        Data::FileUpdate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::SystemDelete(ref __self_0),) => {
                        Data::SystemDelete(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::SystemUndelete(ref __self_0),) => {
                        Data::SystemUndelete(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::Freeze(ref __self_0),) => {
                        Data::Freeze(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ConsensusCreateTopic(ref __self_0),) => {
                        Data::ConsensusCreateTopic(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ConsensusUpdateTopic(ref __self_0),) => {
                        Data::ConsensusUpdateTopic(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ConsensusDeleteTopic(ref __self_0),) => {
                        Data::ConsensusDeleteTopic(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ConsensusSubmitMessage(ref __self_0),) => {
                        Data::ConsensusSubmitMessage(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::UncheckedSubmit(ref __self_0),) => {
                        Data::UncheckedSubmit(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenCreation(ref __self_0),) => {
                        Data::TokenCreation(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenFreeze(ref __self_0),) => {
                        Data::TokenFreeze(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenUnfreeze(ref __self_0),) => {
                        Data::TokenUnfreeze(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenGrantKyc(ref __self_0),) => {
                        Data::TokenGrantKyc(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenRevokeKyc(ref __self_0),) => {
                        Data::TokenRevokeKyc(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenDeletion(ref __self_0),) => {
                        Data::TokenDeletion(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenUpdate(ref __self_0),) => {
                        Data::TokenUpdate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenMint(ref __self_0),) => {
                        Data::TokenMint(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenBurn(ref __self_0),) => {
                        Data::TokenBurn(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenWipe(ref __self_0),) => {
                        Data::TokenWipe(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenAssociate(ref __self_0),) => {
                        Data::TokenAssociate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenDissociate(ref __self_0),) => {
                        Data::TokenDissociate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenFeeScheduleUpdate(ref __self_0),) => {
                        Data::TokenFeeScheduleUpdate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenPause(ref __self_0),) => {
                        Data::TokenPause(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::TokenUnpause(ref __self_0),) => {
                        Data::TokenUnpause(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ScheduleCreate(ref __self_0),) => {
                        Data::ScheduleCreate(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ScheduleDelete(ref __self_0),) => {
                        Data::ScheduleDelete(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ScheduleSign(ref __self_0),) => {
                        Data::ScheduleSign(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Data {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Data {
            #[inline]
            fn eq(&self, other: &Data) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Data::ContractCall(ref __self_0),
                                &Data::ContractCall(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ContractCreateInstance(ref __self_0),
                                &Data::ContractCreateInstance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ContractUpdateInstance(ref __self_0),
                                &Data::ContractUpdateInstance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ContractDeleteInstance(ref __self_0),
                                &Data::ContractDeleteInstance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::EthereumTransaction(ref __self_0),
                                &Data::EthereumTransaction(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoAddLiveHash(ref __self_0),
                                &Data::CryptoAddLiveHash(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoApproveAllowance(ref __self_0),
                                &Data::CryptoApproveAllowance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoDeleteAllowance(ref __self_0),
                                &Data::CryptoDeleteAllowance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoCreateAccount(ref __self_0),
                                &Data::CryptoCreateAccount(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoDelete(ref __self_0),
                                &Data::CryptoDelete(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoDeleteLiveHash(ref __self_0),
                                &Data::CryptoDeleteLiveHash(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoTransfer(ref __self_0),
                                &Data::CryptoTransfer(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::CryptoUpdateAccount(ref __self_0),
                                &Data::CryptoUpdateAccount(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Data::FileAppend(ref __self_0), &Data::FileAppend(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Data::FileCreate(ref __self_0), &Data::FileCreate(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Data::FileDelete(ref __self_0), &Data::FileDelete(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Data::FileUpdate(ref __self_0), &Data::FileUpdate(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Data::SystemDelete(ref __self_0),
                                &Data::SystemDelete(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::SystemUndelete(ref __self_0),
                                &Data::SystemUndelete(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Data::Freeze(ref __self_0), &Data::Freeze(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Data::ConsensusCreateTopic(ref __self_0),
                                &Data::ConsensusCreateTopic(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ConsensusUpdateTopic(ref __self_0),
                                &Data::ConsensusUpdateTopic(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ConsensusDeleteTopic(ref __self_0),
                                &Data::ConsensusDeleteTopic(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ConsensusSubmitMessage(ref __self_0),
                                &Data::ConsensusSubmitMessage(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::UncheckedSubmit(ref __self_0),
                                &Data::UncheckedSubmit(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenCreation(ref __self_0),
                                &Data::TokenCreation(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenFreeze(ref __self_0),
                                &Data::TokenFreeze(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenUnfreeze(ref __self_0),
                                &Data::TokenUnfreeze(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenGrantKyc(ref __self_0),
                                &Data::TokenGrantKyc(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenRevokeKyc(ref __self_0),
                                &Data::TokenRevokeKyc(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenDeletion(ref __self_0),
                                &Data::TokenDeletion(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenUpdate(ref __self_0),
                                &Data::TokenUpdate(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Data::TokenMint(ref __self_0), &Data::TokenMint(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Data::TokenBurn(ref __self_0), &Data::TokenBurn(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Data::TokenWipe(ref __self_0), &Data::TokenWipe(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Data::TokenAssociate(ref __self_0),
                                &Data::TokenAssociate(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenDissociate(ref __self_0),
                                &Data::TokenDissociate(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::TokenFeeScheduleUpdate(ref __self_0),
                                &Data::TokenFeeScheduleUpdate(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Data::TokenPause(ref __self_0), &Data::TokenPause(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Data::TokenUnpause(ref __self_0),
                                &Data::TokenUnpause(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ScheduleCreate(ref __self_0),
                                &Data::ScheduleCreate(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ScheduleDelete(ref __self_0),
                                &Data::ScheduleDelete(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ScheduleSign(ref __self_0),
                                &Data::ScheduleSign(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Data) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Data::ContractCall(ref __self_0),
                                &Data::ContractCall(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ContractCreateInstance(ref __self_0),
                                &Data::ContractCreateInstance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ContractUpdateInstance(ref __self_0),
                                &Data::ContractUpdateInstance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ContractDeleteInstance(ref __self_0),
                                &Data::ContractDeleteInstance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::EthereumTransaction(ref __self_0),
                                &Data::EthereumTransaction(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoAddLiveHash(ref __self_0),
                                &Data::CryptoAddLiveHash(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoApproveAllowance(ref __self_0),
                                &Data::CryptoApproveAllowance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoDeleteAllowance(ref __self_0),
                                &Data::CryptoDeleteAllowance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoCreateAccount(ref __self_0),
                                &Data::CryptoCreateAccount(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoDelete(ref __self_0),
                                &Data::CryptoDelete(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoDeleteLiveHash(ref __self_0),
                                &Data::CryptoDeleteLiveHash(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoTransfer(ref __self_0),
                                &Data::CryptoTransfer(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::CryptoUpdateAccount(ref __self_0),
                                &Data::CryptoUpdateAccount(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Data::FileAppend(ref __self_0), &Data::FileAppend(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Data::FileCreate(ref __self_0), &Data::FileCreate(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Data::FileDelete(ref __self_0), &Data::FileDelete(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Data::FileUpdate(ref __self_0), &Data::FileUpdate(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Data::SystemDelete(ref __self_0),
                                &Data::SystemDelete(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::SystemUndelete(ref __self_0),
                                &Data::SystemUndelete(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Data::Freeze(ref __self_0), &Data::Freeze(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Data::ConsensusCreateTopic(ref __self_0),
                                &Data::ConsensusCreateTopic(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ConsensusUpdateTopic(ref __self_0),
                                &Data::ConsensusUpdateTopic(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ConsensusDeleteTopic(ref __self_0),
                                &Data::ConsensusDeleteTopic(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ConsensusSubmitMessage(ref __self_0),
                                &Data::ConsensusSubmitMessage(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::UncheckedSubmit(ref __self_0),
                                &Data::UncheckedSubmit(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenCreation(ref __self_0),
                                &Data::TokenCreation(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenFreeze(ref __self_0),
                                &Data::TokenFreeze(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenUnfreeze(ref __self_0),
                                &Data::TokenUnfreeze(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenGrantKyc(ref __self_0),
                                &Data::TokenGrantKyc(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenRevokeKyc(ref __self_0),
                                &Data::TokenRevokeKyc(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenDeletion(ref __self_0),
                                &Data::TokenDeletion(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenUpdate(ref __self_0),
                                &Data::TokenUpdate(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Data::TokenMint(ref __self_0), &Data::TokenMint(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Data::TokenBurn(ref __self_0), &Data::TokenBurn(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Data::TokenWipe(ref __self_0), &Data::TokenWipe(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Data::TokenAssociate(ref __self_0),
                                &Data::TokenAssociate(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenDissociate(ref __self_0),
                                &Data::TokenDissociate(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::TokenFeeScheduleUpdate(ref __self_0),
                                &Data::TokenFeeScheduleUpdate(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Data::TokenPause(ref __self_0), &Data::TokenPause(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Data::TokenUnpause(ref __self_0),
                                &Data::TokenUnpause(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ScheduleCreate(ref __self_0),
                                &Data::ScheduleCreate(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ScheduleDelete(ref __self_0),
                                &Data::ScheduleDelete(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ScheduleSign(ref __self_0),
                                &Data::ScheduleSign(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Data {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Data::ContractCall(ref value) => {
                        ::prost::encoding::message::encode(7u32, &*value, buf);
                    }
                    Data::ContractCreateInstance(ref value) => {
                        ::prost::encoding::message::encode(8u32, &*value, buf);
                    }
                    Data::ContractUpdateInstance(ref value) => {
                        ::prost::encoding::message::encode(9u32, &*value, buf);
                    }
                    Data::ContractDeleteInstance(ref value) => {
                        ::prost::encoding::message::encode(22u32, &*value, buf);
                    }
                    Data::EthereumTransaction(ref value) => {
                        ::prost::encoding::message::encode(50u32, &*value, buf);
                    }
                    Data::CryptoAddLiveHash(ref value) => {
                        ::prost::encoding::message::encode(10u32, &*value, buf);
                    }
                    Data::CryptoApproveAllowance(ref value) => {
                        ::prost::encoding::message::encode(48u32, &*value, buf);
                    }
                    Data::CryptoDeleteAllowance(ref value) => {
                        ::prost::encoding::message::encode(49u32, &*value, buf);
                    }
                    Data::CryptoCreateAccount(ref value) => {
                        ::prost::encoding::message::encode(11u32, &*value, buf);
                    }
                    Data::CryptoDelete(ref value) => {
                        ::prost::encoding::message::encode(12u32, &*value, buf);
                    }
                    Data::CryptoDeleteLiveHash(ref value) => {
                        ::prost::encoding::message::encode(13u32, &*value, buf);
                    }
                    Data::CryptoTransfer(ref value) => {
                        ::prost::encoding::message::encode(14u32, &*value, buf);
                    }
                    Data::CryptoUpdateAccount(ref value) => {
                        ::prost::encoding::message::encode(15u32, &*value, buf);
                    }
                    Data::FileAppend(ref value) => {
                        ::prost::encoding::message::encode(16u32, &*value, buf);
                    }
                    Data::FileCreate(ref value) => {
                        ::prost::encoding::message::encode(17u32, &*value, buf);
                    }
                    Data::FileDelete(ref value) => {
                        ::prost::encoding::message::encode(18u32, &*value, buf);
                    }
                    Data::FileUpdate(ref value) => {
                        ::prost::encoding::message::encode(19u32, &*value, buf);
                    }
                    Data::SystemDelete(ref value) => {
                        ::prost::encoding::message::encode(20u32, &*value, buf);
                    }
                    Data::SystemUndelete(ref value) => {
                        ::prost::encoding::message::encode(21u32, &*value, buf);
                    }
                    Data::Freeze(ref value) => {
                        ::prost::encoding::message::encode(23u32, &*value, buf);
                    }
                    Data::ConsensusCreateTopic(ref value) => {
                        ::prost::encoding::message::encode(24u32, &*value, buf);
                    }
                    Data::ConsensusUpdateTopic(ref value) => {
                        ::prost::encoding::message::encode(25u32, &*value, buf);
                    }
                    Data::ConsensusDeleteTopic(ref value) => {
                        ::prost::encoding::message::encode(26u32, &*value, buf);
                    }
                    Data::ConsensusSubmitMessage(ref value) => {
                        ::prost::encoding::message::encode(27u32, &*value, buf);
                    }
                    Data::UncheckedSubmit(ref value) => {
                        ::prost::encoding::message::encode(28u32, &*value, buf);
                    }
                    Data::TokenCreation(ref value) => {
                        ::prost::encoding::message::encode(29u32, &*value, buf);
                    }
                    Data::TokenFreeze(ref value) => {
                        ::prost::encoding::message::encode(31u32, &*value, buf);
                    }
                    Data::TokenUnfreeze(ref value) => {
                        ::prost::encoding::message::encode(32u32, &*value, buf);
                    }
                    Data::TokenGrantKyc(ref value) => {
                        ::prost::encoding::message::encode(33u32, &*value, buf);
                    }
                    Data::TokenRevokeKyc(ref value) => {
                        ::prost::encoding::message::encode(34u32, &*value, buf);
                    }
                    Data::TokenDeletion(ref value) => {
                        ::prost::encoding::message::encode(35u32, &*value, buf);
                    }
                    Data::TokenUpdate(ref value) => {
                        ::prost::encoding::message::encode(36u32, &*value, buf);
                    }
                    Data::TokenMint(ref value) => {
                        ::prost::encoding::message::encode(37u32, &*value, buf);
                    }
                    Data::TokenBurn(ref value) => {
                        ::prost::encoding::message::encode(38u32, &*value, buf);
                    }
                    Data::TokenWipe(ref value) => {
                        ::prost::encoding::message::encode(39u32, &*value, buf);
                    }
                    Data::TokenAssociate(ref value) => {
                        ::prost::encoding::message::encode(40u32, &*value, buf);
                    }
                    Data::TokenDissociate(ref value) => {
                        ::prost::encoding::message::encode(41u32, &*value, buf);
                    }
                    Data::TokenFeeScheduleUpdate(ref value) => {
                        ::prost::encoding::message::encode(45u32, &*value, buf);
                    }
                    Data::TokenPause(ref value) => {
                        ::prost::encoding::message::encode(46u32, &*value, buf);
                    }
                    Data::TokenUnpause(ref value) => {
                        ::prost::encoding::message::encode(47u32, &*value, buf);
                    }
                    Data::ScheduleCreate(ref value) => {
                        ::prost::encoding::message::encode(42u32, &*value, buf);
                    }
                    Data::ScheduleDelete(ref value) => {
                        ::prost::encoding::message::encode(43u32, &*value, buf);
                    }
                    Data::ScheduleSign(ref value) => {
                        ::prost::encoding::message::encode(44u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Data>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    7u32 => match field {
                        ::core::option::Option::Some(Data::ContractCall(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::ContractCall(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    8u32 => match field {
                        ::core::option::Option::Some(Data::ContractCreateInstance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ContractCreateInstance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    9u32 => match field {
                        ::core::option::Option::Some(Data::ContractUpdateInstance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ContractUpdateInstance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    22u32 => match field {
                        ::core::option::Option::Some(Data::ContractDeleteInstance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ContractDeleteInstance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    50u32 => match field {
                        ::core::option::Option::Some(Data::EthereumTransaction(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::EthereumTransaction(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    10u32 => match field {
                        ::core::option::Option::Some(Data::CryptoAddLiveHash(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::CryptoAddLiveHash(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    48u32 => match field {
                        ::core::option::Option::Some(Data::CryptoApproveAllowance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::CryptoApproveAllowance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    49u32 => match field {
                        ::core::option::Option::Some(Data::CryptoDeleteAllowance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::CryptoDeleteAllowance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    11u32 => match field {
                        ::core::option::Option::Some(Data::CryptoCreateAccount(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::CryptoCreateAccount(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    12u32 => match field {
                        ::core::option::Option::Some(Data::CryptoDelete(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::CryptoDelete(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    13u32 => match field {
                        ::core::option::Option::Some(Data::CryptoDeleteLiveHash(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::CryptoDeleteLiveHash(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    14u32 => match field {
                        ::core::option::Option::Some(Data::CryptoTransfer(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::CryptoTransfer(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    15u32 => match field {
                        ::core::option::Option::Some(Data::CryptoUpdateAccount(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::CryptoUpdateAccount(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    16u32 => match field {
                        ::core::option::Option::Some(Data::FileAppend(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::FileAppend(owned_value))
                                },
                            )
                        }
                    },
                    17u32 => match field {
                        ::core::option::Option::Some(Data::FileCreate(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::FileCreate(owned_value))
                                },
                            )
                        }
                    },
                    18u32 => match field {
                        ::core::option::Option::Some(Data::FileDelete(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::FileDelete(owned_value))
                                },
                            )
                        }
                    },
                    19u32 => match field {
                        ::core::option::Option::Some(Data::FileUpdate(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::FileUpdate(owned_value))
                                },
                            )
                        }
                    },
                    20u32 => match field {
                        ::core::option::Option::Some(Data::SystemDelete(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::SystemDelete(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    21u32 => match field {
                        ::core::option::Option::Some(Data::SystemUndelete(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::SystemUndelete(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    23u32 => match field {
                        ::core::option::Option::Some(Data::Freeze(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::Freeze(owned_value))
                                },
                            )
                        }
                    },
                    24u32 => match field {
                        ::core::option::Option::Some(Data::ConsensusCreateTopic(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ConsensusCreateTopic(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    25u32 => match field {
                        ::core::option::Option::Some(Data::ConsensusUpdateTopic(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ConsensusUpdateTopic(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    26u32 => match field {
                        ::core::option::Option::Some(Data::ConsensusDeleteTopic(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ConsensusDeleteTopic(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    27u32 => match field {
                        ::core::option::Option::Some(Data::ConsensusSubmitMessage(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::ConsensusSubmitMessage(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    28u32 => match field {
                        ::core::option::Option::Some(Data::UncheckedSubmit(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::UncheckedSubmit(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    29u32 => match field {
                        ::core::option::Option::Some(Data::TokenCreation(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenCreation(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    31u32 => match field {
                        ::core::option::Option::Some(Data::TokenFreeze(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenFreeze(owned_value))
                                },
                            )
                        }
                    },
                    32u32 => match field {
                        ::core::option::Option::Some(Data::TokenUnfreeze(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenUnfreeze(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    33u32 => match field {
                        ::core::option::Option::Some(Data::TokenGrantKyc(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenGrantKyc(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    34u32 => match field {
                        ::core::option::Option::Some(Data::TokenRevokeKyc(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenRevokeKyc(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    35u32 => match field {
                        ::core::option::Option::Some(Data::TokenDeletion(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenDeletion(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    36u32 => match field {
                        ::core::option::Option::Some(Data::TokenUpdate(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenUpdate(owned_value))
                                },
                            )
                        }
                    },
                    37u32 => match field {
                        ::core::option::Option::Some(Data::TokenMint(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenMint(owned_value))
                                },
                            )
                        }
                    },
                    38u32 => match field {
                        ::core::option::Option::Some(Data::TokenBurn(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenBurn(owned_value))
                                },
                            )
                        }
                    },
                    39u32 => match field {
                        ::core::option::Option::Some(Data::TokenWipe(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenWipe(owned_value))
                                },
                            )
                        }
                    },
                    40u32 => match field {
                        ::core::option::Option::Some(Data::TokenAssociate(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenAssociate(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    41u32 => match field {
                        ::core::option::Option::Some(Data::TokenDissociate(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenDissociate(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    45u32 => match field {
                        ::core::option::Option::Some(Data::TokenFeeScheduleUpdate(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Data::TokenFeeScheduleUpdate(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    46u32 => match field {
                        ::core::option::Option::Some(Data::TokenPause(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Data::TokenPause(owned_value))
                                },
                            )
                        }
                    },
                    47u32 => match field {
                        ::core::option::Option::Some(Data::TokenUnpause(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::TokenUnpause(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    42u32 => match field {
                        ::core::option::Option::Some(Data::ScheduleCreate(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::ScheduleCreate(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    43u32 => match field {
                        ::core::option::Option::Some(Data::ScheduleDelete(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::ScheduleDelete(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    44u32 => match field {
                        ::core::option::Option::Some(Data::ScheduleSign(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::ScheduleSign(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Data tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Data::ContractCall(ref value) => {
                        ::prost::encoding::message::encoded_len(7u32, &*value)
                    }
                    Data::ContractCreateInstance(ref value) => {
                        ::prost::encoding::message::encoded_len(8u32, &*value)
                    }
                    Data::ContractUpdateInstance(ref value) => {
                        ::prost::encoding::message::encoded_len(9u32, &*value)
                    }
                    Data::ContractDeleteInstance(ref value) => {
                        ::prost::encoding::message::encoded_len(22u32, &*value)
                    }
                    Data::EthereumTransaction(ref value) => {
                        ::prost::encoding::message::encoded_len(50u32, &*value)
                    }
                    Data::CryptoAddLiveHash(ref value) => {
                        ::prost::encoding::message::encoded_len(10u32, &*value)
                    }
                    Data::CryptoApproveAllowance(ref value) => {
                        ::prost::encoding::message::encoded_len(48u32, &*value)
                    }
                    Data::CryptoDeleteAllowance(ref value) => {
                        ::prost::encoding::message::encoded_len(49u32, &*value)
                    }
                    Data::CryptoCreateAccount(ref value) => {
                        ::prost::encoding::message::encoded_len(11u32, &*value)
                    }
                    Data::CryptoDelete(ref value) => {
                        ::prost::encoding::message::encoded_len(12u32, &*value)
                    }
                    Data::CryptoDeleteLiveHash(ref value) => {
                        ::prost::encoding::message::encoded_len(13u32, &*value)
                    }
                    Data::CryptoTransfer(ref value) => {
                        ::prost::encoding::message::encoded_len(14u32, &*value)
                    }
                    Data::CryptoUpdateAccount(ref value) => {
                        ::prost::encoding::message::encoded_len(15u32, &*value)
                    }
                    Data::FileAppend(ref value) => {
                        ::prost::encoding::message::encoded_len(16u32, &*value)
                    }
                    Data::FileCreate(ref value) => {
                        ::prost::encoding::message::encoded_len(17u32, &*value)
                    }
                    Data::FileDelete(ref value) => {
                        ::prost::encoding::message::encoded_len(18u32, &*value)
                    }
                    Data::FileUpdate(ref value) => {
                        ::prost::encoding::message::encoded_len(19u32, &*value)
                    }
                    Data::SystemDelete(ref value) => {
                        ::prost::encoding::message::encoded_len(20u32, &*value)
                    }
                    Data::SystemUndelete(ref value) => {
                        ::prost::encoding::message::encoded_len(21u32, &*value)
                    }
                    Data::Freeze(ref value) => {
                        ::prost::encoding::message::encoded_len(23u32, &*value)
                    }
                    Data::ConsensusCreateTopic(ref value) => {
                        ::prost::encoding::message::encoded_len(24u32, &*value)
                    }
                    Data::ConsensusUpdateTopic(ref value) => {
                        ::prost::encoding::message::encoded_len(25u32, &*value)
                    }
                    Data::ConsensusDeleteTopic(ref value) => {
                        ::prost::encoding::message::encoded_len(26u32, &*value)
                    }
                    Data::ConsensusSubmitMessage(ref value) => {
                        ::prost::encoding::message::encoded_len(27u32, &*value)
                    }
                    Data::UncheckedSubmit(ref value) => {
                        ::prost::encoding::message::encoded_len(28u32, &*value)
                    }
                    Data::TokenCreation(ref value) => {
                        ::prost::encoding::message::encoded_len(29u32, &*value)
                    }
                    Data::TokenFreeze(ref value) => {
                        ::prost::encoding::message::encoded_len(31u32, &*value)
                    }
                    Data::TokenUnfreeze(ref value) => {
                        ::prost::encoding::message::encoded_len(32u32, &*value)
                    }
                    Data::TokenGrantKyc(ref value) => {
                        ::prost::encoding::message::encoded_len(33u32, &*value)
                    }
                    Data::TokenRevokeKyc(ref value) => {
                        ::prost::encoding::message::encoded_len(34u32, &*value)
                    }
                    Data::TokenDeletion(ref value) => {
                        ::prost::encoding::message::encoded_len(35u32, &*value)
                    }
                    Data::TokenUpdate(ref value) => {
                        ::prost::encoding::message::encoded_len(36u32, &*value)
                    }
                    Data::TokenMint(ref value) => {
                        ::prost::encoding::message::encoded_len(37u32, &*value)
                    }
                    Data::TokenBurn(ref value) => {
                        ::prost::encoding::message::encoded_len(38u32, &*value)
                    }
                    Data::TokenWipe(ref value) => {
                        ::prost::encoding::message::encoded_len(39u32, &*value)
                    }
                    Data::TokenAssociate(ref value) => {
                        ::prost::encoding::message::encoded_len(40u32, &*value)
                    }
                    Data::TokenDissociate(ref value) => {
                        ::prost::encoding::message::encoded_len(41u32, &*value)
                    }
                    Data::TokenFeeScheduleUpdate(ref value) => {
                        ::prost::encoding::message::encoded_len(45u32, &*value)
                    }
                    Data::TokenPause(ref value) => {
                        ::prost::encoding::message::encoded_len(46u32, &*value)
                    }
                    Data::TokenUnpause(ref value) => {
                        ::prost::encoding::message::encoded_len(47u32, &*value)
                    }
                    Data::ScheduleCreate(ref value) => {
                        ::prost::encoding::message::encoded_len(42u32, &*value)
                    }
                    Data::ScheduleDelete(ref value) => {
                        ::prost::encoding::message::encoded_len(43u32, &*value)
                    }
                    Data::ScheduleSign(ref value) => {
                        ::prost::encoding::message::encoded_len(44u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Data {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Data::ContractCall(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractCall").field(&wrapper).finish()
                    }
                    Data::ContractCreateInstance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractCreateInstance")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::ContractUpdateInstance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractUpdateInstance")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::ContractDeleteInstance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractDeleteInstance")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::EthereumTransaction(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("EthereumTransaction")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::CryptoAddLiveHash(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoAddLiveHash").field(&wrapper).finish()
                    }
                    Data::CryptoApproveAllowance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoApproveAllowance")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::CryptoDeleteAllowance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoDeleteAllowance")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::CryptoCreateAccount(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoCreateAccount")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::CryptoDelete(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoDelete").field(&wrapper).finish()
                    }
                    Data::CryptoDeleteLiveHash(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoDeleteLiveHash")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::CryptoTransfer(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoTransfer").field(&wrapper).finish()
                    }
                    Data::CryptoUpdateAccount(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoUpdateAccount")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::FileAppend(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileAppend").field(&wrapper).finish()
                    }
                    Data::FileCreate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileCreate").field(&wrapper).finish()
                    }
                    Data::FileDelete(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileDelete").field(&wrapper).finish()
                    }
                    Data::FileUpdate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileUpdate").field(&wrapper).finish()
                    }
                    Data::SystemDelete(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("SystemDelete").field(&wrapper).finish()
                    }
                    Data::SystemUndelete(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("SystemUndelete").field(&wrapper).finish()
                    }
                    Data::Freeze(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("Freeze").field(&wrapper).finish()
                    }
                    Data::ConsensusCreateTopic(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ConsensusCreateTopic")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::ConsensusUpdateTopic(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ConsensusUpdateTopic")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::ConsensusDeleteTopic(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ConsensusDeleteTopic")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::ConsensusSubmitMessage(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ConsensusSubmitMessage")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::UncheckedSubmit(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("UncheckedSubmit").field(&wrapper).finish()
                    }
                    Data::TokenCreation(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenCreation").field(&wrapper).finish()
                    }
                    Data::TokenFreeze(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenFreeze").field(&wrapper).finish()
                    }
                    Data::TokenUnfreeze(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenUnfreeze").field(&wrapper).finish()
                    }
                    Data::TokenGrantKyc(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenGrantKyc").field(&wrapper).finish()
                    }
                    Data::TokenRevokeKyc(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenRevokeKyc").field(&wrapper).finish()
                    }
                    Data::TokenDeletion(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenDeletion").field(&wrapper).finish()
                    }
                    Data::TokenUpdate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenUpdate").field(&wrapper).finish()
                    }
                    Data::TokenMint(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenMint").field(&wrapper).finish()
                    }
                    Data::TokenBurn(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenBurn").field(&wrapper).finish()
                    }
                    Data::TokenWipe(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenWipe").field(&wrapper).finish()
                    }
                    Data::TokenAssociate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenAssociate").field(&wrapper).finish()
                    }
                    Data::TokenDissociate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenDissociate").field(&wrapper).finish()
                    }
                    Data::TokenFeeScheduleUpdate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenFeeScheduleUpdate")
                            .field(&wrapper)
                            .finish()
                    }
                    Data::TokenPause(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenPause").field(&wrapper).finish()
                    }
                    Data::TokenUnpause(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenUnpause").field(&wrapper).finish()
                    }
                    Data::ScheduleCreate(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ScheduleCreate").field(&wrapper).finish()
                    }
                    Data::ScheduleDelete(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ScheduleDelete").field(&wrapper).finish()
                    }
                    Data::ScheduleSign(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ScheduleSign").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// A single signed transaction, including all its signatures. The SignatureList will have a
    /// Signature for each Key in the transaction, either explicit or implicit, in the order that they
    /// appear in the transaction. For example, a CryptoTransfer will first have a Signature
    /// corresponding to the Key for the paying account, followed by a Signature corresponding to the Key
    /// for each account that is sending or receiving cryptocurrency in the transfer. Each Transaction
    /// should not have more than 50 levels.
    /// The SignatureList field is deprecated and succeeded by SignatureMap.
    pub struct Transaction {
        /// the body of the transaction, which needs to be signed
        #[deprecated]
        #[prost(message, optional, tag = "1")]
        pub body: ::core::option::Option<TransactionBody>,
        /// The signatures on the body, to authorize the transaction; deprecated and to be succeeded by
        /// SignatureMap field
        #[deprecated]
        #[prost(message, optional, tag = "2")]
        pub sigs: ::core::option::Option<SignatureList>,
        /// The signatures on the body with the new format, to authorize the transaction
        #[deprecated]
        #[prost(message, optional, tag = "3")]
        pub sig_map: ::core::option::Option<SignatureMap>,
        /// TransactionBody serialized into bytes, which needs to be signed
        #[deprecated]
        #[prost(bytes = "vec", tag = "4")]
        pub body_bytes: ::prost::alloc::vec::Vec<u8>,
        /// SignedTransaction serialized into bytes
        #[prost(bytes = "vec", tag = "5")]
        pub signed_transaction_bytes: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Transaction {
        #[inline]
        fn clone(&self) -> Transaction {
            match *self {
                Transaction {
                    body: ref __self_0_0,
                    sigs: ref __self_0_1,
                    sig_map: ref __self_0_2,
                    body_bytes: ref __self_0_3,
                    signed_transaction_bytes: ref __self_0_4,
                } => Transaction {
                    body: ::core::clone::Clone::clone(&(*__self_0_0)),
                    sigs: ::core::clone::Clone::clone(&(*__self_0_1)),
                    sig_map: ::core::clone::Clone::clone(&(*__self_0_2)),
                    body_bytes: ::core::clone::Clone::clone(&(*__self_0_3)),
                    signed_transaction_bytes: ::core::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Transaction {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Transaction {
        #[inline]
        fn eq(&self, other: &Transaction) -> bool {
            match *other {
                Transaction {
                    body: ref __self_1_0,
                    sigs: ref __self_1_1,
                    sig_map: ref __self_1_2,
                    body_bytes: ref __self_1_3,
                    signed_transaction_bytes: ref __self_1_4,
                } => match *self {
                    Transaction {
                        body: ref __self_0_0,
                        sigs: ref __self_0_1,
                        sig_map: ref __self_0_2,
                        body_bytes: ref __self_0_3,
                        signed_transaction_bytes: ref __self_0_4,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Transaction) -> bool {
            match *other {
                Transaction {
                    body: ref __self_1_0,
                    sigs: ref __self_1_1,
                    sig_map: ref __self_1_2,
                    body_bytes: ref __self_1_3,
                    signed_transaction_bytes: ref __self_1_4,
                } => match *self {
                    Transaction {
                        body: ref __self_0_0,
                        sigs: ref __self_0_1,
                        sig_map: ref __self_0_2,
                        body_bytes: ref __self_0_3,
                        signed_transaction_bytes: ref __self_0_4,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                    }
                },
            }
        }
    }
    impl ::prost::Message for Transaction {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.body {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.sigs {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.sig_map {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if self.body_bytes != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.body_bytes, buf);
            }
            if self.signed_transaction_bytes != b"" as &[u8] {
                ::prost::encoding::bytes::encode(5u32, &self.signed_transaction_bytes, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Transaction";
            match tag {
                1u32 => {
                    let mut value = &mut self.body;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "body");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.sigs;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "sigs");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.sig_map;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "sig_map");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.body_bytes;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "body_bytes");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.signed_transaction_bytes;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "signed_transaction_bytes");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .body
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .sigs
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .sig_map
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + if self.body_bytes != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(4u32, &self.body_bytes)
                } else {
                    0
                }
                + if self.signed_transaction_bytes != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(5u32, &self.signed_transaction_bytes)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.body = ::core::option::Option::None;
            self.sigs = ::core::option::Option::None;
            self.sig_map = ::core::option::Option::None;
            self.body_bytes.clear();
            self.signed_transaction_bytes.clear();
        }
    }
    impl ::core::default::Default for Transaction {
        fn default() -> Self {
            Transaction {
                body: ::core::default::Default::default(),
                sigs: ::core::default::Default::default(),
                sig_map: ::core::default::Default::default(),
                body_bytes: ::core::default::Default::default(),
                signed_transaction_bytes: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for Transaction {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Transaction");
            let builder = {
                let wrapper = &self.body;
                builder.field("body", &wrapper)
            };
            let builder = {
                let wrapper = &self.sigs;
                builder.field("sigs", &wrapper)
            };
            let builder = {
                let wrapper = &self.sig_map;
                builder.field("sig_map", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.body_bytes)
                };
                builder.field("body_bytes", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.signed_transaction_bytes)
                };
                builder.field("signed_transaction_bytes", &wrapper)
            };
            builder.finish()
        }
    }
    /// Each query from the client to the node will contain the QueryHeader, which gives the requested
    /// response type, and includes a payment transaction that will compensate the node for responding to
    /// the query. The payment can be blank if the query is free.
    pub struct QueryHeader {
        /// A signed CryptoTransferTransaction to pay the node a fee for handling this query
        #[prost(message, optional, tag = "1")]
        pub payment: ::core::option::Option<Transaction>,
        /// The requested response, asking for cost, state proof, both, or neither
        #[prost(enumeration = "ResponseType", tag = "2")]
        pub response_type: i32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for QueryHeader {
        #[inline]
        fn clone(&self) -> QueryHeader {
            match *self {
                QueryHeader {
                    payment: ref __self_0_0,
                    response_type: ref __self_0_1,
                } => QueryHeader {
                    payment: ::core::clone::Clone::clone(&(*__self_0_0)),
                    response_type: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for QueryHeader {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for QueryHeader {
        #[inline]
        fn eq(&self, other: &QueryHeader) -> bool {
            match *other {
                QueryHeader {
                    payment: ref __self_1_0,
                    response_type: ref __self_1_1,
                } => match *self {
                    QueryHeader {
                        payment: ref __self_0_0,
                        response_type: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &QueryHeader) -> bool {
            match *other {
                QueryHeader {
                    payment: ref __self_1_0,
                    response_type: ref __self_1_1,
                } => match *self {
                    QueryHeader {
                        payment: ref __self_0_0,
                        response_type: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for QueryHeader {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.payment {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.response_type != ResponseType::default() as i32 {
                ::prost::encoding::int32::encode(2u32, &self.response_type, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "QueryHeader";
            match tag {
                1u32 => {
                    let mut value = &mut self.payment;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "payment");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.response_type;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "response_type");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .payment
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.response_type != ResponseType::default() as i32 {
                    ::prost::encoding::int32::encoded_len(2u32, &self.response_type)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.payment = ::core::option::Option::None;
            self.response_type = ResponseType::default() as i32;
        }
    }
    impl ::core::default::Default for QueryHeader {
        fn default() -> Self {
            QueryHeader {
                payment: ::core::default::Default::default(),
                response_type: ResponseType::default() as i32,
            }
        }
    }
    impl ::core::fmt::Debug for QueryHeader {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("QueryHeader");
            let builder = {
                let wrapper = &self.payment;
                builder.field("payment", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match ResponseType::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.response_type)
                };
                builder.field("response_type", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl QueryHeader {
        ///Returns the enum value of `response_type`, or the default if the field is set to an invalid enum value.
        pub fn response_type(&self) -> ResponseType {
            ResponseType::from_i32(self.response_type).unwrap_or(ResponseType::default())
        }
        ///Sets `response_type` to the provided enum value.
        pub fn set_response_type(&mut self, value: ResponseType) {
            self.response_type = value as i32;
        }
    }
    /// The client uses the ResponseType to indicate that it desires the node send just the answer, or
    /// both the answer and a state proof. It can also ask for just the cost and not the answer itself
    /// (allowing it to tailor the payment transaction accordingly). If the payment in the query fails
    /// the precheck, then the response may have some fields blank. The state proof is only available for
    /// some types of information. It is available for a Record, but not a receipt. It is available for
    /// the information in each kind of *GetInfo request.
    #[repr(i32)]
    pub enum ResponseType {
        /// Response returns answer
        AnswerOnly = 0,
        /// (NOT YET SUPPORTED) Response returns both answer and state proof
        AnswerStateProof = 1,
        /// Response returns the cost of answer
        CostAnswer = 2,
        /// (NOT YET SUPPORTED) Response returns the total cost of answer and state proof
        CostAnswerStateProof = 3,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ResponseType {
        #[inline]
        fn clone(&self) -> ResponseType {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for ResponseType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for ResponseType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&ResponseType::AnswerOnly,) => ::core::fmt::Formatter::write_str(f, "AnswerOnly"),
                (&ResponseType::AnswerStateProof,) => {
                    ::core::fmt::Formatter::write_str(f, "AnswerStateProof")
                }
                (&ResponseType::CostAnswer,) => ::core::fmt::Formatter::write_str(f, "CostAnswer"),
                (&ResponseType::CostAnswerStateProof,) => {
                    ::core::fmt::Formatter::write_str(f, "CostAnswerStateProof")
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ResponseType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ResponseType {
        #[inline]
        fn eq(&self, other: &ResponseType) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for ResponseType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for ResponseType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for ResponseType {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for ResponseType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ResponseType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for ResponseType {
        #[inline]
        fn cmp(&self, other: &ResponseType) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    impl ResponseType {
        ///Returns `true` if `value` is a variant of `ResponseType`.
        pub fn is_valid(value: i32) -> bool {
            match value {
                0 => true,
                1 => true,
                2 => true,
                3 => true,
                _ => false,
            }
        }
        ///Converts an `i32` to a `ResponseType`, or `None` if `value` is not a valid variant.
        pub fn from_i32(value: i32) -> ::core::option::Option<ResponseType> {
            match value {
                0 => ::core::option::Option::Some(ResponseType::AnswerOnly),
                1 => ::core::option::Option::Some(ResponseType::AnswerStateProof),
                2 => ::core::option::Option::Some(ResponseType::CostAnswer),
                3 => ::core::option::Option::Some(ResponseType::CostAnswerStateProof),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for ResponseType {
        fn default() -> ResponseType {
            ResponseType::AnswerOnly
        }
    }
    impl ::core::convert::From<ResponseType> for i32 {
        fn from(value: ResponseType) -> i32 {
            value as i32
        }
    }
    #[non_exhaustive]
    ///
    ///Returned in `TransactionReceipt`, `Error::PreCheckStatus`, and `Error::ReceiptStatus`.
    ///
    ///The success variant is `Success` which is what a `TransactionReceipt` will contain for a
    ///successful transaction.
    ///    
    #[repr(i32)]
    pub enum ResponseCodeEnum {
        /// The transaction passed the precheck validations.
        Ok = 0,
        /// For any error not handled by specific error codes listed below.
        InvalidTransaction = 1,
        /// Payer account does not exist.
        PayerAccountNotFound = 2,
        /// Node Account provided does not match the node account of the node the transaction was submitted
        /// to.
        InvalidNodeAccount = 3,
        /// Pre-Check error when TransactionValidStart + transactionValidDuration is less than current
        /// consensus time.
        TransactionExpired = 4,
        /// Transaction start time is greater than current consensus time
        InvalidTransactionStart = 5,
        /// The given transactionValidDuration was either non-positive, or greater than the maximum
        /// valid duration of 180 secs.
        ///
        InvalidTransactionDuration = 6,
        /// The transaction signature is not valid
        InvalidSignature = 7,
        /// Transaction memo size exceeded 100 bytes
        MemoTooLong = 8,
        /// The fee provided in the transaction is insufficient for this type of transaction
        InsufficientTxFee = 9,
        /// The payer account has insufficient cryptocurrency to pay the transaction fee
        InsufficientPayerBalance = 10,
        /// This transaction ID is a duplicate of one that was submitted to this node or reached consensus
        /// in the last 180 seconds (receipt period)
        DuplicateTransaction = 11,
        /// If API is throttled out
        Busy = 12,
        /// The API is not currently supported
        NotSupported = 13,
        /// The file id is invalid or does not exist
        InvalidFileId = 14,
        /// The account id is invalid or does not exist
        InvalidAccountId = 15,
        /// The contract id is invalid or does not exist
        InvalidContractId = 16,
        /// Transaction id is not valid
        InvalidTransactionId = 17,
        /// Receipt for given transaction id does not exist
        ReceiptNotFound = 18,
        /// Record for given transaction id does not exist
        RecordNotFound = 19,
        /// The solidity id is invalid or entity with this solidity id does not exist
        InvalidSolidityId = 20,
        /// The responding node has submitted the transaction to the network. Its final status is still
        /// unknown.
        Unknown = 21,
        /// The transaction succeeded
        Success = 22,
        /// There was a system error and the transaction failed because of invalid request parameters.
        FailInvalid = 23,
        /// There was a system error while performing fee calculation, reserved for future.
        FailFee = 24,
        /// There was a system error while performing balance checks, reserved for future.
        FailBalance = 25,
        /// Key not provided in the transaction body
        KeyRequired = 26,
        /// Unsupported algorithm/encoding used for keys in the transaction
        BadEncoding = 27,
        /// When the account balance is not sufficient for the transfer
        InsufficientAccountBalance = 28,
        /// During an update transaction when the system is not able to find the Users Solidity address
        InvalidSolidityAddress = 29,
        /// Not enough gas was supplied to execute transaction
        InsufficientGas = 30,
        /// contract byte code size is over the limit
        ContractSizeLimitExceeded = 31,
        /// local execution (query) is requested for a function which changes state
        LocalCallModificationException = 32,
        /// Contract REVERT OPCODE executed
        ContractRevertExecuted = 33,
        /// For any contract execution related error not handled by specific error codes listed above.
        ContractExecutionException = 34,
        /// In Query validation, account with +ve(amount) value should be Receiving node account, the
        /// receiver account should be only one account in the list
        InvalidReceivingNodeAccount = 35,
        /// Header is missing in Query request
        MissingQueryHeader = 36,
        /// The update of the account failed
        AccountUpdateFailed = 37,
        /// Provided key encoding was not supported by the system
        InvalidKeyEncoding = 38,
        /// null solidity address
        NullSolidityAddress = 39,
        /// update of the contract failed
        ContractUpdateFailed = 40,
        /// the query header is invalid
        InvalidQueryHeader = 41,
        /// Invalid fee submitted
        InvalidFeeSubmitted = 42,
        /// Payer signature is invalid
        InvalidPayerSignature = 43,
        /// The keys were not provided in the request.
        KeyNotProvided = 44,
        /// Expiration time provided in the transaction was invalid.
        InvalidExpirationTime = 45,
        /// WriteAccess Control Keys are not provided for the file
        NoWaclKey = 46,
        /// The contents of file are provided as empty.
        FileContentEmpty = 47,
        /// The crypto transfer credit and debit do not sum equal to 0
        InvalidAccountAmounts = 48,
        /// Transaction body provided is empty
        EmptyTransactionBody = 49,
        /// Invalid transaction body provided
        InvalidTransactionBody = 50,
        /// the type of key (base ed25519 key, KeyList, or ThresholdKey) does not match the type of
        /// signature (base ed25519 signature, SignatureList, or ThresholdKeySignature)
        InvalidSignatureTypeMismatchingKey = 51,
        /// the number of key (KeyList, or ThresholdKey) does not match that of signature (SignatureList,
        /// or ThresholdKeySignature). e.g. if a keyList has 3 base keys, then the corresponding
        /// signatureList should also have 3 base signatures.
        InvalidSignatureCountMismatchingKey = 52,
        /// the livehash body is empty
        EmptyLiveHashBody = 53,
        /// the livehash data is missing
        EmptyLiveHash = 54,
        /// the keys for a livehash are missing
        EmptyLiveHashKeys = 55,
        /// the livehash data is not the output of a SHA-384 digest
        InvalidLiveHashSize = 56,
        /// the query body is empty
        EmptyQueryBody = 57,
        /// the crypto livehash query is empty
        EmptyLiveHashQuery = 58,
        /// the livehash is not present
        LiveHashNotFound = 59,
        /// the account id passed has not yet been created.
        AccountIdDoesNotExist = 60,
        /// the livehash already exists for a given account
        LiveHashAlreadyExists = 61,
        /// File WACL keys are invalid
        InvalidFileWacl = 62,
        /// Serialization failure
        SerializationFailed = 63,
        /// The size of the Transaction is greater than transactionMaxBytes
        TransactionOversize = 64,
        /// The Transaction has more than 50 levels
        TransactionTooManyLayers = 65,
        /// Contract is marked as deleted
        ContractDeleted = 66,
        /// the platform node is either disconnected or lagging behind.
        PlatformNotActive = 67,
        /// one public key matches more than one prefixes on the signature map
        KeyPrefixMismatch = 68,
        /// transaction not created by platform due to large backlog
        PlatformTransactionNotCreated = 69,
        /// auto renewal period is not a positive number of seconds
        InvalidRenewalPeriod = 70,
        /// the response code when a smart contract id is passed for a crypto API request
        InvalidPayerAccountId = 71,
        /// the account has been marked as deleted
        AccountDeleted = 72,
        /// the file has been marked as deleted
        FileDeleted = 73,
        /// same accounts repeated in the transfer account list
        AccountRepeatedInAccountAmounts = 74,
        /// attempting to set negative balance value for crypto account
        SettingNegativeAccountBalance = 75,
        /// when deleting smart contract that has crypto balance either transfer account or transfer smart
        /// contract is required
        ObtainerRequired = 76,
        /// when deleting smart contract that has crypto balance you can not use the same contract id as
        /// transferContractId as the one being deleted
        ObtainerSameContractId = 77,
        /// transferAccountId or transferContractId specified for contract delete does not exist
        ObtainerDoesNotExist = 78,
        /// attempting to modify (update or delete a immutable smart contract, i.e. one created without a
        /// admin key)
        ModifyingImmutableContract = 79,
        /// Unexpected exception thrown by file system functions
        FileSystemException = 80,
        /// the duration is not a subset of \[MINIMUM_AUTORENEW_DURATION,MAXIMUM_AUTORENEW_DURATION\]
        AutorenewDurationNotInRange = 81,
        /// Decoding the smart contract binary to a byte array failed. Check that the input is a valid hex
        /// string.
        ErrorDecodingBytestring = 82,
        /// File to create a smart contract was of length zero
        ContractFileEmpty = 83,
        /// Bytecode for smart contract is of length zero
        ContractBytecodeEmpty = 84,
        /// Attempt to set negative initial balance
        InvalidInitialBalance = 85,
        /// \[Deprecated\]. attempt to set negative receive record threshold
        InvalidReceiveRecordThreshold = 86,
        /// \[Deprecated\]. attempt to set negative send record threshold
        InvalidSendRecordThreshold = 87,
        /// Special Account Operations should be performed by only Genesis account, return this code if it
        /// is not Genesis Account
        AccountIsNotGenesisAccount = 88,
        /// The fee payer account doesn't have permission to submit such Transaction
        PayerAccountUnauthorized = 89,
        /// FreezeTransactionBody is invalid
        InvalidFreezeTransactionBody = 90,
        /// FreezeTransactionBody does not exist
        FreezeTransactionBodyNotFound = 91,
        /// Exceeded the number of accounts (both from and to) allowed for crypto transfer list
        TransferListSizeLimitExceeded = 92,
        /// Smart contract result size greater than specified maxResultSize
        ResultSizeLimitExceeded = 93,
        /// The payer account is not a special account(account 0.0.55)
        NotSpecialAccount = 94,
        /// Negative gas was offered in smart contract call
        ContractNegativeGas = 95,
        /// Negative value / initial balance was specified in a smart contract call / create
        ContractNegativeValue = 96,
        /// Failed to update fee file
        InvalidFeeFile = 97,
        /// Failed to update exchange rate file
        InvalidExchangeRateFile = 98,
        /// Payment tendered for contract local call cannot cover both the fee and the gas
        InsufficientLocalCallGas = 99,
        /// Entities with Entity ID below 1000 are not allowed to be deleted
        EntityNotAllowedToDelete = 100,
        /// Violating one of these rules: 1) treasury account can update all entities below 0.0.1000, 2)
        /// account 0.0.50 can update all entities from 0.0.51 - 0.0.80, 3) Network Function Master Account
        /// A/c 0.0.50 - Update all Network Function accounts & perform all the Network Functions listed
        /// below, 4) Network Function Accounts: i) A/c 0.0.55 - Update Address Book files (0.0.101/102),
        /// ii) A/c 0.0.56 - Update Fee schedule (0.0.111), iii) A/c 0.0.57 - Update Exchange Rate
        /// (0.0.112).
        AuthorizationFailed = 101,
        /// Fee Schedule Proto uploaded but not valid (append or update is required)
        FileUploadedProtoInvalid = 102,
        /// Fee Schedule Proto uploaded but not valid (append or update is required)
        FileUploadedProtoNotSavedToDisk = 103,
        /// Fee Schedule Proto File Part uploaded
        FeeScheduleFilePartUploaded = 104,
        /// The change on Exchange Rate exceeds Exchange_Rate_Allowed_Percentage
        ExchangeRateChangeLimitExceeded = 105,
        /// Contract permanent storage exceeded the currently allowable limit
        MaxContractStorageExceeded = 106,
        /// Transfer Account should not be same as Account to be deleted
        TransferAccountSameAsDeleteAccount = 107,
        TotalLedgerBalanceInvalid = 108,
        /// The expiration date/time on a smart contract may not be reduced
        ExpirationReductionNotAllowed = 110,
        /// Gas exceeded currently allowable gas limit per transaction
        MaxGasLimitExceeded = 111,
        /// File size exceeded the currently allowable limit
        MaxFileSizeExceeded = 112,
        /// When a valid signature is not provided for operations on account with receiverSigRequired=true
        ReceiverSigRequired = 113,
        /// The Topic ID specified is not in the system.
        InvalidTopicId = 150,
        /// A provided admin key was invalid.
        InvalidAdminKey = 155,
        /// A provided submit key was invalid.
        InvalidSubmitKey = 156,
        /// An attempted operation was not authorized (ie - a deleteTopic for a topic with no adminKey).
        Unauthorized = 157,
        /// A ConsensusService message is empty.
        InvalidTopicMessage = 158,
        /// The autoRenewAccount specified is not a valid, active account.
        InvalidAutorenewAccount = 159,
        /// An adminKey was not specified on the topic, so there must not be an autoRenewAccount.
        AutorenewAccountNotAllowed = 160,
        /// The topic has expired, was not automatically renewed, and is in a 7 day grace period before the
        /// topic will be deleted unrecoverably. This error response code will not be returned until
        /// autoRenew functionality is supported by HAPI.
        TopicExpired = 162,
        /// chunk number must be from 1 to total (chunks) inclusive.
        InvalidChunkNumber = 163,
        /// For every chunk, the payer account that is part of initialTransactionID must match the Payer Account of this transaction. The entire initialTransactionID should match the transactionID of the first chunk, but this is not checked or enforced by Hedera except when the chunk number is 1.
        InvalidChunkTransactionId = 164,
        /// Account is frozen and cannot transact with the token
        AccountFrozenForToken = 165,
        /// An involved account already has more than <tt>tokens.maxPerAccount</tt> associations with non-deleted tokens.
        TokensPerAccountLimitExceeded = 166,
        /// The token is invalid or does not exist
        InvalidTokenId = 167,
        /// Invalid token decimals
        InvalidTokenDecimals = 168,
        /// Invalid token initial supply
        InvalidTokenInitialSupply = 169,
        /// Treasury Account does not exist or is deleted
        InvalidTreasuryAccountForToken = 170,
        /// Token Symbol is not UTF-8 capitalized alphabetical string
        InvalidTokenSymbol = 171,
        /// Freeze key is not set on token
        TokenHasNoFreezeKey = 172,
        /// Amounts in transfer list are not net zero
        TransfersNotZeroSumForToken = 173,
        /// A token symbol was not provided
        MissingTokenSymbol = 174,
        /// The provided token symbol was too long
        TokenSymbolTooLong = 175,
        /// KYC must be granted and account does not have KYC granted
        AccountKycNotGrantedForToken = 176,
        /// KYC key is not set on token
        TokenHasNoKycKey = 177,
        /// Token balance is not sufficient for the transaction
        InsufficientTokenBalance = 178,
        /// Token transactions cannot be executed on deleted token
        TokenWasDeleted = 179,
        /// Supply key is not set on token
        TokenHasNoSupplyKey = 180,
        /// Wipe key is not set on token
        TokenHasNoWipeKey = 181,
        /// The requested token mint amount would cause an invalid total supply
        InvalidTokenMintAmount = 182,
        /// The requested token burn amount would cause an invalid total supply
        InvalidTokenBurnAmount = 183,
        /// A required token-account relationship is missing
        TokenNotAssociatedToAccount = 184,
        /// The target of a wipe operation was the token treasury account
        CannotWipeTokenTreasuryAccount = 185,
        /// The provided KYC key was invalid.
        InvalidKycKey = 186,
        /// The provided wipe key was invalid.
        InvalidWipeKey = 187,
        /// The provided freeze key was invalid.
        InvalidFreezeKey = 188,
        /// The provided supply key was invalid.
        InvalidSupplyKey = 189,
        /// Token Name is not provided
        MissingTokenName = 190,
        /// Token Name is too long
        TokenNameTooLong = 191,
        /// The provided wipe amount must not be negative, zero or bigger than the token holder balance
        InvalidWipingAmount = 192,
        /// Token does not have Admin key set, thus update/delete transactions cannot be performed
        TokenIsImmutable = 193,
        /// An <tt>associateToken</tt> operation specified a token already associated to the account
        TokenAlreadyAssociatedToAccount = 194,
        /// An attempted operation is invalid until all token balances for the target account are zero
        TransactionRequiresZeroTokenBalances = 195,
        /// An attempted operation is invalid because the account is a treasury
        AccountIsTreasury = 196,
        /// Same TokenIDs present in the token list
        TokenIdRepeatedInTokenList = 197,
        /// Exceeded the number of token transfers (both from and to) allowed for token transfer list
        TokenTransferListSizeLimitExceeded = 198,
        /// TokenTransfersTransactionBody has no TokenTransferList
        EmptyTokenTransferBody = 199,
        /// TokenTransfersTransactionBody has a TokenTransferList with no AccountAmounts
        EmptyTokenTransferAccountAmounts = 200,
        /// The Scheduled entity does not exist; or has now expired, been deleted, or been executed
        InvalidScheduleId = 201,
        /// The Scheduled entity cannot be modified. Admin key not set
        ScheduleIsImmutable = 202,
        /// The provided Scheduled Payer does not exist
        InvalidSchedulePayerId = 203,
        /// The Schedule Create Transaction TransactionID account does not exist
        InvalidScheduleAccountId = 204,
        /// The provided sig map did not contain any new valid signatures from required signers of the scheduled transaction
        NoNewValidSignatures = 205,
        /// The required signers for a scheduled transaction cannot be resolved, for example because they do not exist or have been deleted
        UnresolvableRequiredSigners = 206,
        /// Only whitelisted transaction types may be scheduled
        ScheduledTransactionNotInWhitelist = 207,
        /// At least one of the signatures in the provided sig map did not represent a valid signature for any required signer
        SomeSignaturesWereInvalid = 208,
        /// The scheduled field in the TransactionID may not be set to true
        TransactionIdFieldNotAllowed = 209,
        /// A schedule already exists with the same identifying fields of an attempted ScheduleCreate (that is, all fields other than scheduledPayerAccountID)
        IdenticalScheduleAlreadyCreated = 210,
        /// A string field in the transaction has a UTF-8 encoding with the prohibited zero byte
        InvalidZeroByteInString = 211,
        /// A schedule being signed or deleted has already been deleted
        ScheduleAlreadyDeleted = 212,
        /// A schedule being signed or deleted has already been executed
        ScheduleAlreadyExecuted = 213,
        /// ConsensusSubmitMessage request's message size is larger than allowed.
        MessageSizeTooLarge = 214,
        /// An operation was assigned to more than one throttle group in a given bucket
        OperationRepeatedInBucketGroups = 215,
        /// The capacity needed to satisfy all opsPerSec groups in a bucket overflowed a signed 8-byte integral type
        BucketCapacityOverflow = 216,
        /// Given the network size in the address book, the node-level capacity for an operation would never be enough to accept a single request; usually means a bucket burstPeriod should be increased
        NodeCapacityNotSufficientForOperation = 217,
        /// A bucket was defined without any throttle groups
        BucketHasNoThrottleGroups = 218,
        /// A throttle group was granted zero opsPerSec
        ThrottleGroupHasZeroOpsPerSec = 219,
        /// The throttle definitions file was updated, but some supported operations were not assigned a bucket
        SuccessButMissingExpectedOperation = 220,
        /// The new contents for the throttle definitions system file were not valid protobuf
        UnparseableThrottleDefinitions = 221,
        /// The new throttle definitions system file were invalid, and no more specific error could be divined
        InvalidThrottleDefinitions = 222,
        /// The transaction references an account which has passed its expiration without renewal funds available, and currently remains in the ledger only because of the grace period given to expired entities
        AccountExpiredAndPendingRemoval = 223,
        /// Invalid token max supply
        InvalidTokenMaxSupply = 224,
        /// Invalid token nft serial number
        InvalidTokenNftSerialNumber = 225,
        /// Invalid nft id
        InvalidNftId = 226,
        /// Nft metadata is too long
        MetadataTooLong = 227,
        /// Repeated operations count exceeds the limit
        BatchSizeLimitExceeded = 228,
        /// The range of data to be gathered is out of the set boundaries
        InvalidQueryRange = 229,
        /// A custom fractional fee set a denominator of zero
        FractionDividesByZero = 230,
        /// The transaction payer could not afford a custom fee
        InsufficientPayerBalanceForCustomFee = 231,
        /// More than 10 custom fees were specified
        CustomFeesListTooLong = 232,
        /// Any of the feeCollector accounts for customFees is invalid
        InvalidCustomFeeCollector = 233,
        /// Any of the token Ids in customFees is invalid
        InvalidTokenIdInCustomFees = 234,
        /// Any of the token Ids in customFees are not associated to feeCollector
        TokenNotAssociatedToFeeCollector = 235,
        /// A token cannot have more units minted due to its configured supply ceiling
        TokenMaxSupplyReached = 236,
        /// The transaction attempted to move an NFT serial number from an account other than its owner
        SenderDoesNotOwnNftSerialNo = 237,
        /// A custom fee schedule entry did not specify either a fixed or fractional fee
        CustomFeeNotFullySpecified = 238,
        /// Only positive fees may be assessed at this time
        CustomFeeMustBePositive = 239,
        /// Fee schedule key is not set on token
        TokenHasNoFeeScheduleKey = 240,
        /// A fractional custom fee exceeded the range of a 64-bit signed integer
        CustomFeeOutsideNumericRange = 241,
        /// A royalty cannot exceed the total fungible value exchanged for an NFT
        RoyaltyFractionCannotExceedOne = 242,
        /// Each fractional custom fee must have its maximum_amount, if specified, at least its minimum_amount
        FractionalFeeMaxAmountLessThanMinAmount = 243,
        /// A fee schedule update tried to clear the custom fees from a token whose fee schedule was already empty
        CustomScheduleAlreadyHasNoFees = 244,
        /// Only tokens of type FUNGIBLE_COMMON can be used to as fee schedule denominations
        CustomFeeDenominationMustBeFungibleCommon = 245,
        /// Only tokens of type FUNGIBLE_COMMON can have fractional fees
        CustomFractionalFeeOnlyAllowedForFungibleCommon = 246,
        /// The provided custom fee schedule key was invalid
        InvalidCustomFeeScheduleKey = 247,
        /// The requested token mint metadata was invalid
        InvalidTokenMintMetadata = 248,
        /// The requested token burn metadata was invalid
        InvalidTokenBurnMetadata = 249,
        /// The treasury for a unique token cannot be changed until it owns no NFTs
        CurrentTreasuryStillOwnsNfts = 250,
        /// An account cannot be dissociated from a unique token if it owns NFTs for the token
        AccountStillOwnsNfts = 251,
        /// A NFT can only be burned when owned by the unique token's treasury
        TreasuryMustOwnBurnedNft = 252,
        /// An account did not own the NFT to be wiped
        AccountDoesNotOwnWipedNft = 253,
        /// An AccountAmount token transfers list referenced a token type other than FUNGIBLE_COMMON
        AccountAmountTransfersOnlyAllowedForFungibleCommon = 254,
        /// All the NFTs allowed in the current price regime have already been minted
        MaxNftsInPriceRegimeHaveBeenMinted = 255,
        /// The payer account has been marked as deleted
        PayerAccountDeleted = 256,
        /// The reference chain of custom fees for a transferred token exceeded the maximum length of 2
        CustomFeeChargingExceededMaxRecursionDepth = 257,
        /// More than 20 balance adjustments were to satisfy a CryptoTransfer and its implied custom fee payments
        CustomFeeChargingExceededMaxAccountAmounts = 258,
        /// The sender account in the token transfer transaction could not afford a custom fee
        InsufficientSenderAccountBalanceForCustomFee = 259,
        /// Currently no more than 4,294,967,295 NFTs may be minted for a given unique token type
        SerialNumberLimitReached = 260,
        /// Only tokens of type NON_FUNGIBLE_UNIQUE can have royalty fees
        CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique = 261,
        /// The account has reached the limit on the automatic associations count.
        NoRemainingAutomaticAssociations = 262,
        /// Already existing automatic associations are more than the new maximum automatic associations.
        ExistingAutomaticAssociationsExceedGivenLimit = 263,
        /// Cannot set the number of automatic associations for an account more than the maximum allowed
        /// token associations <tt>tokens.maxPerAccount</tt>.
        RequestedNumAutomaticAssociationsExceedsAssociationLimit = 264,
        /// Token is paused. This Token cannot be a part of any kind of Transaction until unpaused.
        TokenIsPaused = 265,
        /// Pause key is not set on token
        TokenHasNoPauseKey = 266,
        /// The provided pause key was invalid
        InvalidPauseKey = 267,
        /// The update file in a freeze transaction body must exist.
        FreezeUpdateFileDoesNotExist = 268,
        /// The hash of the update file in a freeze transaction body must match the in-memory hash.
        FreezeUpdateFileHashDoesNotMatch = 269,
        /// A FREEZE_UPGRADE transaction was handled with no previous update prepared.
        NoUpgradeHasBeenPrepared = 270,
        /// A FREEZE_ABORT transaction was handled with no scheduled freeze.
        NoFreezeIsScheduled = 271,
        /// The update file hash when handling a FREEZE_UPGRADE transaction differs from the file
        /// hash at the time of handling the PREPARE_UPGRADE transaction.
        UpdateFileHashChangedSincePrepareUpgrade = 272,
        /// The given freeze start time was in the (consensus) past.
        FreezeStartTimeMustBeFuture = 273,
        /// The prepared update file cannot be updated or appended until either the upgrade has
        /// been completed, or a FREEZE_ABORT has been handled.
        PreparedUpdateFileIsImmutable = 274,
        /// Once a freeze is scheduled, it must be aborted before any other type of freeze can
        /// can be performed.
        FreezeAlreadyScheduled = 275,
        /// If an NMT upgrade has been prepared, the following operation must be a FREEZE_UPGRADE.
        /// (To issue a FREEZE_ONLY, submit a FREEZE_ABORT first.)
        FreezeUpgradeInProgress = 276,
        /// If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
        /// confirm the id of the file to be used in the upgrade.
        UpdateFileIdDoesNotMatchPrepared = 277,
        /// If an NMT upgrade has been prepared, the subsequent FREEZE_UPGRADE transaction must
        /// confirm the hash of the file to be used in the upgrade.
        UpdateFileHashDoesNotMatchPrepared = 278,
        /// Consensus throttle did not allow execution of this transaction. System is throttled at
        /// consensus level.
        ConsensusGasExhausted = 279,
        /// A precompiled contract succeeded, but was later reverted.
        RevertedSuccess = 280,
        /// All contract storage allocated to the current price regime has been consumed.
        MaxStorageInPriceRegimeHasBeenUsed = 281,
        /// An alias used in a CryptoTransfer transaction is not the serialization of a primitive Key
        /// message--that is, a Key with a single Ed25519 or ECDSA(secp256k1) public key and no
        /// unknown protobuf fields.
        InvalidAliasKey = 282,
        /// A fungible token transfer expected a different number of decimals than the involved
        /// type actually has.
        UnexpectedTokenDecimals = 283,
        /// \[Deprecated\] The proxy account id is invalid or does not exist.
        InvalidProxyAccountId = 284,
        /// The transfer account id in CryptoDelete transaction is invalid or does not exist.
        InvalidTransferAccountId = 285,
        /// The fee collector account id in TokenFeeScheduleUpdate is invalid or does not exist.
        InvalidFeeCollectorAccountId = 286,
        /// The alias already set on an account cannot be updated using CryptoUpdate transaction.
        AliasIsImmutable = 287,
        /// An approved allowance specifies a spender account that is the same as the hbar/token
        /// owner account.
        SpenderAccountSameAsOwner = 288,
        /// The establishment or adjustment of an approved allowance cause the token allowance
        /// to exceed the token maximum supply.
        AmountExceedsTokenMaxSupply = 289,
        /// The specified amount for an approved allowance cannot be negative.
        NegativeAllowanceAmount = 290,
        /// \[Deprecated\] The approveForAll flag cannot be set for a fungible token.
        CannotApproveForAllFungibleCommon = 291,
        /// The spender does not have an existing approved allowance with the hbar/token owner.
        SpenderDoesNotHaveAllowance = 292,
        /// The transfer amount exceeds the current approved allowance for the spender account.
        AmountExceedsAllowance = 293,
        /// The payer account of an approveAllowances or adjustAllowance transaction is attempting
        /// to go beyond the maximum allowed number of allowances.
        MaxAllowancesExceeded = 294,
        /// No allowances have been specified in the approval transaction.
        EmptyAllowances = 295,
        /// \[Deprecated\] Spender is repeated more than once in Crypto or Token or NFT allowance lists in a single
        /// CryptoApproveAllowance transaction.
        SpenderAccountRepeatedInAllowances = 296,
        /// \[Deprecated\] Serial numbers are repeated in nft allowance for a single spender account
        RepeatedSerialNumsInNftAllowances = 297,
        /// Fungible common token used in NFT allowances
        FungibleTokenInNftAllowances = 298,
        /// Non fungible token used in fungible token allowances
        NftInFungibleTokenAllowances = 299,
        /// The account id specified as the owner is invalid or does not exist.
        InvalidAllowanceOwnerId = 300,
        /// The account id specified as the spender is invalid or does not exist.
        InvalidAllowanceSpenderId = 301,
        /// \[Deprecated\] If the CryptoDeleteAllowance transaction has repeated crypto or token or Nft allowances to delete.
        RepeatedAllowancesToDelete = 302,
        /// If the account Id specified as the delegating spender is invalid or does not exist.
        InvalidDelegatingSpender = 303,
        /// The delegating Spender cannot grant approveForAll allowance on a NFT token type for another spender.
        DelegatingSpenderCannotGrantApproveForAll = 304,
        /// The delegating Spender cannot grant allowance on a NFT serial for another spender as it doesnt not have approveForAll
        /// granted on token-owner.
        DelegatingSpenderDoesNotHaveApproveForAll = 305,
        /// The scheduled transaction could not be created because it's expiration_time was too far in the future.
        ScheduleExpirationTimeTooFarInFuture = 306,
        /// The scheduled transaction could not be created because it's expiration_time was less than or equal to the consensus time.
        ScheduleExpirationTimeMustBeHigherThanConsensusTime = 307,
        /// The scheduled transaction could not be created because it would cause throttles to be violated on the specified expiration_time.
        ScheduleFutureThrottleExceeded = 308,
        /// The scheduled transaction could not be created because it would cause the gas limit to be violated on the specified expiration_time.
        ScheduleFutureGasLimitExceeded = 309,
        /// The ethereum transaction either failed parsing or failed signature validation, or some other EthereumTransaction error not covered by another response code.
        InvalidEthereumTransaction = 310,
        /// EthereumTransaction was signed against a chainId that this network does not support.
        WrongChainId = 311,
        /// This transaction specified an ethereumNonce that is not the current ethereumNonce of the account.
        WrongNonce = 312,
        /// The ethereum transaction specified an access list, which the network does not support.
        AccessListUnsupported = 313,
        /// A schedule being signed or deleted has passed it's expiration date and is pending execution if needed and then expiration.
        SchedulePendingExpiration = 314,
        /// A selfdestruct or ContractDelete targeted a contract that is a token treasury.
        ContractIsTokenTreasury = 315,
        /// A selfdestruct or ContractDelete targeted a contract with non-zero token balances.
        ContractHasNonZeroTokenBalances = 316,
        /// A contract referenced by a transaction is "detached"; that is, expired and lacking any
        /// hbar funds for auto-renewal payment---but still within its post-expiry grace period.
        ContractExpiredAndPendingRemoval = 317,
        /// A ContractUpdate requested removal of a contract's auto-renew account, but that contract has  
        /// no auto-renew account.
        ContractHasNoAutoRenewAccount = 318,
        /// A delete transaction submitted via HAPI set permanent_removal=true
        PermanentRemovalRequiresSystemInitiation = 319,
        ///
        /// A CryptoCreate or ContractCreate used the deprecated proxyAccountID field.
        ProxyAccountIdFieldIsDeprecated = 320,
        /// An account set the staked_account_id to itself in CryptoUpdate or ContractUpdate transactions.
        SelfStakingIsNotAllowed = 321,
        /// The staking account id or staking node id given is invalid or does not exist.
        InvalidStakingId = 322,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ResponseCodeEnum {
        #[inline]
        fn clone(&self) -> ResponseCodeEnum {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for ResponseCodeEnum {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for ResponseCodeEnum {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&ResponseCodeEnum::Ok,) => ::core::fmt::Formatter::write_str(f, "Ok"),
                (&ResponseCodeEnum::InvalidTransaction,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTransaction")
                }
                (&ResponseCodeEnum::PayerAccountNotFound,) => {
                    ::core::fmt::Formatter::write_str(f, "PayerAccountNotFound")
                }
                (&ResponseCodeEnum::InvalidNodeAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidNodeAccount")
                }
                (&ResponseCodeEnum::TransactionExpired,) => {
                    ::core::fmt::Formatter::write_str(f, "TransactionExpired")
                }
                (&ResponseCodeEnum::InvalidTransactionStart,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTransactionStart")
                }
                (&ResponseCodeEnum::InvalidTransactionDuration,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTransactionDuration")
                }
                (&ResponseCodeEnum::InvalidSignature,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidSignature")
                }
                (&ResponseCodeEnum::MemoTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "MemoTooLong")
                }
                (&ResponseCodeEnum::InsufficientTxFee,) => {
                    ::core::fmt::Formatter::write_str(f, "InsufficientTxFee")
                }
                (&ResponseCodeEnum::InsufficientPayerBalance,) => {
                    ::core::fmt::Formatter::write_str(f, "InsufficientPayerBalance")
                }
                (&ResponseCodeEnum::DuplicateTransaction,) => {
                    ::core::fmt::Formatter::write_str(f, "DuplicateTransaction")
                }
                (&ResponseCodeEnum::Busy,) => ::core::fmt::Formatter::write_str(f, "Busy"),
                (&ResponseCodeEnum::NotSupported,) => {
                    ::core::fmt::Formatter::write_str(f, "NotSupported")
                }
                (&ResponseCodeEnum::InvalidFileId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidFileId")
                }
                (&ResponseCodeEnum::InvalidAccountId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidAccountId")
                }
                (&ResponseCodeEnum::InvalidContractId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidContractId")
                }
                (&ResponseCodeEnum::InvalidTransactionId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTransactionId")
                }
                (&ResponseCodeEnum::ReceiptNotFound,) => {
                    ::core::fmt::Formatter::write_str(f, "ReceiptNotFound")
                }
                (&ResponseCodeEnum::RecordNotFound,) => {
                    ::core::fmt::Formatter::write_str(f, "RecordNotFound")
                }
                (&ResponseCodeEnum::InvalidSolidityId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidSolidityId")
                }
                (&ResponseCodeEnum::Unknown,) => ::core::fmt::Formatter::write_str(f, "Unknown"),
                (&ResponseCodeEnum::Success,) => ::core::fmt::Formatter::write_str(f, "Success"),
                (&ResponseCodeEnum::FailInvalid,) => {
                    ::core::fmt::Formatter::write_str(f, "FailInvalid")
                }
                (&ResponseCodeEnum::FailFee,) => ::core::fmt::Formatter::write_str(f, "FailFee"),
                (&ResponseCodeEnum::FailBalance,) => {
                    ::core::fmt::Formatter::write_str(f, "FailBalance")
                }
                (&ResponseCodeEnum::KeyRequired,) => {
                    ::core::fmt::Formatter::write_str(f, "KeyRequired")
                }
                (&ResponseCodeEnum::BadEncoding,) => {
                    ::core::fmt::Formatter::write_str(f, "BadEncoding")
                }
                (&ResponseCodeEnum::InsufficientAccountBalance,) => {
                    ::core::fmt::Formatter::write_str(f, "InsufficientAccountBalance")
                }
                (&ResponseCodeEnum::InvalidSolidityAddress,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidSolidityAddress")
                }
                (&ResponseCodeEnum::InsufficientGas,) => {
                    ::core::fmt::Formatter::write_str(f, "InsufficientGas")
                }
                (&ResponseCodeEnum::ContractSizeLimitExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractSizeLimitExceeded")
                }
                (&ResponseCodeEnum::LocalCallModificationException,) => {
                    ::core::fmt::Formatter::write_str(f, "LocalCallModificationException")
                }
                (&ResponseCodeEnum::ContractRevertExecuted,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractRevertExecuted")
                }
                (&ResponseCodeEnum::ContractExecutionException,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractExecutionException")
                }
                (&ResponseCodeEnum::InvalidReceivingNodeAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidReceivingNodeAccount")
                }
                (&ResponseCodeEnum::MissingQueryHeader,) => {
                    ::core::fmt::Formatter::write_str(f, "MissingQueryHeader")
                }
                (&ResponseCodeEnum::AccountUpdateFailed,) => {
                    ::core::fmt::Formatter::write_str(f, "AccountUpdateFailed")
                }
                (&ResponseCodeEnum::InvalidKeyEncoding,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidKeyEncoding")
                }
                (&ResponseCodeEnum::NullSolidityAddress,) => {
                    ::core::fmt::Formatter::write_str(f, "NullSolidityAddress")
                }
                (&ResponseCodeEnum::ContractUpdateFailed,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractUpdateFailed")
                }
                (&ResponseCodeEnum::InvalidQueryHeader,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidQueryHeader")
                }
                (&ResponseCodeEnum::InvalidFeeSubmitted,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidFeeSubmitted")
                }
                (&ResponseCodeEnum::InvalidPayerSignature,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidPayerSignature")
                }
                (&ResponseCodeEnum::KeyNotProvided,) => {
                    ::core::fmt::Formatter::write_str(f, "KeyNotProvided")
                }
                (&ResponseCodeEnum::InvalidExpirationTime,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidExpirationTime")
                }
                (&ResponseCodeEnum::NoWaclKey,) => {
                    ::core::fmt::Formatter::write_str(f, "NoWaclKey")
                }
                (&ResponseCodeEnum::FileContentEmpty,) => {
                    ::core::fmt::Formatter::write_str(f, "FileContentEmpty")
                }
                (&ResponseCodeEnum::InvalidAccountAmounts,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidAccountAmounts")
                }
                (&ResponseCodeEnum::EmptyTransactionBody,) => {
                    ::core::fmt::Formatter::write_str(f, "EmptyTransactionBody")
                }
                (&ResponseCodeEnum::InvalidTransactionBody,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTransactionBody")
                }
                (&ResponseCodeEnum::InvalidSignatureTypeMismatchingKey,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidSignatureTypeMismatchingKey")
                }
                (&ResponseCodeEnum::InvalidSignatureCountMismatchingKey,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidSignatureCountMismatchingKey")
                }
                (&ResponseCodeEnum::EmptyLiveHashBody,) => {
                    ::core::fmt::Formatter::write_str(f, "EmptyLiveHashBody")
                }
                (&ResponseCodeEnum::EmptyLiveHash,) => {
                    ::core::fmt::Formatter::write_str(f, "EmptyLiveHash")
                }
                (&ResponseCodeEnum::EmptyLiveHashKeys,) => {
                    ::core::fmt::Formatter::write_str(f, "EmptyLiveHashKeys")
                }
                (&ResponseCodeEnum::InvalidLiveHashSize,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidLiveHashSize")
                }
                (&ResponseCodeEnum::EmptyQueryBody,) => {
                    ::core::fmt::Formatter::write_str(f, "EmptyQueryBody")
                }
                (&ResponseCodeEnum::EmptyLiveHashQuery,) => {
                    ::core::fmt::Formatter::write_str(f, "EmptyLiveHashQuery")
                }
                (&ResponseCodeEnum::LiveHashNotFound,) => {
                    ::core::fmt::Formatter::write_str(f, "LiveHashNotFound")
                }
                (&ResponseCodeEnum::AccountIdDoesNotExist,) => {
                    ::core::fmt::Formatter::write_str(f, "AccountIdDoesNotExist")
                }
                (&ResponseCodeEnum::LiveHashAlreadyExists,) => {
                    ::core::fmt::Formatter::write_str(f, "LiveHashAlreadyExists")
                }
                (&ResponseCodeEnum::InvalidFileWacl,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidFileWacl")
                }
                (&ResponseCodeEnum::SerializationFailed,) => {
                    ::core::fmt::Formatter::write_str(f, "SerializationFailed")
                }
                (&ResponseCodeEnum::TransactionOversize,) => {
                    ::core::fmt::Formatter::write_str(f, "TransactionOversize")
                }
                (&ResponseCodeEnum::TransactionTooManyLayers,) => {
                    ::core::fmt::Formatter::write_str(f, "TransactionTooManyLayers")
                }
                (&ResponseCodeEnum::ContractDeleted,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractDeleted")
                }
                (&ResponseCodeEnum::PlatformNotActive,) => {
                    ::core::fmt::Formatter::write_str(f, "PlatformNotActive")
                }
                (&ResponseCodeEnum::KeyPrefixMismatch,) => {
                    ::core::fmt::Formatter::write_str(f, "KeyPrefixMismatch")
                }
                (&ResponseCodeEnum::PlatformTransactionNotCreated,) => {
                    ::core::fmt::Formatter::write_str(f, "PlatformTransactionNotCreated")
                }
                (&ResponseCodeEnum::InvalidRenewalPeriod,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidRenewalPeriod")
                }
                (&ResponseCodeEnum::InvalidPayerAccountId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidPayerAccountId")
                }
                (&ResponseCodeEnum::AccountDeleted,) => {
                    ::core::fmt::Formatter::write_str(f, "AccountDeleted")
                }
                (&ResponseCodeEnum::FileDeleted,) => {
                    ::core::fmt::Formatter::write_str(f, "FileDeleted")
                }
                (&ResponseCodeEnum::AccountRepeatedInAccountAmounts,) => {
                    ::core::fmt::Formatter::write_str(f, "AccountRepeatedInAccountAmounts")
                }
                (&ResponseCodeEnum::SettingNegativeAccountBalance,) => {
                    ::core::fmt::Formatter::write_str(f, "SettingNegativeAccountBalance")
                }
                (&ResponseCodeEnum::ObtainerRequired,) => {
                    ::core::fmt::Formatter::write_str(f, "ObtainerRequired")
                }
                (&ResponseCodeEnum::ObtainerSameContractId,) => {
                    ::core::fmt::Formatter::write_str(f, "ObtainerSameContractId")
                }
                (&ResponseCodeEnum::ObtainerDoesNotExist,) => {
                    ::core::fmt::Formatter::write_str(f, "ObtainerDoesNotExist")
                }
                (&ResponseCodeEnum::ModifyingImmutableContract,) => {
                    ::core::fmt::Formatter::write_str(f, "ModifyingImmutableContract")
                }
                (&ResponseCodeEnum::FileSystemException,) => {
                    ::core::fmt::Formatter::write_str(f, "FileSystemException")
                }
                (&ResponseCodeEnum::AutorenewDurationNotInRange,) => {
                    ::core::fmt::Formatter::write_str(f, "AutorenewDurationNotInRange")
                }
                (&ResponseCodeEnum::ErrorDecodingBytestring,) => {
                    ::core::fmt::Formatter::write_str(f, "ErrorDecodingBytestring")
                }
                (&ResponseCodeEnum::ContractFileEmpty,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractFileEmpty")
                }
                (&ResponseCodeEnum::ContractBytecodeEmpty,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractBytecodeEmpty")
                }
                (&ResponseCodeEnum::InvalidInitialBalance,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidInitialBalance")
                }
                (&ResponseCodeEnum::InvalidReceiveRecordThreshold,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidReceiveRecordThreshold")
                }
                (&ResponseCodeEnum::InvalidSendRecordThreshold,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidSendRecordThreshold")
                }
                (&ResponseCodeEnum::AccountIsNotGenesisAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "AccountIsNotGenesisAccount")
                }
                (&ResponseCodeEnum::PayerAccountUnauthorized,) => {
                    ::core::fmt::Formatter::write_str(f, "PayerAccountUnauthorized")
                }
                (&ResponseCodeEnum::InvalidFreezeTransactionBody,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidFreezeTransactionBody")
                }
                (&ResponseCodeEnum::FreezeTransactionBodyNotFound,) => {
                    ::core::fmt::Formatter::write_str(f, "FreezeTransactionBodyNotFound")
                }
                (&ResponseCodeEnum::TransferListSizeLimitExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "TransferListSizeLimitExceeded")
                }
                (&ResponseCodeEnum::ResultSizeLimitExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "ResultSizeLimitExceeded")
                }
                (&ResponseCodeEnum::NotSpecialAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "NotSpecialAccount")
                }
                (&ResponseCodeEnum::ContractNegativeGas,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractNegativeGas")
                }
                (&ResponseCodeEnum::ContractNegativeValue,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractNegativeValue")
                }
                (&ResponseCodeEnum::InvalidFeeFile,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidFeeFile")
                }
                (&ResponseCodeEnum::InvalidExchangeRateFile,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidExchangeRateFile")
                }
                (&ResponseCodeEnum::InsufficientLocalCallGas,) => {
                    ::core::fmt::Formatter::write_str(f, "InsufficientLocalCallGas")
                }
                (&ResponseCodeEnum::EntityNotAllowedToDelete,) => {
                    ::core::fmt::Formatter::write_str(f, "EntityNotAllowedToDelete")
                }
                (&ResponseCodeEnum::AuthorizationFailed,) => {
                    ::core::fmt::Formatter::write_str(f, "AuthorizationFailed")
                }
                (&ResponseCodeEnum::FileUploadedProtoInvalid,) => {
                    ::core::fmt::Formatter::write_str(f, "FileUploadedProtoInvalid")
                }
                (&ResponseCodeEnum::FileUploadedProtoNotSavedToDisk,) => {
                    ::core::fmt::Formatter::write_str(f, "FileUploadedProtoNotSavedToDisk")
                }
                (&ResponseCodeEnum::FeeScheduleFilePartUploaded,) => {
                    ::core::fmt::Formatter::write_str(f, "FeeScheduleFilePartUploaded")
                }
                (&ResponseCodeEnum::ExchangeRateChangeLimitExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "ExchangeRateChangeLimitExceeded")
                }
                (&ResponseCodeEnum::MaxContractStorageExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "MaxContractStorageExceeded")
                }
                (&ResponseCodeEnum::TransferAccountSameAsDeleteAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "TransferAccountSameAsDeleteAccount")
                }
                (&ResponseCodeEnum::TotalLedgerBalanceInvalid,) => {
                    ::core::fmt::Formatter::write_str(f, "TotalLedgerBalanceInvalid")
                }
                (&ResponseCodeEnum::ExpirationReductionNotAllowed,) => {
                    ::core::fmt::Formatter::write_str(f, "ExpirationReductionNotAllowed")
                }
                (&ResponseCodeEnum::MaxGasLimitExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "MaxGasLimitExceeded")
                }
                (&ResponseCodeEnum::MaxFileSizeExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "MaxFileSizeExceeded")
                }
                (&ResponseCodeEnum::ReceiverSigRequired,) => {
                    ::core::fmt::Formatter::write_str(f, "ReceiverSigRequired")
                }
                (&ResponseCodeEnum::InvalidTopicId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTopicId")
                }
                (&ResponseCodeEnum::InvalidAdminKey,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidAdminKey")
                }
                (&ResponseCodeEnum::InvalidSubmitKey,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidSubmitKey")
                }
                (&ResponseCodeEnum::Unauthorized,) => {
                    ::core::fmt::Formatter::write_str(f, "Unauthorized")
                }
                (&ResponseCodeEnum::InvalidTopicMessage,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTopicMessage")
                }
                (&ResponseCodeEnum::InvalidAutorenewAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidAutorenewAccount")
                }
                (&ResponseCodeEnum::AutorenewAccountNotAllowed,) => {
                    ::core::fmt::Formatter::write_str(f, "AutorenewAccountNotAllowed")
                }
                (&ResponseCodeEnum::TopicExpired,) => {
                    ::core::fmt::Formatter::write_str(f, "TopicExpired")
                }
                (&ResponseCodeEnum::InvalidChunkNumber,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidChunkNumber")
                }
                (&ResponseCodeEnum::InvalidChunkTransactionId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidChunkTransactionId")
                }
                (&ResponseCodeEnum::AccountFrozenForToken,) => {
                    ::core::fmt::Formatter::write_str(f, "AccountFrozenForToken")
                }
                (&ResponseCodeEnum::TokensPerAccountLimitExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "TokensPerAccountLimitExceeded")
                }
                (&ResponseCodeEnum::InvalidTokenId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTokenId")
                }
                (&ResponseCodeEnum::InvalidTokenDecimals,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTokenDecimals")
                }
                (&ResponseCodeEnum::InvalidTokenInitialSupply,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTokenInitialSupply")
                }
                (&ResponseCodeEnum::InvalidTreasuryAccountForToken,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTreasuryAccountForToken")
                }
                (&ResponseCodeEnum::InvalidTokenSymbol,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTokenSymbol")
                }
                (&ResponseCodeEnum::TokenHasNoFreezeKey,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenHasNoFreezeKey")
                }
                (&ResponseCodeEnum::TransfersNotZeroSumForToken,) => {
                    ::core::fmt::Formatter::write_str(f, "TransfersNotZeroSumForToken")
                }
                (&ResponseCodeEnum::MissingTokenSymbol,) => {
                    ::core::fmt::Formatter::write_str(f, "MissingTokenSymbol")
                }
                (&ResponseCodeEnum::TokenSymbolTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenSymbolTooLong")
                }
                (&ResponseCodeEnum::AccountKycNotGrantedForToken,) => {
                    ::core::fmt::Formatter::write_str(f, "AccountKycNotGrantedForToken")
                }
                (&ResponseCodeEnum::TokenHasNoKycKey,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenHasNoKycKey")
                }
                (&ResponseCodeEnum::InsufficientTokenBalance,) => {
                    ::core::fmt::Formatter::write_str(f, "InsufficientTokenBalance")
                }
                (&ResponseCodeEnum::TokenWasDeleted,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenWasDeleted")
                }
                (&ResponseCodeEnum::TokenHasNoSupplyKey,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenHasNoSupplyKey")
                }
                (&ResponseCodeEnum::TokenHasNoWipeKey,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenHasNoWipeKey")
                }
                (&ResponseCodeEnum::InvalidTokenMintAmount,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTokenMintAmount")
                }
                (&ResponseCodeEnum::InvalidTokenBurnAmount,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTokenBurnAmount")
                }
                (&ResponseCodeEnum::TokenNotAssociatedToAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenNotAssociatedToAccount")
                }
                (&ResponseCodeEnum::CannotWipeTokenTreasuryAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "CannotWipeTokenTreasuryAccount")
                }
                (&ResponseCodeEnum::InvalidKycKey,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidKycKey")
                }
                (&ResponseCodeEnum::InvalidWipeKey,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidWipeKey")
                }
                (&ResponseCodeEnum::InvalidFreezeKey,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidFreezeKey")
                }
                (&ResponseCodeEnum::InvalidSupplyKey,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidSupplyKey")
                }
                (&ResponseCodeEnum::MissingTokenName,) => {
                    ::core::fmt::Formatter::write_str(f, "MissingTokenName")
                }
                (&ResponseCodeEnum::TokenNameTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenNameTooLong")
                }
                (&ResponseCodeEnum::InvalidWipingAmount,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidWipingAmount")
                }
                (&ResponseCodeEnum::TokenIsImmutable,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenIsImmutable")
                }
                (&ResponseCodeEnum::TokenAlreadyAssociatedToAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenAlreadyAssociatedToAccount")
                }
                (&ResponseCodeEnum::TransactionRequiresZeroTokenBalances,) => {
                    ::core::fmt::Formatter::write_str(f, "TransactionRequiresZeroTokenBalances")
                }
                (&ResponseCodeEnum::AccountIsTreasury,) => {
                    ::core::fmt::Formatter::write_str(f, "AccountIsTreasury")
                }
                (&ResponseCodeEnum::TokenIdRepeatedInTokenList,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenIdRepeatedInTokenList")
                }
                (&ResponseCodeEnum::TokenTransferListSizeLimitExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenTransferListSizeLimitExceeded")
                }
                (&ResponseCodeEnum::EmptyTokenTransferBody,) => {
                    ::core::fmt::Formatter::write_str(f, "EmptyTokenTransferBody")
                }
                (&ResponseCodeEnum::EmptyTokenTransferAccountAmounts,) => {
                    ::core::fmt::Formatter::write_str(f, "EmptyTokenTransferAccountAmounts")
                }
                (&ResponseCodeEnum::InvalidScheduleId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidScheduleId")
                }
                (&ResponseCodeEnum::ScheduleIsImmutable,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduleIsImmutable")
                }
                (&ResponseCodeEnum::InvalidSchedulePayerId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidSchedulePayerId")
                }
                (&ResponseCodeEnum::InvalidScheduleAccountId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidScheduleAccountId")
                }
                (&ResponseCodeEnum::NoNewValidSignatures,) => {
                    ::core::fmt::Formatter::write_str(f, "NoNewValidSignatures")
                }
                (&ResponseCodeEnum::UnresolvableRequiredSigners,) => {
                    ::core::fmt::Formatter::write_str(f, "UnresolvableRequiredSigners")
                }
                (&ResponseCodeEnum::ScheduledTransactionNotInWhitelist,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduledTransactionNotInWhitelist")
                }
                (&ResponseCodeEnum::SomeSignaturesWereInvalid,) => {
                    ::core::fmt::Formatter::write_str(f, "SomeSignaturesWereInvalid")
                }
                (&ResponseCodeEnum::TransactionIdFieldNotAllowed,) => {
                    ::core::fmt::Formatter::write_str(f, "TransactionIdFieldNotAllowed")
                }
                (&ResponseCodeEnum::IdenticalScheduleAlreadyCreated,) => {
                    ::core::fmt::Formatter::write_str(f, "IdenticalScheduleAlreadyCreated")
                }
                (&ResponseCodeEnum::InvalidZeroByteInString,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidZeroByteInString")
                }
                (&ResponseCodeEnum::ScheduleAlreadyDeleted,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduleAlreadyDeleted")
                }
                (&ResponseCodeEnum::ScheduleAlreadyExecuted,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduleAlreadyExecuted")
                }
                (&ResponseCodeEnum::MessageSizeTooLarge,) => {
                    ::core::fmt::Formatter::write_str(f, "MessageSizeTooLarge")
                }
                (&ResponseCodeEnum::OperationRepeatedInBucketGroups,) => {
                    ::core::fmt::Formatter::write_str(f, "OperationRepeatedInBucketGroups")
                }
                (&ResponseCodeEnum::BucketCapacityOverflow,) => {
                    ::core::fmt::Formatter::write_str(f, "BucketCapacityOverflow")
                }
                (&ResponseCodeEnum::NodeCapacityNotSufficientForOperation,) => {
                    ::core::fmt::Formatter::write_str(f, "NodeCapacityNotSufficientForOperation")
                }
                (&ResponseCodeEnum::BucketHasNoThrottleGroups,) => {
                    ::core::fmt::Formatter::write_str(f, "BucketHasNoThrottleGroups")
                }
                (&ResponseCodeEnum::ThrottleGroupHasZeroOpsPerSec,) => {
                    ::core::fmt::Formatter::write_str(f, "ThrottleGroupHasZeroOpsPerSec")
                }
                (&ResponseCodeEnum::SuccessButMissingExpectedOperation,) => {
                    ::core::fmt::Formatter::write_str(f, "SuccessButMissingExpectedOperation")
                }
                (&ResponseCodeEnum::UnparseableThrottleDefinitions,) => {
                    ::core::fmt::Formatter::write_str(f, "UnparseableThrottleDefinitions")
                }
                (&ResponseCodeEnum::InvalidThrottleDefinitions,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidThrottleDefinitions")
                }
                (&ResponseCodeEnum::AccountExpiredAndPendingRemoval,) => {
                    ::core::fmt::Formatter::write_str(f, "AccountExpiredAndPendingRemoval")
                }
                (&ResponseCodeEnum::InvalidTokenMaxSupply,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTokenMaxSupply")
                }
                (&ResponseCodeEnum::InvalidTokenNftSerialNumber,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTokenNftSerialNumber")
                }
                (&ResponseCodeEnum::InvalidNftId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidNftId")
                }
                (&ResponseCodeEnum::MetadataTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "MetadataTooLong")
                }
                (&ResponseCodeEnum::BatchSizeLimitExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "BatchSizeLimitExceeded")
                }
                (&ResponseCodeEnum::InvalidQueryRange,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidQueryRange")
                }
                (&ResponseCodeEnum::FractionDividesByZero,) => {
                    ::core::fmt::Formatter::write_str(f, "FractionDividesByZero")
                }
                (&ResponseCodeEnum::InsufficientPayerBalanceForCustomFee,) => {
                    ::core::fmt::Formatter::write_str(f, "InsufficientPayerBalanceForCustomFee")
                }
                (&ResponseCodeEnum::CustomFeesListTooLong,) => {
                    ::core::fmt::Formatter::write_str(f, "CustomFeesListTooLong")
                }
                (&ResponseCodeEnum::InvalidCustomFeeCollector,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidCustomFeeCollector")
                }
                (&ResponseCodeEnum::InvalidTokenIdInCustomFees,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTokenIdInCustomFees")
                }
                (&ResponseCodeEnum::TokenNotAssociatedToFeeCollector,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenNotAssociatedToFeeCollector")
                }
                (&ResponseCodeEnum::TokenMaxSupplyReached,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenMaxSupplyReached")
                }
                (&ResponseCodeEnum::SenderDoesNotOwnNftSerialNo,) => {
                    ::core::fmt::Formatter::write_str(f, "SenderDoesNotOwnNftSerialNo")
                }
                (&ResponseCodeEnum::CustomFeeNotFullySpecified,) => {
                    ::core::fmt::Formatter::write_str(f, "CustomFeeNotFullySpecified")
                }
                (&ResponseCodeEnum::CustomFeeMustBePositive,) => {
                    ::core::fmt::Formatter::write_str(f, "CustomFeeMustBePositive")
                }
                (&ResponseCodeEnum::TokenHasNoFeeScheduleKey,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenHasNoFeeScheduleKey")
                }
                (&ResponseCodeEnum::CustomFeeOutsideNumericRange,) => {
                    ::core::fmt::Formatter::write_str(f, "CustomFeeOutsideNumericRange")
                }
                (&ResponseCodeEnum::RoyaltyFractionCannotExceedOne,) => {
                    ::core::fmt::Formatter::write_str(f, "RoyaltyFractionCannotExceedOne")
                }
                (&ResponseCodeEnum::FractionalFeeMaxAmountLessThanMinAmount,) => {
                    ::core::fmt::Formatter::write_str(f, "FractionalFeeMaxAmountLessThanMinAmount")
                }
                (&ResponseCodeEnum::CustomScheduleAlreadyHasNoFees,) => {
                    ::core::fmt::Formatter::write_str(f, "CustomScheduleAlreadyHasNoFees")
                }
                (&ResponseCodeEnum::CustomFeeDenominationMustBeFungibleCommon,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "CustomFeeDenominationMustBeFungibleCommon",
                    )
                }
                (&ResponseCodeEnum::CustomFractionalFeeOnlyAllowedForFungibleCommon,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "CustomFractionalFeeOnlyAllowedForFungibleCommon",
                    )
                }
                (&ResponseCodeEnum::InvalidCustomFeeScheduleKey,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidCustomFeeScheduleKey")
                }
                (&ResponseCodeEnum::InvalidTokenMintMetadata,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTokenMintMetadata")
                }
                (&ResponseCodeEnum::InvalidTokenBurnMetadata,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTokenBurnMetadata")
                }
                (&ResponseCodeEnum::CurrentTreasuryStillOwnsNfts,) => {
                    ::core::fmt::Formatter::write_str(f, "CurrentTreasuryStillOwnsNfts")
                }
                (&ResponseCodeEnum::AccountStillOwnsNfts,) => {
                    ::core::fmt::Formatter::write_str(f, "AccountStillOwnsNfts")
                }
                (&ResponseCodeEnum::TreasuryMustOwnBurnedNft,) => {
                    ::core::fmt::Formatter::write_str(f, "TreasuryMustOwnBurnedNft")
                }
                (&ResponseCodeEnum::AccountDoesNotOwnWipedNft,) => {
                    ::core::fmt::Formatter::write_str(f, "AccountDoesNotOwnWipedNft")
                }
                (&ResponseCodeEnum::AccountAmountTransfersOnlyAllowedForFungibleCommon,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "AccountAmountTransfersOnlyAllowedForFungibleCommon",
                    )
                }
                (&ResponseCodeEnum::MaxNftsInPriceRegimeHaveBeenMinted,) => {
                    ::core::fmt::Formatter::write_str(f, "MaxNftsInPriceRegimeHaveBeenMinted")
                }
                (&ResponseCodeEnum::PayerAccountDeleted,) => {
                    ::core::fmt::Formatter::write_str(f, "PayerAccountDeleted")
                }
                (&ResponseCodeEnum::CustomFeeChargingExceededMaxRecursionDepth,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "CustomFeeChargingExceededMaxRecursionDepth",
                    )
                }
                (&ResponseCodeEnum::CustomFeeChargingExceededMaxAccountAmounts,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "CustomFeeChargingExceededMaxAccountAmounts",
                    )
                }
                (&ResponseCodeEnum::InsufficientSenderAccountBalanceForCustomFee,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "InsufficientSenderAccountBalanceForCustomFee",
                    )
                }
                (&ResponseCodeEnum::SerialNumberLimitReached,) => {
                    ::core::fmt::Formatter::write_str(f, "SerialNumberLimitReached")
                }
                (&ResponseCodeEnum::CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique",
                    )
                }
                (&ResponseCodeEnum::NoRemainingAutomaticAssociations,) => {
                    ::core::fmt::Formatter::write_str(f, "NoRemainingAutomaticAssociations")
                }
                (&ResponseCodeEnum::ExistingAutomaticAssociationsExceedGivenLimit,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ExistingAutomaticAssociationsExceedGivenLimit",
                    )
                }
                (&ResponseCodeEnum::RequestedNumAutomaticAssociationsExceedsAssociationLimit,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "RequestedNumAutomaticAssociationsExceedsAssociationLimit",
                    )
                }
                (&ResponseCodeEnum::TokenIsPaused,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenIsPaused")
                }
                (&ResponseCodeEnum::TokenHasNoPauseKey,) => {
                    ::core::fmt::Formatter::write_str(f, "TokenHasNoPauseKey")
                }
                (&ResponseCodeEnum::InvalidPauseKey,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidPauseKey")
                }
                (&ResponseCodeEnum::FreezeUpdateFileDoesNotExist,) => {
                    ::core::fmt::Formatter::write_str(f, "FreezeUpdateFileDoesNotExist")
                }
                (&ResponseCodeEnum::FreezeUpdateFileHashDoesNotMatch,) => {
                    ::core::fmt::Formatter::write_str(f, "FreezeUpdateFileHashDoesNotMatch")
                }
                (&ResponseCodeEnum::NoUpgradeHasBeenPrepared,) => {
                    ::core::fmt::Formatter::write_str(f, "NoUpgradeHasBeenPrepared")
                }
                (&ResponseCodeEnum::NoFreezeIsScheduled,) => {
                    ::core::fmt::Formatter::write_str(f, "NoFreezeIsScheduled")
                }
                (&ResponseCodeEnum::UpdateFileHashChangedSincePrepareUpgrade,) => {
                    ::core::fmt::Formatter::write_str(f, "UpdateFileHashChangedSincePrepareUpgrade")
                }
                (&ResponseCodeEnum::FreezeStartTimeMustBeFuture,) => {
                    ::core::fmt::Formatter::write_str(f, "FreezeStartTimeMustBeFuture")
                }
                (&ResponseCodeEnum::PreparedUpdateFileIsImmutable,) => {
                    ::core::fmt::Formatter::write_str(f, "PreparedUpdateFileIsImmutable")
                }
                (&ResponseCodeEnum::FreezeAlreadyScheduled,) => {
                    ::core::fmt::Formatter::write_str(f, "FreezeAlreadyScheduled")
                }
                (&ResponseCodeEnum::FreezeUpgradeInProgress,) => {
                    ::core::fmt::Formatter::write_str(f, "FreezeUpgradeInProgress")
                }
                (&ResponseCodeEnum::UpdateFileIdDoesNotMatchPrepared,) => {
                    ::core::fmt::Formatter::write_str(f, "UpdateFileIdDoesNotMatchPrepared")
                }
                (&ResponseCodeEnum::UpdateFileHashDoesNotMatchPrepared,) => {
                    ::core::fmt::Formatter::write_str(f, "UpdateFileHashDoesNotMatchPrepared")
                }
                (&ResponseCodeEnum::ConsensusGasExhausted,) => {
                    ::core::fmt::Formatter::write_str(f, "ConsensusGasExhausted")
                }
                (&ResponseCodeEnum::RevertedSuccess,) => {
                    ::core::fmt::Formatter::write_str(f, "RevertedSuccess")
                }
                (&ResponseCodeEnum::MaxStorageInPriceRegimeHasBeenUsed,) => {
                    ::core::fmt::Formatter::write_str(f, "MaxStorageInPriceRegimeHasBeenUsed")
                }
                (&ResponseCodeEnum::InvalidAliasKey,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidAliasKey")
                }
                (&ResponseCodeEnum::UnexpectedTokenDecimals,) => {
                    ::core::fmt::Formatter::write_str(f, "UnexpectedTokenDecimals")
                }
                (&ResponseCodeEnum::InvalidProxyAccountId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidProxyAccountId")
                }
                (&ResponseCodeEnum::InvalidTransferAccountId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidTransferAccountId")
                }
                (&ResponseCodeEnum::InvalidFeeCollectorAccountId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidFeeCollectorAccountId")
                }
                (&ResponseCodeEnum::AliasIsImmutable,) => {
                    ::core::fmt::Formatter::write_str(f, "AliasIsImmutable")
                }
                (&ResponseCodeEnum::SpenderAccountSameAsOwner,) => {
                    ::core::fmt::Formatter::write_str(f, "SpenderAccountSameAsOwner")
                }
                (&ResponseCodeEnum::AmountExceedsTokenMaxSupply,) => {
                    ::core::fmt::Formatter::write_str(f, "AmountExceedsTokenMaxSupply")
                }
                (&ResponseCodeEnum::NegativeAllowanceAmount,) => {
                    ::core::fmt::Formatter::write_str(f, "NegativeAllowanceAmount")
                }
                (&ResponseCodeEnum::CannotApproveForAllFungibleCommon,) => {
                    ::core::fmt::Formatter::write_str(f, "CannotApproveForAllFungibleCommon")
                }
                (&ResponseCodeEnum::SpenderDoesNotHaveAllowance,) => {
                    ::core::fmt::Formatter::write_str(f, "SpenderDoesNotHaveAllowance")
                }
                (&ResponseCodeEnum::AmountExceedsAllowance,) => {
                    ::core::fmt::Formatter::write_str(f, "AmountExceedsAllowance")
                }
                (&ResponseCodeEnum::MaxAllowancesExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "MaxAllowancesExceeded")
                }
                (&ResponseCodeEnum::EmptyAllowances,) => {
                    ::core::fmt::Formatter::write_str(f, "EmptyAllowances")
                }
                (&ResponseCodeEnum::SpenderAccountRepeatedInAllowances,) => {
                    ::core::fmt::Formatter::write_str(f, "SpenderAccountRepeatedInAllowances")
                }
                (&ResponseCodeEnum::RepeatedSerialNumsInNftAllowances,) => {
                    ::core::fmt::Formatter::write_str(f, "RepeatedSerialNumsInNftAllowances")
                }
                (&ResponseCodeEnum::FungibleTokenInNftAllowances,) => {
                    ::core::fmt::Formatter::write_str(f, "FungibleTokenInNftAllowances")
                }
                (&ResponseCodeEnum::NftInFungibleTokenAllowances,) => {
                    ::core::fmt::Formatter::write_str(f, "NftInFungibleTokenAllowances")
                }
                (&ResponseCodeEnum::InvalidAllowanceOwnerId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidAllowanceOwnerId")
                }
                (&ResponseCodeEnum::InvalidAllowanceSpenderId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidAllowanceSpenderId")
                }
                (&ResponseCodeEnum::RepeatedAllowancesToDelete,) => {
                    ::core::fmt::Formatter::write_str(f, "RepeatedAllowancesToDelete")
                }
                (&ResponseCodeEnum::InvalidDelegatingSpender,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidDelegatingSpender")
                }
                (&ResponseCodeEnum::DelegatingSpenderCannotGrantApproveForAll,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "DelegatingSpenderCannotGrantApproveForAll",
                    )
                }
                (&ResponseCodeEnum::DelegatingSpenderDoesNotHaveApproveForAll,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "DelegatingSpenderDoesNotHaveApproveForAll",
                    )
                }
                (&ResponseCodeEnum::ScheduleExpirationTimeTooFarInFuture,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduleExpirationTimeTooFarInFuture")
                }
                (&ResponseCodeEnum::ScheduleExpirationTimeMustBeHigherThanConsensusTime,) => {
                    ::core::fmt::Formatter::write_str(
                        f,
                        "ScheduleExpirationTimeMustBeHigherThanConsensusTime",
                    )
                }
                (&ResponseCodeEnum::ScheduleFutureThrottleExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduleFutureThrottleExceeded")
                }
                (&ResponseCodeEnum::ScheduleFutureGasLimitExceeded,) => {
                    ::core::fmt::Formatter::write_str(f, "ScheduleFutureGasLimitExceeded")
                }
                (&ResponseCodeEnum::InvalidEthereumTransaction,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidEthereumTransaction")
                }
                (&ResponseCodeEnum::WrongChainId,) => {
                    ::core::fmt::Formatter::write_str(f, "WrongChainId")
                }
                (&ResponseCodeEnum::WrongNonce,) => {
                    ::core::fmt::Formatter::write_str(f, "WrongNonce")
                }
                (&ResponseCodeEnum::AccessListUnsupported,) => {
                    ::core::fmt::Formatter::write_str(f, "AccessListUnsupported")
                }
                (&ResponseCodeEnum::SchedulePendingExpiration,) => {
                    ::core::fmt::Formatter::write_str(f, "SchedulePendingExpiration")
                }
                (&ResponseCodeEnum::ContractIsTokenTreasury,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractIsTokenTreasury")
                }
                (&ResponseCodeEnum::ContractHasNonZeroTokenBalances,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractHasNonZeroTokenBalances")
                }
                (&ResponseCodeEnum::ContractExpiredAndPendingRemoval,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractExpiredAndPendingRemoval")
                }
                (&ResponseCodeEnum::ContractHasNoAutoRenewAccount,) => {
                    ::core::fmt::Formatter::write_str(f, "ContractHasNoAutoRenewAccount")
                }
                (&ResponseCodeEnum::PermanentRemovalRequiresSystemInitiation,) => {
                    ::core::fmt::Formatter::write_str(f, "PermanentRemovalRequiresSystemInitiation")
                }
                (&ResponseCodeEnum::ProxyAccountIdFieldIsDeprecated,) => {
                    ::core::fmt::Formatter::write_str(f, "ProxyAccountIdFieldIsDeprecated")
                }
                (&ResponseCodeEnum::SelfStakingIsNotAllowed,) => {
                    ::core::fmt::Formatter::write_str(f, "SelfStakingIsNotAllowed")
                }
                (&ResponseCodeEnum::InvalidStakingId,) => {
                    ::core::fmt::Formatter::write_str(f, "InvalidStakingId")
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ResponseCodeEnum {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ResponseCodeEnum {
        #[inline]
        fn eq(&self, other: &ResponseCodeEnum) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for ResponseCodeEnum {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for ResponseCodeEnum {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for ResponseCodeEnum {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self), state),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for ResponseCodeEnum {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ResponseCodeEnum,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    ::core::cmp::PartialOrd::partial_cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for ResponseCodeEnum {
        #[inline]
        fn cmp(&self, other: &ResponseCodeEnum) -> ::core::cmp::Ordering {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi)
                }
            }
        }
    }
    impl ResponseCodeEnum {
        ///Returns `true` if `value` is a variant of `ResponseCodeEnum`.
        pub fn is_valid(value: i32) -> bool {
            match value {
                0 => true,
                1 => true,
                2 => true,
                3 => true,
                4 => true,
                5 => true,
                6 => true,
                7 => true,
                8 => true,
                9 => true,
                10 => true,
                11 => true,
                12 => true,
                13 => true,
                14 => true,
                15 => true,
                16 => true,
                17 => true,
                18 => true,
                19 => true,
                20 => true,
                21 => true,
                22 => true,
                23 => true,
                24 => true,
                25 => true,
                26 => true,
                27 => true,
                28 => true,
                29 => true,
                30 => true,
                31 => true,
                32 => true,
                33 => true,
                34 => true,
                35 => true,
                36 => true,
                37 => true,
                38 => true,
                39 => true,
                40 => true,
                41 => true,
                42 => true,
                43 => true,
                44 => true,
                45 => true,
                46 => true,
                47 => true,
                48 => true,
                49 => true,
                50 => true,
                51 => true,
                52 => true,
                53 => true,
                54 => true,
                55 => true,
                56 => true,
                57 => true,
                58 => true,
                59 => true,
                60 => true,
                61 => true,
                62 => true,
                63 => true,
                64 => true,
                65 => true,
                66 => true,
                67 => true,
                68 => true,
                69 => true,
                70 => true,
                71 => true,
                72 => true,
                73 => true,
                74 => true,
                75 => true,
                76 => true,
                77 => true,
                78 => true,
                79 => true,
                80 => true,
                81 => true,
                82 => true,
                83 => true,
                84 => true,
                85 => true,
                86 => true,
                87 => true,
                88 => true,
                89 => true,
                90 => true,
                91 => true,
                92 => true,
                93 => true,
                94 => true,
                95 => true,
                96 => true,
                97 => true,
                98 => true,
                99 => true,
                100 => true,
                101 => true,
                102 => true,
                103 => true,
                104 => true,
                105 => true,
                106 => true,
                107 => true,
                108 => true,
                110 => true,
                111 => true,
                112 => true,
                113 => true,
                150 => true,
                155 => true,
                156 => true,
                157 => true,
                158 => true,
                159 => true,
                160 => true,
                162 => true,
                163 => true,
                164 => true,
                165 => true,
                166 => true,
                167 => true,
                168 => true,
                169 => true,
                170 => true,
                171 => true,
                172 => true,
                173 => true,
                174 => true,
                175 => true,
                176 => true,
                177 => true,
                178 => true,
                179 => true,
                180 => true,
                181 => true,
                182 => true,
                183 => true,
                184 => true,
                185 => true,
                186 => true,
                187 => true,
                188 => true,
                189 => true,
                190 => true,
                191 => true,
                192 => true,
                193 => true,
                194 => true,
                195 => true,
                196 => true,
                197 => true,
                198 => true,
                199 => true,
                200 => true,
                201 => true,
                202 => true,
                203 => true,
                204 => true,
                205 => true,
                206 => true,
                207 => true,
                208 => true,
                209 => true,
                210 => true,
                211 => true,
                212 => true,
                213 => true,
                214 => true,
                215 => true,
                216 => true,
                217 => true,
                218 => true,
                219 => true,
                220 => true,
                221 => true,
                222 => true,
                223 => true,
                224 => true,
                225 => true,
                226 => true,
                227 => true,
                228 => true,
                229 => true,
                230 => true,
                231 => true,
                232 => true,
                233 => true,
                234 => true,
                235 => true,
                236 => true,
                237 => true,
                238 => true,
                239 => true,
                240 => true,
                241 => true,
                242 => true,
                243 => true,
                244 => true,
                245 => true,
                246 => true,
                247 => true,
                248 => true,
                249 => true,
                250 => true,
                251 => true,
                252 => true,
                253 => true,
                254 => true,
                255 => true,
                256 => true,
                257 => true,
                258 => true,
                259 => true,
                260 => true,
                261 => true,
                262 => true,
                263 => true,
                264 => true,
                265 => true,
                266 => true,
                267 => true,
                268 => true,
                269 => true,
                270 => true,
                271 => true,
                272 => true,
                273 => true,
                274 => true,
                275 => true,
                276 => true,
                277 => true,
                278 => true,
                279 => true,
                280 => true,
                281 => true,
                282 => true,
                283 => true,
                284 => true,
                285 => true,
                286 => true,
                287 => true,
                288 => true,
                289 => true,
                290 => true,
                291 => true,
                292 => true,
                293 => true,
                294 => true,
                295 => true,
                296 => true,
                297 => true,
                298 => true,
                299 => true,
                300 => true,
                301 => true,
                302 => true,
                303 => true,
                304 => true,
                305 => true,
                306 => true,
                307 => true,
                308 => true,
                309 => true,
                310 => true,
                311 => true,
                312 => true,
                313 => true,
                314 => true,
                315 => true,
                316 => true,
                317 => true,
                318 => true,
                319 => true,
                320 => true,
                321 => true,
                322 => true,
                _ => false,
            }
        }
        ///Converts an `i32` to a `ResponseCodeEnum`, or `None` if `value` is not a valid variant.
        pub fn from_i32(value: i32) -> ::core::option::Option<ResponseCodeEnum> {
            match value {
                0 => ::core::option::Option::Some(ResponseCodeEnum::Ok),
                1 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTransaction),
                2 => ::core::option::Option::Some(ResponseCodeEnum::PayerAccountNotFound),
                3 => ::core::option::Option::Some(ResponseCodeEnum::InvalidNodeAccount),
                4 => ::core::option::Option::Some(ResponseCodeEnum::TransactionExpired),
                5 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTransactionStart),
                6 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTransactionDuration),
                7 => ::core::option::Option::Some(ResponseCodeEnum::InvalidSignature),
                8 => ::core::option::Option::Some(ResponseCodeEnum::MemoTooLong),
                9 => ::core::option::Option::Some(ResponseCodeEnum::InsufficientTxFee),
                10 => ::core::option::Option::Some(ResponseCodeEnum::InsufficientPayerBalance),
                11 => ::core::option::Option::Some(ResponseCodeEnum::DuplicateTransaction),
                12 => ::core::option::Option::Some(ResponseCodeEnum::Busy),
                13 => ::core::option::Option::Some(ResponseCodeEnum::NotSupported),
                14 => ::core::option::Option::Some(ResponseCodeEnum::InvalidFileId),
                15 => ::core::option::Option::Some(ResponseCodeEnum::InvalidAccountId),
                16 => ::core::option::Option::Some(ResponseCodeEnum::InvalidContractId),
                17 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTransactionId),
                18 => ::core::option::Option::Some(ResponseCodeEnum::ReceiptNotFound),
                19 => ::core::option::Option::Some(ResponseCodeEnum::RecordNotFound),
                20 => ::core::option::Option::Some(ResponseCodeEnum::InvalidSolidityId),
                21 => ::core::option::Option::Some(ResponseCodeEnum::Unknown),
                22 => ::core::option::Option::Some(ResponseCodeEnum::Success),
                23 => ::core::option::Option::Some(ResponseCodeEnum::FailInvalid),
                24 => ::core::option::Option::Some(ResponseCodeEnum::FailFee),
                25 => ::core::option::Option::Some(ResponseCodeEnum::FailBalance),
                26 => ::core::option::Option::Some(ResponseCodeEnum::KeyRequired),
                27 => ::core::option::Option::Some(ResponseCodeEnum::BadEncoding),
                28 => ::core::option::Option::Some(ResponseCodeEnum::InsufficientAccountBalance),
                29 => ::core::option::Option::Some(ResponseCodeEnum::InvalidSolidityAddress),
                30 => ::core::option::Option::Some(ResponseCodeEnum::InsufficientGas),
                31 => ::core::option::Option::Some(ResponseCodeEnum::ContractSizeLimitExceeded),
                32 => {
                    ::core::option::Option::Some(ResponseCodeEnum::LocalCallModificationException)
                }
                33 => ::core::option::Option::Some(ResponseCodeEnum::ContractRevertExecuted),
                34 => ::core::option::Option::Some(ResponseCodeEnum::ContractExecutionException),
                35 => ::core::option::Option::Some(ResponseCodeEnum::InvalidReceivingNodeAccount),
                36 => ::core::option::Option::Some(ResponseCodeEnum::MissingQueryHeader),
                37 => ::core::option::Option::Some(ResponseCodeEnum::AccountUpdateFailed),
                38 => ::core::option::Option::Some(ResponseCodeEnum::InvalidKeyEncoding),
                39 => ::core::option::Option::Some(ResponseCodeEnum::NullSolidityAddress),
                40 => ::core::option::Option::Some(ResponseCodeEnum::ContractUpdateFailed),
                41 => ::core::option::Option::Some(ResponseCodeEnum::InvalidQueryHeader),
                42 => ::core::option::Option::Some(ResponseCodeEnum::InvalidFeeSubmitted),
                43 => ::core::option::Option::Some(ResponseCodeEnum::InvalidPayerSignature),
                44 => ::core::option::Option::Some(ResponseCodeEnum::KeyNotProvided),
                45 => ::core::option::Option::Some(ResponseCodeEnum::InvalidExpirationTime),
                46 => ::core::option::Option::Some(ResponseCodeEnum::NoWaclKey),
                47 => ::core::option::Option::Some(ResponseCodeEnum::FileContentEmpty),
                48 => ::core::option::Option::Some(ResponseCodeEnum::InvalidAccountAmounts),
                49 => ::core::option::Option::Some(ResponseCodeEnum::EmptyTransactionBody),
                50 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTransactionBody),
                51 => ::core::option::Option::Some(
                    ResponseCodeEnum::InvalidSignatureTypeMismatchingKey,
                ),
                52 => ::core::option::Option::Some(
                    ResponseCodeEnum::InvalidSignatureCountMismatchingKey,
                ),
                53 => ::core::option::Option::Some(ResponseCodeEnum::EmptyLiveHashBody),
                54 => ::core::option::Option::Some(ResponseCodeEnum::EmptyLiveHash),
                55 => ::core::option::Option::Some(ResponseCodeEnum::EmptyLiveHashKeys),
                56 => ::core::option::Option::Some(ResponseCodeEnum::InvalidLiveHashSize),
                57 => ::core::option::Option::Some(ResponseCodeEnum::EmptyQueryBody),
                58 => ::core::option::Option::Some(ResponseCodeEnum::EmptyLiveHashQuery),
                59 => ::core::option::Option::Some(ResponseCodeEnum::LiveHashNotFound),
                60 => ::core::option::Option::Some(ResponseCodeEnum::AccountIdDoesNotExist),
                61 => ::core::option::Option::Some(ResponseCodeEnum::LiveHashAlreadyExists),
                62 => ::core::option::Option::Some(ResponseCodeEnum::InvalidFileWacl),
                63 => ::core::option::Option::Some(ResponseCodeEnum::SerializationFailed),
                64 => ::core::option::Option::Some(ResponseCodeEnum::TransactionOversize),
                65 => ::core::option::Option::Some(ResponseCodeEnum::TransactionTooManyLayers),
                66 => ::core::option::Option::Some(ResponseCodeEnum::ContractDeleted),
                67 => ::core::option::Option::Some(ResponseCodeEnum::PlatformNotActive),
                68 => ::core::option::Option::Some(ResponseCodeEnum::KeyPrefixMismatch),
                69 => ::core::option::Option::Some(ResponseCodeEnum::PlatformTransactionNotCreated),
                70 => ::core::option::Option::Some(ResponseCodeEnum::InvalidRenewalPeriod),
                71 => ::core::option::Option::Some(ResponseCodeEnum::InvalidPayerAccountId),
                72 => ::core::option::Option::Some(ResponseCodeEnum::AccountDeleted),
                73 => ::core::option::Option::Some(ResponseCodeEnum::FileDeleted),
                74 => {
                    ::core::option::Option::Some(ResponseCodeEnum::AccountRepeatedInAccountAmounts)
                }
                75 => ::core::option::Option::Some(ResponseCodeEnum::SettingNegativeAccountBalance),
                76 => ::core::option::Option::Some(ResponseCodeEnum::ObtainerRequired),
                77 => ::core::option::Option::Some(ResponseCodeEnum::ObtainerSameContractId),
                78 => ::core::option::Option::Some(ResponseCodeEnum::ObtainerDoesNotExist),
                79 => ::core::option::Option::Some(ResponseCodeEnum::ModifyingImmutableContract),
                80 => ::core::option::Option::Some(ResponseCodeEnum::FileSystemException),
                81 => ::core::option::Option::Some(ResponseCodeEnum::AutorenewDurationNotInRange),
                82 => ::core::option::Option::Some(ResponseCodeEnum::ErrorDecodingBytestring),
                83 => ::core::option::Option::Some(ResponseCodeEnum::ContractFileEmpty),
                84 => ::core::option::Option::Some(ResponseCodeEnum::ContractBytecodeEmpty),
                85 => ::core::option::Option::Some(ResponseCodeEnum::InvalidInitialBalance),
                86 => ::core::option::Option::Some(ResponseCodeEnum::InvalidReceiveRecordThreshold),
                87 => ::core::option::Option::Some(ResponseCodeEnum::InvalidSendRecordThreshold),
                88 => ::core::option::Option::Some(ResponseCodeEnum::AccountIsNotGenesisAccount),
                89 => ::core::option::Option::Some(ResponseCodeEnum::PayerAccountUnauthorized),
                90 => ::core::option::Option::Some(ResponseCodeEnum::InvalidFreezeTransactionBody),
                91 => ::core::option::Option::Some(ResponseCodeEnum::FreezeTransactionBodyNotFound),
                92 => ::core::option::Option::Some(ResponseCodeEnum::TransferListSizeLimitExceeded),
                93 => ::core::option::Option::Some(ResponseCodeEnum::ResultSizeLimitExceeded),
                94 => ::core::option::Option::Some(ResponseCodeEnum::NotSpecialAccount),
                95 => ::core::option::Option::Some(ResponseCodeEnum::ContractNegativeGas),
                96 => ::core::option::Option::Some(ResponseCodeEnum::ContractNegativeValue),
                97 => ::core::option::Option::Some(ResponseCodeEnum::InvalidFeeFile),
                98 => ::core::option::Option::Some(ResponseCodeEnum::InvalidExchangeRateFile),
                99 => ::core::option::Option::Some(ResponseCodeEnum::InsufficientLocalCallGas),
                100 => ::core::option::Option::Some(ResponseCodeEnum::EntityNotAllowedToDelete),
                101 => ::core::option::Option::Some(ResponseCodeEnum::AuthorizationFailed),
                102 => ::core::option::Option::Some(ResponseCodeEnum::FileUploadedProtoInvalid),
                103 => {
                    ::core::option::Option::Some(ResponseCodeEnum::FileUploadedProtoNotSavedToDisk)
                }
                104 => ::core::option::Option::Some(ResponseCodeEnum::FeeScheduleFilePartUploaded),
                105 => {
                    ::core::option::Option::Some(ResponseCodeEnum::ExchangeRateChangeLimitExceeded)
                }
                106 => ::core::option::Option::Some(ResponseCodeEnum::MaxContractStorageExceeded),
                107 => ::core::option::Option::Some(
                    ResponseCodeEnum::TransferAccountSameAsDeleteAccount,
                ),
                108 => ::core::option::Option::Some(ResponseCodeEnum::TotalLedgerBalanceInvalid),
                110 => {
                    ::core::option::Option::Some(ResponseCodeEnum::ExpirationReductionNotAllowed)
                }
                111 => ::core::option::Option::Some(ResponseCodeEnum::MaxGasLimitExceeded),
                112 => ::core::option::Option::Some(ResponseCodeEnum::MaxFileSizeExceeded),
                113 => ::core::option::Option::Some(ResponseCodeEnum::ReceiverSigRequired),
                150 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTopicId),
                155 => ::core::option::Option::Some(ResponseCodeEnum::InvalidAdminKey),
                156 => ::core::option::Option::Some(ResponseCodeEnum::InvalidSubmitKey),
                157 => ::core::option::Option::Some(ResponseCodeEnum::Unauthorized),
                158 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTopicMessage),
                159 => ::core::option::Option::Some(ResponseCodeEnum::InvalidAutorenewAccount),
                160 => ::core::option::Option::Some(ResponseCodeEnum::AutorenewAccountNotAllowed),
                162 => ::core::option::Option::Some(ResponseCodeEnum::TopicExpired),
                163 => ::core::option::Option::Some(ResponseCodeEnum::InvalidChunkNumber),
                164 => ::core::option::Option::Some(ResponseCodeEnum::InvalidChunkTransactionId),
                165 => ::core::option::Option::Some(ResponseCodeEnum::AccountFrozenForToken),
                166 => {
                    ::core::option::Option::Some(ResponseCodeEnum::TokensPerAccountLimitExceeded)
                }
                167 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTokenId),
                168 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTokenDecimals),
                169 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTokenInitialSupply),
                170 => {
                    ::core::option::Option::Some(ResponseCodeEnum::InvalidTreasuryAccountForToken)
                }
                171 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTokenSymbol),
                172 => ::core::option::Option::Some(ResponseCodeEnum::TokenHasNoFreezeKey),
                173 => ::core::option::Option::Some(ResponseCodeEnum::TransfersNotZeroSumForToken),
                174 => ::core::option::Option::Some(ResponseCodeEnum::MissingTokenSymbol),
                175 => ::core::option::Option::Some(ResponseCodeEnum::TokenSymbolTooLong),
                176 => ::core::option::Option::Some(ResponseCodeEnum::AccountKycNotGrantedForToken),
                177 => ::core::option::Option::Some(ResponseCodeEnum::TokenHasNoKycKey),
                178 => ::core::option::Option::Some(ResponseCodeEnum::InsufficientTokenBalance),
                179 => ::core::option::Option::Some(ResponseCodeEnum::TokenWasDeleted),
                180 => ::core::option::Option::Some(ResponseCodeEnum::TokenHasNoSupplyKey),
                181 => ::core::option::Option::Some(ResponseCodeEnum::TokenHasNoWipeKey),
                182 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTokenMintAmount),
                183 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTokenBurnAmount),
                184 => ::core::option::Option::Some(ResponseCodeEnum::TokenNotAssociatedToAccount),
                185 => {
                    ::core::option::Option::Some(ResponseCodeEnum::CannotWipeTokenTreasuryAccount)
                }
                186 => ::core::option::Option::Some(ResponseCodeEnum::InvalidKycKey),
                187 => ::core::option::Option::Some(ResponseCodeEnum::InvalidWipeKey),
                188 => ::core::option::Option::Some(ResponseCodeEnum::InvalidFreezeKey),
                189 => ::core::option::Option::Some(ResponseCodeEnum::InvalidSupplyKey),
                190 => ::core::option::Option::Some(ResponseCodeEnum::MissingTokenName),
                191 => ::core::option::Option::Some(ResponseCodeEnum::TokenNameTooLong),
                192 => ::core::option::Option::Some(ResponseCodeEnum::InvalidWipingAmount),
                193 => ::core::option::Option::Some(ResponseCodeEnum::TokenIsImmutable),
                194 => {
                    ::core::option::Option::Some(ResponseCodeEnum::TokenAlreadyAssociatedToAccount)
                }
                195 => ::core::option::Option::Some(
                    ResponseCodeEnum::TransactionRequiresZeroTokenBalances,
                ),
                196 => ::core::option::Option::Some(ResponseCodeEnum::AccountIsTreasury),
                197 => ::core::option::Option::Some(ResponseCodeEnum::TokenIdRepeatedInTokenList),
                198 => ::core::option::Option::Some(
                    ResponseCodeEnum::TokenTransferListSizeLimitExceeded,
                ),
                199 => ::core::option::Option::Some(ResponseCodeEnum::EmptyTokenTransferBody),
                200 => {
                    ::core::option::Option::Some(ResponseCodeEnum::EmptyTokenTransferAccountAmounts)
                }
                201 => ::core::option::Option::Some(ResponseCodeEnum::InvalidScheduleId),
                202 => ::core::option::Option::Some(ResponseCodeEnum::ScheduleIsImmutable),
                203 => ::core::option::Option::Some(ResponseCodeEnum::InvalidSchedulePayerId),
                204 => ::core::option::Option::Some(ResponseCodeEnum::InvalidScheduleAccountId),
                205 => ::core::option::Option::Some(ResponseCodeEnum::NoNewValidSignatures),
                206 => ::core::option::Option::Some(ResponseCodeEnum::UnresolvableRequiredSigners),
                207 => ::core::option::Option::Some(
                    ResponseCodeEnum::ScheduledTransactionNotInWhitelist,
                ),
                208 => ::core::option::Option::Some(ResponseCodeEnum::SomeSignaturesWereInvalid),
                209 => ::core::option::Option::Some(ResponseCodeEnum::TransactionIdFieldNotAllowed),
                210 => {
                    ::core::option::Option::Some(ResponseCodeEnum::IdenticalScheduleAlreadyCreated)
                }
                211 => ::core::option::Option::Some(ResponseCodeEnum::InvalidZeroByteInString),
                212 => ::core::option::Option::Some(ResponseCodeEnum::ScheduleAlreadyDeleted),
                213 => ::core::option::Option::Some(ResponseCodeEnum::ScheduleAlreadyExecuted),
                214 => ::core::option::Option::Some(ResponseCodeEnum::MessageSizeTooLarge),
                215 => {
                    ::core::option::Option::Some(ResponseCodeEnum::OperationRepeatedInBucketGroups)
                }
                216 => ::core::option::Option::Some(ResponseCodeEnum::BucketCapacityOverflow),
                217 => ::core::option::Option::Some(
                    ResponseCodeEnum::NodeCapacityNotSufficientForOperation,
                ),
                218 => ::core::option::Option::Some(ResponseCodeEnum::BucketHasNoThrottleGroups),
                219 => {
                    ::core::option::Option::Some(ResponseCodeEnum::ThrottleGroupHasZeroOpsPerSec)
                }
                220 => ::core::option::Option::Some(
                    ResponseCodeEnum::SuccessButMissingExpectedOperation,
                ),
                221 => {
                    ::core::option::Option::Some(ResponseCodeEnum::UnparseableThrottleDefinitions)
                }
                222 => ::core::option::Option::Some(ResponseCodeEnum::InvalidThrottleDefinitions),
                223 => {
                    ::core::option::Option::Some(ResponseCodeEnum::AccountExpiredAndPendingRemoval)
                }
                224 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTokenMaxSupply),
                225 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTokenNftSerialNumber),
                226 => ::core::option::Option::Some(ResponseCodeEnum::InvalidNftId),
                227 => ::core::option::Option::Some(ResponseCodeEnum::MetadataTooLong),
                228 => ::core::option::Option::Some(ResponseCodeEnum::BatchSizeLimitExceeded),
                229 => ::core::option::Option::Some(ResponseCodeEnum::InvalidQueryRange),
                230 => ::core::option::Option::Some(ResponseCodeEnum::FractionDividesByZero),
                231 => ::core::option::Option::Some(
                    ResponseCodeEnum::InsufficientPayerBalanceForCustomFee,
                ),
                232 => ::core::option::Option::Some(ResponseCodeEnum::CustomFeesListTooLong),
                233 => ::core::option::Option::Some(ResponseCodeEnum::InvalidCustomFeeCollector),
                234 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTokenIdInCustomFees),
                235 => {
                    ::core::option::Option::Some(ResponseCodeEnum::TokenNotAssociatedToFeeCollector)
                }
                236 => ::core::option::Option::Some(ResponseCodeEnum::TokenMaxSupplyReached),
                237 => ::core::option::Option::Some(ResponseCodeEnum::SenderDoesNotOwnNftSerialNo),
                238 => ::core::option::Option::Some(ResponseCodeEnum::CustomFeeNotFullySpecified),
                239 => ::core::option::Option::Some(ResponseCodeEnum::CustomFeeMustBePositive),
                240 => ::core::option::Option::Some(ResponseCodeEnum::TokenHasNoFeeScheduleKey),
                241 => ::core::option::Option::Some(ResponseCodeEnum::CustomFeeOutsideNumericRange),
                242 => {
                    ::core::option::Option::Some(ResponseCodeEnum::RoyaltyFractionCannotExceedOne)
                }
                243 => ::core::option::Option::Some(
                    ResponseCodeEnum::FractionalFeeMaxAmountLessThanMinAmount,
                ),
                244 => {
                    ::core::option::Option::Some(ResponseCodeEnum::CustomScheduleAlreadyHasNoFees)
                }
                245 => ::core::option::Option::Some(
                    ResponseCodeEnum::CustomFeeDenominationMustBeFungibleCommon,
                ),
                246 => ::core::option::Option::Some(
                    ResponseCodeEnum::CustomFractionalFeeOnlyAllowedForFungibleCommon,
                ),
                247 => ::core::option::Option::Some(ResponseCodeEnum::InvalidCustomFeeScheduleKey),
                248 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTokenMintMetadata),
                249 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTokenBurnMetadata),
                250 => ::core::option::Option::Some(ResponseCodeEnum::CurrentTreasuryStillOwnsNfts),
                251 => ::core::option::Option::Some(ResponseCodeEnum::AccountStillOwnsNfts),
                252 => ::core::option::Option::Some(ResponseCodeEnum::TreasuryMustOwnBurnedNft),
                253 => ::core::option::Option::Some(ResponseCodeEnum::AccountDoesNotOwnWipedNft),
                254 => ::core::option::Option::Some(
                    ResponseCodeEnum::AccountAmountTransfersOnlyAllowedForFungibleCommon,
                ),
                255 => ::core::option::Option::Some(
                    ResponseCodeEnum::MaxNftsInPriceRegimeHaveBeenMinted,
                ),
                256 => ::core::option::Option::Some(ResponseCodeEnum::PayerAccountDeleted),
                257 => ::core::option::Option::Some(
                    ResponseCodeEnum::CustomFeeChargingExceededMaxRecursionDepth,
                ),
                258 => ::core::option::Option::Some(
                    ResponseCodeEnum::CustomFeeChargingExceededMaxAccountAmounts,
                ),
                259 => ::core::option::Option::Some(
                    ResponseCodeEnum::InsufficientSenderAccountBalanceForCustomFee,
                ),
                260 => ::core::option::Option::Some(ResponseCodeEnum::SerialNumberLimitReached),
                261 => ::core::option::Option::Some(
                    ResponseCodeEnum::CustomRoyaltyFeeOnlyAllowedForNonFungibleUnique,
                ),
                262 => {
                    ::core::option::Option::Some(ResponseCodeEnum::NoRemainingAutomaticAssociations)
                }
                263 => ::core::option::Option::Some(
                    ResponseCodeEnum::ExistingAutomaticAssociationsExceedGivenLimit,
                ),
                264 => ::core::option::Option::Some(
                    ResponseCodeEnum::RequestedNumAutomaticAssociationsExceedsAssociationLimit,
                ),
                265 => ::core::option::Option::Some(ResponseCodeEnum::TokenIsPaused),
                266 => ::core::option::Option::Some(ResponseCodeEnum::TokenHasNoPauseKey),
                267 => ::core::option::Option::Some(ResponseCodeEnum::InvalidPauseKey),
                268 => ::core::option::Option::Some(ResponseCodeEnum::FreezeUpdateFileDoesNotExist),
                269 => {
                    ::core::option::Option::Some(ResponseCodeEnum::FreezeUpdateFileHashDoesNotMatch)
                }
                270 => ::core::option::Option::Some(ResponseCodeEnum::NoUpgradeHasBeenPrepared),
                271 => ::core::option::Option::Some(ResponseCodeEnum::NoFreezeIsScheduled),
                272 => ::core::option::Option::Some(
                    ResponseCodeEnum::UpdateFileHashChangedSincePrepareUpgrade,
                ),
                273 => ::core::option::Option::Some(ResponseCodeEnum::FreezeStartTimeMustBeFuture),
                274 => {
                    ::core::option::Option::Some(ResponseCodeEnum::PreparedUpdateFileIsImmutable)
                }
                275 => ::core::option::Option::Some(ResponseCodeEnum::FreezeAlreadyScheduled),
                276 => ::core::option::Option::Some(ResponseCodeEnum::FreezeUpgradeInProgress),
                277 => {
                    ::core::option::Option::Some(ResponseCodeEnum::UpdateFileIdDoesNotMatchPrepared)
                }
                278 => ::core::option::Option::Some(
                    ResponseCodeEnum::UpdateFileHashDoesNotMatchPrepared,
                ),
                279 => ::core::option::Option::Some(ResponseCodeEnum::ConsensusGasExhausted),
                280 => ::core::option::Option::Some(ResponseCodeEnum::RevertedSuccess),
                281 => ::core::option::Option::Some(
                    ResponseCodeEnum::MaxStorageInPriceRegimeHasBeenUsed,
                ),
                282 => ::core::option::Option::Some(ResponseCodeEnum::InvalidAliasKey),
                283 => ::core::option::Option::Some(ResponseCodeEnum::UnexpectedTokenDecimals),
                284 => ::core::option::Option::Some(ResponseCodeEnum::InvalidProxyAccountId),
                285 => ::core::option::Option::Some(ResponseCodeEnum::InvalidTransferAccountId),
                286 => ::core::option::Option::Some(ResponseCodeEnum::InvalidFeeCollectorAccountId),
                287 => ::core::option::Option::Some(ResponseCodeEnum::AliasIsImmutable),
                288 => ::core::option::Option::Some(ResponseCodeEnum::SpenderAccountSameAsOwner),
                289 => ::core::option::Option::Some(ResponseCodeEnum::AmountExceedsTokenMaxSupply),
                290 => ::core::option::Option::Some(ResponseCodeEnum::NegativeAllowanceAmount),
                291 => ::core::option::Option::Some(
                    ResponseCodeEnum::CannotApproveForAllFungibleCommon,
                ),
                292 => ::core::option::Option::Some(ResponseCodeEnum::SpenderDoesNotHaveAllowance),
                293 => ::core::option::Option::Some(ResponseCodeEnum::AmountExceedsAllowance),
                294 => ::core::option::Option::Some(ResponseCodeEnum::MaxAllowancesExceeded),
                295 => ::core::option::Option::Some(ResponseCodeEnum::EmptyAllowances),
                296 => ::core::option::Option::Some(
                    ResponseCodeEnum::SpenderAccountRepeatedInAllowances,
                ),
                297 => ::core::option::Option::Some(
                    ResponseCodeEnum::RepeatedSerialNumsInNftAllowances,
                ),
                298 => ::core::option::Option::Some(ResponseCodeEnum::FungibleTokenInNftAllowances),
                299 => ::core::option::Option::Some(ResponseCodeEnum::NftInFungibleTokenAllowances),
                300 => ::core::option::Option::Some(ResponseCodeEnum::InvalidAllowanceOwnerId),
                301 => ::core::option::Option::Some(ResponseCodeEnum::InvalidAllowanceSpenderId),
                302 => ::core::option::Option::Some(ResponseCodeEnum::RepeatedAllowancesToDelete),
                303 => ::core::option::Option::Some(ResponseCodeEnum::InvalidDelegatingSpender),
                304 => ::core::option::Option::Some(
                    ResponseCodeEnum::DelegatingSpenderCannotGrantApproveForAll,
                ),
                305 => ::core::option::Option::Some(
                    ResponseCodeEnum::DelegatingSpenderDoesNotHaveApproveForAll,
                ),
                306 => ::core::option::Option::Some(
                    ResponseCodeEnum::ScheduleExpirationTimeTooFarInFuture,
                ),
                307 => ::core::option::Option::Some(
                    ResponseCodeEnum::ScheduleExpirationTimeMustBeHigherThanConsensusTime,
                ),
                308 => {
                    ::core::option::Option::Some(ResponseCodeEnum::ScheduleFutureThrottleExceeded)
                }
                309 => {
                    ::core::option::Option::Some(ResponseCodeEnum::ScheduleFutureGasLimitExceeded)
                }
                310 => ::core::option::Option::Some(ResponseCodeEnum::InvalidEthereumTransaction),
                311 => ::core::option::Option::Some(ResponseCodeEnum::WrongChainId),
                312 => ::core::option::Option::Some(ResponseCodeEnum::WrongNonce),
                313 => ::core::option::Option::Some(ResponseCodeEnum::AccessListUnsupported),
                314 => ::core::option::Option::Some(ResponseCodeEnum::SchedulePendingExpiration),
                315 => ::core::option::Option::Some(ResponseCodeEnum::ContractIsTokenTreasury),
                316 => {
                    ::core::option::Option::Some(ResponseCodeEnum::ContractHasNonZeroTokenBalances)
                }
                317 => {
                    ::core::option::Option::Some(ResponseCodeEnum::ContractExpiredAndPendingRemoval)
                }
                318 => {
                    ::core::option::Option::Some(ResponseCodeEnum::ContractHasNoAutoRenewAccount)
                }
                319 => ::core::option::Option::Some(
                    ResponseCodeEnum::PermanentRemovalRequiresSystemInitiation,
                ),
                320 => {
                    ::core::option::Option::Some(ResponseCodeEnum::ProxyAccountIdFieldIsDeprecated)
                }
                321 => ::core::option::Option::Some(ResponseCodeEnum::SelfStakingIsNotAllowed),
                322 => ::core::option::Option::Some(ResponseCodeEnum::InvalidStakingId),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl ::core::default::Default for ResponseCodeEnum {
        fn default() -> ResponseCodeEnum {
            ResponseCodeEnum::Ok
        }
    }
    impl ::core::convert::From<ResponseCodeEnum> for i32 {
        fn from(value: ResponseCodeEnum) -> i32 {
            value as i32
        }
    }
    /// When the client sends the node a transaction of any kind, the node replies with this, which
    /// simply says that the transaction passed the precheck (so the node will submit it to the network)
    /// or it failed (so it won't). If the fee offered was insufficient, this will also contain the
    /// amount of the required fee. To learn the consensus result, the client should later obtain a
    /// receipt (free), or can buy a more detailed record (not free).
    pub struct TransactionResponse {
        /// The response code that indicates the current status of the transaction.
        #[prost(enumeration = "ResponseCodeEnum", tag = "1")]
        pub node_transaction_precheck_code: i32,
        /// If the response code was INSUFFICIENT_TX_FEE, the actual transaction fee that would be
        /// required to execute the transaction.
        #[prost(uint64, tag = "2")]
        pub cost: u64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionResponse {
        #[inline]
        fn clone(&self) -> TransactionResponse {
            match *self {
                TransactionResponse {
                    node_transaction_precheck_code: ref __self_0_0,
                    cost: ref __self_0_1,
                } => TransactionResponse {
                    node_transaction_precheck_code: ::core::clone::Clone::clone(&(*__self_0_0)),
                    cost: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionResponse {
        #[inline]
        fn eq(&self, other: &TransactionResponse) -> bool {
            match *other {
                TransactionResponse {
                    node_transaction_precheck_code: ref __self_1_0,
                    cost: ref __self_1_1,
                } => match *self {
                    TransactionResponse {
                        node_transaction_precheck_code: ref __self_0_0,
                        cost: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionResponse) -> bool {
            match *other {
                TransactionResponse {
                    node_transaction_precheck_code: ref __self_1_0,
                    cost: ref __self_1_1,
                } => match *self {
                    TransactionResponse {
                        node_transaction_precheck_code: ref __self_0_0,
                        cost: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TransactionResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.node_transaction_precheck_code != ResponseCodeEnum::default() as i32 {
                ::prost::encoding::int32::encode(1u32, &self.node_transaction_precheck_code, buf);
            }
            if self.cost != 0u64 {
                ::prost::encoding::uint64::encode(2u32, &self.cost, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.node_transaction_precheck_code;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "node_transaction_precheck_code");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.cost;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "cost");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.node_transaction_precheck_code != ResponseCodeEnum::default() as i32 {
                ::prost::encoding::int32::encoded_len(1u32, &self.node_transaction_precheck_code)
            } else {
                0
            } + if self.cost != 0u64 {
                ::prost::encoding::uint64::encoded_len(2u32, &self.cost)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.node_transaction_precheck_code = ResponseCodeEnum::default() as i32;
            self.cost = 0u64;
        }
    }
    impl ::core::default::Default for TransactionResponse {
        fn default() -> Self {
            TransactionResponse {
                node_transaction_precheck_code: ResponseCodeEnum::default() as i32,
                cost: 0u64,
            }
        }
    }
    impl ::core::fmt::Debug for TransactionResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionResponse");
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match ResponseCodeEnum::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.node_transaction_precheck_code)
                };
                builder.field("node_transaction_precheck_code", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.cost)
                };
                builder.field("cost", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl TransactionResponse {
        ///Returns the enum value of `node_transaction_precheck_code`, or the default if the field is set to an invalid enum value.
        pub fn node_transaction_precheck_code(&self) -> ResponseCodeEnum {
            ResponseCodeEnum::from_i32(self.node_transaction_precheck_code)
                .unwrap_or(ResponseCodeEnum::default())
        }
        ///Sets `node_transaction_precheck_code` to the provided enum value.
        pub fn set_node_transaction_precheck_code(&mut self, value: ResponseCodeEnum) {
            self.node_transaction_precheck_code = value as i32;
        }
    }
    /// Every query receives a response containing the QueryResponseHeader. Either or both of the cost
    /// and stateProof fields may be blank, if the responseType didn't ask for the cost or stateProof.
    pub struct ResponseHeader {
        /// Result of fee transaction precheck, saying it passed, or why it failed
        #[prost(enumeration = "ResponseCodeEnum", tag = "1")]
        pub node_transaction_precheck_code: i32,
        /// The requested response is repeated back here, for convenience
        #[prost(enumeration = "ResponseType", tag = "2")]
        pub response_type: i32,
        /// The fee that would be charged to get the requested information (if a cost was requested).
        /// Note: This cost only includes the query fee and does not include the transfer fee(which is
        /// required to execute the transfer transaction to debit the payer account and credit the node
        /// account with query fee)
        #[prost(uint64, tag = "3")]
        pub cost: u64,
        /// The state proof for this information (if a state proof was requested, and is available)
        #[prost(bytes = "vec", tag = "4")]
        pub state_proof: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ResponseHeader {
        #[inline]
        fn clone(&self) -> ResponseHeader {
            match *self {
                ResponseHeader {
                    node_transaction_precheck_code: ref __self_0_0,
                    response_type: ref __self_0_1,
                    cost: ref __self_0_2,
                    state_proof: ref __self_0_3,
                } => ResponseHeader {
                    node_transaction_precheck_code: ::core::clone::Clone::clone(&(*__self_0_0)),
                    response_type: ::core::clone::Clone::clone(&(*__self_0_1)),
                    cost: ::core::clone::Clone::clone(&(*__self_0_2)),
                    state_proof: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ResponseHeader {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ResponseHeader {
        #[inline]
        fn eq(&self, other: &ResponseHeader) -> bool {
            match *other {
                ResponseHeader {
                    node_transaction_precheck_code: ref __self_1_0,
                    response_type: ref __self_1_1,
                    cost: ref __self_1_2,
                    state_proof: ref __self_1_3,
                } => match *self {
                    ResponseHeader {
                        node_transaction_precheck_code: ref __self_0_0,
                        response_type: ref __self_0_1,
                        cost: ref __self_0_2,
                        state_proof: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ResponseHeader) -> bool {
            match *other {
                ResponseHeader {
                    node_transaction_precheck_code: ref __self_1_0,
                    response_type: ref __self_1_1,
                    cost: ref __self_1_2,
                    state_proof: ref __self_1_3,
                } => match *self {
                    ResponseHeader {
                        node_transaction_precheck_code: ref __self_0_0,
                        response_type: ref __self_0_1,
                        cost: ref __self_0_2,
                        state_proof: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ResponseHeader {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.node_transaction_precheck_code != ResponseCodeEnum::default() as i32 {
                ::prost::encoding::int32::encode(1u32, &self.node_transaction_precheck_code, buf);
            }
            if self.response_type != ResponseType::default() as i32 {
                ::prost::encoding::int32::encode(2u32, &self.response_type, buf);
            }
            if self.cost != 0u64 {
                ::prost::encoding::uint64::encode(3u32, &self.cost, buf);
            }
            if self.state_proof != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.state_proof, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ResponseHeader";
            match tag {
                1u32 => {
                    let mut value = &mut self.node_transaction_precheck_code;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "node_transaction_precheck_code");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.response_type;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "response_type");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.cost;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "cost");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.state_proof;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "state_proof");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.node_transaction_precheck_code != ResponseCodeEnum::default() as i32 {
                ::prost::encoding::int32::encoded_len(1u32, &self.node_transaction_precheck_code)
            } else {
                0
            } + if self.response_type != ResponseType::default() as i32 {
                ::prost::encoding::int32::encoded_len(2u32, &self.response_type)
            } else {
                0
            } + if self.cost != 0u64 {
                ::prost::encoding::uint64::encoded_len(3u32, &self.cost)
            } else {
                0
            } + if self.state_proof != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(4u32, &self.state_proof)
            } else {
                0
            }
        }
        fn clear(&mut self) {
            self.node_transaction_precheck_code = ResponseCodeEnum::default() as i32;
            self.response_type = ResponseType::default() as i32;
            self.cost = 0u64;
            self.state_proof.clear();
        }
    }
    impl ::core::default::Default for ResponseHeader {
        fn default() -> Self {
            ResponseHeader {
                node_transaction_precheck_code: ResponseCodeEnum::default() as i32,
                response_type: ResponseType::default() as i32,
                cost: 0u64,
                state_proof: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ResponseHeader {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ResponseHeader");
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match ResponseCodeEnum::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.node_transaction_precheck_code)
                };
                builder.field("node_transaction_precheck_code", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match ResponseType::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.response_type)
                };
                builder.field("response_type", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.cost)
                };
                builder.field("cost", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.state_proof)
                };
                builder.field("state_proof", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl ResponseHeader {
        ///Returns the enum value of `node_transaction_precheck_code`, or the default if the field is set to an invalid enum value.
        pub fn node_transaction_precheck_code(&self) -> ResponseCodeEnum {
            ResponseCodeEnum::from_i32(self.node_transaction_precheck_code)
                .unwrap_or(ResponseCodeEnum::default())
        }
        ///Sets `node_transaction_precheck_code` to the provided enum value.
        pub fn set_node_transaction_precheck_code(&mut self, value: ResponseCodeEnum) {
            self.node_transaction_precheck_code = value as i32;
        }
        ///Returns the enum value of `response_type`, or the default if the field is set to an invalid enum value.
        pub fn response_type(&self) -> ResponseType {
            ResponseType::from_i32(self.response_type).unwrap_or(ResponseType::default())
        }
        ///Sets `response_type` to the provided enum value.
        pub fn set_response_type(&mut self, value: ResponseType) {
            self.response_type = value as i32;
        }
    }
    /// Get the balance of a cryptocurrency account. This returns only the balance, so it is a smaller
    /// reply than CryptoGetInfo, which returns the balance plus additional information.
    pub struct CryptoGetAccountBalanceQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        #[prost(
            oneof = "crypto_get_account_balance_query::BalanceSource",
            tags = "2, 3"
        )]
        pub balance_source: ::core::option::Option<crypto_get_account_balance_query::BalanceSource>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoGetAccountBalanceQuery {
        #[inline]
        fn clone(&self) -> CryptoGetAccountBalanceQuery {
            match *self {
                CryptoGetAccountBalanceQuery {
                    header: ref __self_0_0,
                    balance_source: ref __self_0_1,
                } => CryptoGetAccountBalanceQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    balance_source: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoGetAccountBalanceQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoGetAccountBalanceQuery {
        #[inline]
        fn eq(&self, other: &CryptoGetAccountBalanceQuery) -> bool {
            match *other {
                CryptoGetAccountBalanceQuery {
                    header: ref __self_1_0,
                    balance_source: ref __self_1_1,
                } => match *self {
                    CryptoGetAccountBalanceQuery {
                        header: ref __self_0_0,
                        balance_source: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoGetAccountBalanceQuery) -> bool {
            match *other {
                CryptoGetAccountBalanceQuery {
                    header: ref __self_1_0,
                    balance_source: ref __self_1_1,
                } => match *self {
                    CryptoGetAccountBalanceQuery {
                        header: ref __self_0_0,
                        balance_source: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CryptoGetAccountBalanceQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref oneof) = self.balance_source {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoGetAccountBalanceQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 | 3u32 => {
                    let mut value = &mut self.balance_source;
                    crypto_get_account_balance_query::BalanceSource::merge(
                        value, tag, wire_type, buf, ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "balance_source");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self.balance_source.as_ref().map_or(
                    0,
                    crypto_get_account_balance_query::BalanceSource::encoded_len,
                )
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.balance_source = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CryptoGetAccountBalanceQuery {
        fn default() -> Self {
            CryptoGetAccountBalanceQuery {
                header: ::core::default::Default::default(),
                balance_source: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoGetAccountBalanceQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoGetAccountBalanceQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.balance_source;
                builder.field("balance_source", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `CryptoGetAccountBalanceQuery`.
    pub mod crypto_get_account_balance_query {
        pub enum BalanceSource {
            /// The account ID for which information is requested
            #[prost(message, tag = "2")]
            AccountId(super::AccountId),
            /// The account ID for which information is requested
            #[prost(message, tag = "3")]
            ContractId(super::ContractId),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for BalanceSource {
            #[inline]
            fn clone(&self) -> BalanceSource {
                match (&*self,) {
                    (&BalanceSource::AccountId(ref __self_0),) => {
                        BalanceSource::AccountId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&BalanceSource::ContractId(ref __self_0),) => {
                        BalanceSource::ContractId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for BalanceSource {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for BalanceSource {
            #[inline]
            fn eq(&self, other: &BalanceSource) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &BalanceSource::AccountId(ref __self_0),
                                &BalanceSource::AccountId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &BalanceSource::ContractId(ref __self_0),
                                &BalanceSource::ContractId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &BalanceSource) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &BalanceSource::AccountId(ref __self_0),
                                &BalanceSource::AccountId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &BalanceSource::ContractId(ref __self_0),
                                &BalanceSource::ContractId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl BalanceSource {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    BalanceSource::AccountId(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    BalanceSource::ContractId(ref value) => {
                        ::prost::encoding::message::encode(3u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<BalanceSource>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    2u32 => match field {
                        ::core::option::Option::Some(BalanceSource::AccountId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(BalanceSource::AccountId(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    3u32 => match field {
                        ::core::option::Option::Some(BalanceSource::ContractId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        BalanceSource::ContractId(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid BalanceSource tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    BalanceSource::AccountId(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                    BalanceSource::ContractId(ref value) => {
                        ::prost::encoding::message::encoded_len(3u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for BalanceSource {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    BalanceSource::AccountId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("AccountId").field(&wrapper).finish()
                    }
                    BalanceSource::ContractId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractId").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// Response when the client sends the node CryptoGetAccountBalanceQuery
    pub struct CryptoGetAccountBalanceResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither.
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The account ID that is being described (this is useful with state proofs, for proving to a
        /// third party)
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
        /// The current balance, in tinybars.
        #[prost(uint64, tag = "3")]
        pub balance: u64,
        /// The token balances possessed by the target account.
        #[prost(message, repeated, tag = "4")]
        pub token_balances: ::prost::alloc::vec::Vec<TokenBalance>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoGetAccountBalanceResponse {
        #[inline]
        fn clone(&self) -> CryptoGetAccountBalanceResponse {
            match *self {
                CryptoGetAccountBalanceResponse {
                    header: ref __self_0_0,
                    account_id: ref __self_0_1,
                    balance: ref __self_0_2,
                    token_balances: ref __self_0_3,
                } => CryptoGetAccountBalanceResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    balance: ::core::clone::Clone::clone(&(*__self_0_2)),
                    token_balances: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoGetAccountBalanceResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoGetAccountBalanceResponse {
        #[inline]
        fn eq(&self, other: &CryptoGetAccountBalanceResponse) -> bool {
            match *other {
                CryptoGetAccountBalanceResponse {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                    balance: ref __self_1_2,
                    token_balances: ref __self_1_3,
                } => match *self {
                    CryptoGetAccountBalanceResponse {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                        balance: ref __self_0_2,
                        token_balances: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoGetAccountBalanceResponse) -> bool {
            match *other {
                CryptoGetAccountBalanceResponse {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                    balance: ref __self_1_2,
                    token_balances: ref __self_1_3,
                } => match *self {
                    CryptoGetAccountBalanceResponse {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                        balance: ref __self_0_2,
                        token_balances: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for CryptoGetAccountBalanceResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.balance != 0u64 {
                ::prost::encoding::uint64::encode(3u32, &self.balance, buf);
            }
            for msg in &self.token_balances {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoGetAccountBalanceResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.balance;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "balance");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.token_balances;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "token_balances");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.balance != 0u64 {
                    ::prost::encoding::uint64::encoded_len(3u32, &self.balance)
                } else {
                    0
                }
                + ::prost::encoding::message::encoded_len_repeated(4u32, &self.token_balances)
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
            self.balance = 0u64;
            self.token_balances.clear();
        }
    }
    impl ::core::default::Default for CryptoGetAccountBalanceResponse {
        fn default() -> Self {
            CryptoGetAccountBalanceResponse {
                header: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
                balance: 0u64,
                token_balances: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoGetAccountBalanceResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoGetAccountBalanceResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.balance)
                };
                builder.field("balance", &wrapper)
            };
            let builder = {
                let wrapper = &self.token_balances;
                builder.field("token_balances", &wrapper)
            };
            builder.finish()
        }
    }
    /// Gets information about a schedule in the network's action queue.
    ///
    /// Responds with <tt>INVALID_SCHEDULE_ID</tt> if the requested schedule doesn't exist.
    pub struct ScheduleGetInfoQuery {
        /// standard info sent from client to node including the signed payment, and what kind of response
        /// is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The id of the schedule to interrogate
        #[prost(message, optional, tag = "2")]
        pub schedule_id: ::core::option::Option<ScheduleId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ScheduleGetInfoQuery {
        #[inline]
        fn clone(&self) -> ScheduleGetInfoQuery {
            match *self {
                ScheduleGetInfoQuery {
                    header: ref __self_0_0,
                    schedule_id: ref __self_0_1,
                } => ScheduleGetInfoQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    schedule_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ScheduleGetInfoQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ScheduleGetInfoQuery {
        #[inline]
        fn eq(&self, other: &ScheduleGetInfoQuery) -> bool {
            match *other {
                ScheduleGetInfoQuery {
                    header: ref __self_1_0,
                    schedule_id: ref __self_1_1,
                } => match *self {
                    ScheduleGetInfoQuery {
                        header: ref __self_0_0,
                        schedule_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ScheduleGetInfoQuery) -> bool {
            match *other {
                ScheduleGetInfoQuery {
                    header: ref __self_1_0,
                    schedule_id: ref __self_1_1,
                } => match *self {
                    ScheduleGetInfoQuery {
                        header: ref __self_0_0,
                        schedule_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ScheduleGetInfoQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.schedule_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ScheduleGetInfoQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.schedule_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "schedule_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .schedule_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.schedule_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ScheduleGetInfoQuery {
        fn default() -> Self {
            ScheduleGetInfoQuery {
                header: ::core::default::Default::default(),
                schedule_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ScheduleGetInfoQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ScheduleGetInfoQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.schedule_id;
                builder.field("schedule_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Information summarizing schedule state
    pub struct ScheduleInfo {
        /// The id of the schedule
        #[prost(message, optional, tag = "1")]
        pub schedule_id: ::core::option::Option<ScheduleId>,
        /// The time at which the schedule will be evaluated for execution and then expire.
        ///
        /// Note: Before Long Term Scheduled Transactions are enabled, Scheduled Transactions will _never_ execute at expiration - they
        ///       will _only_ execute during the initial ScheduleCreate transaction or via ScheduleSign transactions and will _always_
        ///       expire at expirationTime.
        #[prost(message, optional, tag = "4")]
        pub expiration_time: ::core::option::Option<Timestamp>,
        /// The scheduled transaction
        #[prost(message, optional, tag = "5")]
        pub scheduled_transaction_body: ::core::option::Option<SchedulableTransactionBody>,
        /// The publicly visible memo of the schedule
        #[prost(string, tag = "6")]
        pub memo: ::prost::alloc::string::String,
        /// The key used to delete the schedule from state
        #[prost(message, optional, tag = "7")]
        pub admin_key: ::core::option::Option<Key>,
        /// The Ed25519 keys the network deems to have signed the scheduled transaction
        #[prost(message, optional, tag = "8")]
        pub signers: ::core::option::Option<KeyList>,
        /// The id of the account that created the schedule
        #[prost(message, optional, tag = "9")]
        pub creator_account_id: ::core::option::Option<AccountId>,
        /// The id of the account responsible for the service fee of the scheduled transaction
        #[prost(message, optional, tag = "10")]
        pub payer_account_id: ::core::option::Option<AccountId>,
        /// The transaction id that will be used in the record of the scheduled transaction (if it
        /// executes)
        #[prost(message, optional, tag = "11")]
        pub scheduled_transaction_id: ::core::option::Option<TransactionId>,
        /// The ledger ID the response was returned from; please see <a href="<https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a>> for the network-specific IDs.
        #[prost(bytes = "vec", tag = "12")]
        pub ledger_id: ::prost::alloc::vec::Vec<u8>,
        /// When set to true, the transaction will be evaluated for execution at expiration_time instead
        /// of when all required signatures are received.
        /// When set to false, the transaction will execute immediately after sufficient signatures are received
        /// to sign the contained transaction. During the initial ScheduleCreate transaction or via ScheduleSign transactions.
        ///
        /// Note: this field is unused until Long Term Scheduled Transactions are enabled.
        #[prost(bool, tag = "13")]
        pub wait_for_expiry: bool,
        #[prost(oneof = "schedule_info::Data", tags = "2, 3")]
        pub data: ::core::option::Option<schedule_info::Data>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ScheduleInfo {
        #[inline]
        fn clone(&self) -> ScheduleInfo {
            match *self {
                ScheduleInfo {
                    schedule_id: ref __self_0_0,
                    expiration_time: ref __self_0_1,
                    scheduled_transaction_body: ref __self_0_2,
                    memo: ref __self_0_3,
                    admin_key: ref __self_0_4,
                    signers: ref __self_0_5,
                    creator_account_id: ref __self_0_6,
                    payer_account_id: ref __self_0_7,
                    scheduled_transaction_id: ref __self_0_8,
                    ledger_id: ref __self_0_9,
                    wait_for_expiry: ref __self_0_10,
                    data: ref __self_0_11,
                } => ScheduleInfo {
                    schedule_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    expiration_time: ::core::clone::Clone::clone(&(*__self_0_1)),
                    scheduled_transaction_body: ::core::clone::Clone::clone(&(*__self_0_2)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_3)),
                    admin_key: ::core::clone::Clone::clone(&(*__self_0_4)),
                    signers: ::core::clone::Clone::clone(&(*__self_0_5)),
                    creator_account_id: ::core::clone::Clone::clone(&(*__self_0_6)),
                    payer_account_id: ::core::clone::Clone::clone(&(*__self_0_7)),
                    scheduled_transaction_id: ::core::clone::Clone::clone(&(*__self_0_8)),
                    ledger_id: ::core::clone::Clone::clone(&(*__self_0_9)),
                    wait_for_expiry: ::core::clone::Clone::clone(&(*__self_0_10)),
                    data: ::core::clone::Clone::clone(&(*__self_0_11)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ScheduleInfo {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ScheduleInfo {
        #[inline]
        fn eq(&self, other: &ScheduleInfo) -> bool {
            match *other {
                ScheduleInfo {
                    schedule_id: ref __self_1_0,
                    expiration_time: ref __self_1_1,
                    scheduled_transaction_body: ref __self_1_2,
                    memo: ref __self_1_3,
                    admin_key: ref __self_1_4,
                    signers: ref __self_1_5,
                    creator_account_id: ref __self_1_6,
                    payer_account_id: ref __self_1_7,
                    scheduled_transaction_id: ref __self_1_8,
                    ledger_id: ref __self_1_9,
                    wait_for_expiry: ref __self_1_10,
                    data: ref __self_1_11,
                } => match *self {
                    ScheduleInfo {
                        schedule_id: ref __self_0_0,
                        expiration_time: ref __self_0_1,
                        scheduled_transaction_body: ref __self_0_2,
                        memo: ref __self_0_3,
                        admin_key: ref __self_0_4,
                        signers: ref __self_0_5,
                        creator_account_id: ref __self_0_6,
                        payer_account_id: ref __self_0_7,
                        scheduled_transaction_id: ref __self_0_8,
                        ledger_id: ref __self_0_9,
                        wait_for_expiry: ref __self_0_10,
                        data: ref __self_0_11,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                            && (*__self_0_11) == (*__self_1_11)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ScheduleInfo) -> bool {
            match *other {
                ScheduleInfo {
                    schedule_id: ref __self_1_0,
                    expiration_time: ref __self_1_1,
                    scheduled_transaction_body: ref __self_1_2,
                    memo: ref __self_1_3,
                    admin_key: ref __self_1_4,
                    signers: ref __self_1_5,
                    creator_account_id: ref __self_1_6,
                    payer_account_id: ref __self_1_7,
                    scheduled_transaction_id: ref __self_1_8,
                    ledger_id: ref __self_1_9,
                    wait_for_expiry: ref __self_1_10,
                    data: ref __self_1_11,
                } => match *self {
                    ScheduleInfo {
                        schedule_id: ref __self_0_0,
                        expiration_time: ref __self_0_1,
                        scheduled_transaction_body: ref __self_0_2,
                        memo: ref __self_0_3,
                        admin_key: ref __self_0_4,
                        signers: ref __self_0_5,
                        creator_account_id: ref __self_0_6,
                        payer_account_id: ref __self_0_7,
                        scheduled_transaction_id: ref __self_0_8,
                        ledger_id: ref __self_0_9,
                        wait_for_expiry: ref __self_0_10,
                        data: ref __self_0_11,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                            || (*__self_0_11) != (*__self_1_11)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ScheduleInfo {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.schedule_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref oneof) = self.data {
                oneof.encode(buf)
            }
            if let Some(ref msg) = self.expiration_time {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            if let Some(ref msg) = self.scheduled_transaction_body {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
            if self.memo != "" {
                ::prost::encoding::string::encode(6u32, &self.memo, buf);
            }
            if let Some(ref msg) = self.admin_key {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            if let Some(ref msg) = self.signers {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
            if let Some(ref msg) = self.creator_account_id {
                ::prost::encoding::message::encode(9u32, msg, buf);
            }
            if let Some(ref msg) = self.payer_account_id {
                ::prost::encoding::message::encode(10u32, msg, buf);
            }
            if let Some(ref msg) = self.scheduled_transaction_id {
                ::prost::encoding::message::encode(11u32, msg, buf);
            }
            if self.ledger_id != b"" as &[u8] {
                ::prost::encoding::bytes::encode(12u32, &self.ledger_id, buf);
            }
            if self.wait_for_expiry != false {
                ::prost::encoding::bool::encode(13u32, &self.wait_for_expiry, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ScheduleInfo";
            match tag {
                1u32 => {
                    let mut value = &mut self.schedule_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "schedule_id");
                        error
                    })
                }
                2u32 | 3u32 => {
                    let mut value = &mut self.data;
                    schedule_info::Data::merge(value, tag, wire_type, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "data");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.expiration_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiration_time");
                        error
                    })
                }
                5u32 => {
                    let mut value = &mut self.scheduled_transaction_body;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "scheduled_transaction_body");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                7u32 => {
                    let mut value = &mut self.admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "admin_key");
                        error
                    })
                }
                8u32 => {
                    let mut value = &mut self.signers;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "signers");
                        error
                    })
                }
                9u32 => {
                    let mut value = &mut self.creator_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "creator_account_id");
                        error
                    })
                }
                10u32 => {
                    let mut value = &mut self.payer_account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "payer_account_id");
                        error
                    })
                }
                11u32 => {
                    let mut value = &mut self.scheduled_transaction_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "scheduled_transaction_id");
                        error
                    })
                }
                12u32 => {
                    let mut value = &mut self.ledger_id;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "ledger_id");
                            error
                        },
                    )
                }
                13u32 => {
                    let mut value = &mut self.wait_for_expiry;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "wait_for_expiry");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .schedule_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .data
                    .as_ref()
                    .map_or(0, schedule_info::Data::encoded_len)
                + self
                    .expiration_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + self
                    .scheduled_transaction_body
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                + if self.memo != "" {
                    ::prost::encoding::string::encoded_len(6u32, &self.memo)
                } else {
                    0
                }
                + self
                    .admin_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                + self
                    .signers
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(8u32, msg))
                + self
                    .creator_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(9u32, msg))
                + self
                    .payer_account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(10u32, msg))
                + self
                    .scheduled_transaction_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(11u32, msg))
                + if self.ledger_id != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(12u32, &self.ledger_id)
                } else {
                    0
                }
                + if self.wait_for_expiry != false {
                    ::prost::encoding::bool::encoded_len(13u32, &self.wait_for_expiry)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.schedule_id = ::core::option::Option::None;
            self.data = ::core::option::Option::None;
            self.expiration_time = ::core::option::Option::None;
            self.scheduled_transaction_body = ::core::option::Option::None;
            self.memo.clear();
            self.admin_key = ::core::option::Option::None;
            self.signers = ::core::option::Option::None;
            self.creator_account_id = ::core::option::Option::None;
            self.payer_account_id = ::core::option::Option::None;
            self.scheduled_transaction_id = ::core::option::Option::None;
            self.ledger_id.clear();
            self.wait_for_expiry = false;
        }
    }
    impl ::core::default::Default for ScheduleInfo {
        fn default() -> Self {
            ScheduleInfo {
                schedule_id: ::core::default::Default::default(),
                data: ::core::default::Default::default(),
                expiration_time: ::core::default::Default::default(),
                scheduled_transaction_body: ::core::default::Default::default(),
                memo: ::prost::alloc::string::String::new(),
                admin_key: ::core::default::Default::default(),
                signers: ::core::default::Default::default(),
                creator_account_id: ::core::default::Default::default(),
                payer_account_id: ::core::default::Default::default(),
                scheduled_transaction_id: ::core::default::Default::default(),
                ledger_id: ::core::default::Default::default(),
                wait_for_expiry: false,
            }
        }
    }
    impl ::core::fmt::Debug for ScheduleInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ScheduleInfo");
            let builder = {
                let wrapper = &self.schedule_id;
                builder.field("schedule_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiration_time;
                builder.field("expiration_time", &wrapper)
            };
            let builder = {
                let wrapper = &self.scheduled_transaction_body;
                builder.field("scheduled_transaction_body", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = &self.admin_key;
                builder.field("admin_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.signers;
                builder.field("signers", &wrapper)
            };
            let builder = {
                let wrapper = &self.creator_account_id;
                builder.field("creator_account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.payer_account_id;
                builder.field("payer_account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.scheduled_transaction_id;
                builder.field("scheduled_transaction_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.ledger_id)
                };
                builder.field("ledger_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.wait_for_expiry)
                };
                builder.field("wait_for_expiry", &wrapper)
            };
            let builder = {
                let wrapper = &self.data;
                builder.field("data", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `ScheduleInfo`.
    pub mod schedule_info {
        pub enum Data {
            /// If the schedule has been deleted, the consensus time when this occurred
            #[prost(message, tag = "2")]
            DeletionTime(super::Timestamp),
            /// If the schedule has been executed, the consensus time when this occurred
            #[prost(message, tag = "3")]
            ExecutionTime(super::Timestamp),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Data {
            #[inline]
            fn clone(&self) -> Data {
                match (&*self,) {
                    (&Data::DeletionTime(ref __self_0),) => {
                        Data::DeletionTime(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Data::ExecutionTime(ref __self_0),) => {
                        Data::ExecutionTime(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Data {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Data {
            #[inline]
            fn eq(&self, other: &Data) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Data::DeletionTime(ref __self_0),
                                &Data::DeletionTime(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Data::ExecutionTime(ref __self_0),
                                &Data::ExecutionTime(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Data) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Data::DeletionTime(ref __self_0),
                                &Data::DeletionTime(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Data::ExecutionTime(ref __self_0),
                                &Data::ExecutionTime(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Data {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Data::DeletionTime(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    Data::ExecutionTime(ref value) => {
                        ::prost::encoding::message::encode(3u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Data>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    2u32 => match field {
                        ::core::option::Option::Some(Data::DeletionTime(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::DeletionTime(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    3u32 => match field {
                        ::core::option::Option::Some(Data::ExecutionTime(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Data::ExecutionTime(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Data tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Data::DeletionTime(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                    Data::ExecutionTime(ref value) => {
                        ::prost::encoding::message::encoded_len(3u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Data {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Data::DeletionTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("DeletionTime").field(&wrapper).finish()
                    }
                    Data::ExecutionTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ExecutionTime").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// Response wrapper for the <tt>ScheduleInfo</tt>
    pub struct ScheduleGetInfoResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof, or
        /// both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The information requested about this schedule instance
        #[prost(message, optional, tag = "2")]
        pub schedule_info: ::core::option::Option<ScheduleInfo>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ScheduleGetInfoResponse {
        #[inline]
        fn clone(&self) -> ScheduleGetInfoResponse {
            match *self {
                ScheduleGetInfoResponse {
                    header: ref __self_0_0,
                    schedule_info: ref __self_0_1,
                } => ScheduleGetInfoResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    schedule_info: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ScheduleGetInfoResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ScheduleGetInfoResponse {
        #[inline]
        fn eq(&self, other: &ScheduleGetInfoResponse) -> bool {
            match *other {
                ScheduleGetInfoResponse {
                    header: ref __self_1_0,
                    schedule_info: ref __self_1_1,
                } => match *self {
                    ScheduleGetInfoResponse {
                        header: ref __self_0_0,
                        schedule_info: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ScheduleGetInfoResponse) -> bool {
            match *other {
                ScheduleGetInfoResponse {
                    header: ref __self_1_0,
                    schedule_info: ref __self_1_1,
                } => match *self {
                    ScheduleGetInfoResponse {
                        header: ref __self_0_0,
                        schedule_info: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ScheduleGetInfoResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.schedule_info {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ScheduleGetInfoResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.schedule_info;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "schedule_info");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .schedule_info
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.schedule_info = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ScheduleGetInfoResponse {
        fn default() -> Self {
            ScheduleGetInfoResponse {
                header: ::core::default::Default::default(),
                schedule_info: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ScheduleGetInfoResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ScheduleGetInfoResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.schedule_info;
                builder.field("schedule_info", &wrapper)
            };
            builder.finish()
        }
    }
    /// An exchange rate between hbar and cents (USD) and the time at which the exchange rate will
    /// expire, and be superseded by a new exchange rate.
    pub struct ExchangeRate {
        /// Denominator in calculation of exchange rate between hbar and cents
        #[prost(int32, tag = "1")]
        pub hbar_equiv: i32,
        /// Numerator in calculation of exchange rate between hbar and cents
        #[prost(int32, tag = "2")]
        pub cent_equiv: i32,
        /// Expiration time in seconds for this exchange rate
        #[prost(message, optional, tag = "3")]
        pub expiration_time: ::core::option::Option<TimestampSeconds>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ExchangeRate {
        #[inline]
        fn clone(&self) -> ExchangeRate {
            match *self {
                ExchangeRate {
                    hbar_equiv: ref __self_0_0,
                    cent_equiv: ref __self_0_1,
                    expiration_time: ref __self_0_2,
                } => ExchangeRate {
                    hbar_equiv: ::core::clone::Clone::clone(&(*__self_0_0)),
                    cent_equiv: ::core::clone::Clone::clone(&(*__self_0_1)),
                    expiration_time: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ExchangeRate {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ExchangeRate {
        #[inline]
        fn eq(&self, other: &ExchangeRate) -> bool {
            match *other {
                ExchangeRate {
                    hbar_equiv: ref __self_1_0,
                    cent_equiv: ref __self_1_1,
                    expiration_time: ref __self_1_2,
                } => match *self {
                    ExchangeRate {
                        hbar_equiv: ref __self_0_0,
                        cent_equiv: ref __self_0_1,
                        expiration_time: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ExchangeRate) -> bool {
            match *other {
                ExchangeRate {
                    hbar_equiv: ref __self_1_0,
                    cent_equiv: ref __self_1_1,
                    expiration_time: ref __self_1_2,
                } => match *self {
                    ExchangeRate {
                        hbar_equiv: ref __self_0_0,
                        cent_equiv: ref __self_0_1,
                        expiration_time: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ExchangeRate {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.hbar_equiv != 0i32 {
                ::prost::encoding::int32::encode(1u32, &self.hbar_equiv, buf);
            }
            if self.cent_equiv != 0i32 {
                ::prost::encoding::int32::encode(2u32, &self.cent_equiv, buf);
            }
            if let Some(ref msg) = self.expiration_time {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ExchangeRate";
            match tag {
                1u32 => {
                    let mut value = &mut self.hbar_equiv;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "hbar_equiv");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.cent_equiv;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "cent_equiv");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.expiration_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiration_time");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.hbar_equiv != 0i32 {
                ::prost::encoding::int32::encoded_len(1u32, &self.hbar_equiv)
            } else {
                0
            } + if self.cent_equiv != 0i32 {
                ::prost::encoding::int32::encoded_len(2u32, &self.cent_equiv)
            } else {
                0
            } + self
                .expiration_time
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
        }
        fn clear(&mut self) {
            self.hbar_equiv = 0i32;
            self.cent_equiv = 0i32;
            self.expiration_time = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ExchangeRate {
        fn default() -> Self {
            ExchangeRate {
                hbar_equiv: 0i32,
                cent_equiv: 0i32,
                expiration_time: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ExchangeRate {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ExchangeRate");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.hbar_equiv)
                };
                builder.field("hbar_equiv", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.cent_equiv)
                };
                builder.field("cent_equiv", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiration_time;
                builder.field("expiration_time", &wrapper)
            };
            builder.finish()
        }
    }
    /// Two sets of exchange rates
    pub struct ExchangeRateSet {
        /// Current exchange rate
        #[prost(message, optional, tag = "1")]
        pub current_rate: ::core::option::Option<ExchangeRate>,
        /// Next exchange rate which will take effect when current rate expires
        #[prost(message, optional, tag = "2")]
        pub next_rate: ::core::option::Option<ExchangeRate>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ExchangeRateSet {
        #[inline]
        fn clone(&self) -> ExchangeRateSet {
            match *self {
                ExchangeRateSet {
                    current_rate: ref __self_0_0,
                    next_rate: ref __self_0_1,
                } => ExchangeRateSet {
                    current_rate: ::core::clone::Clone::clone(&(*__self_0_0)),
                    next_rate: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ExchangeRateSet {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ExchangeRateSet {
        #[inline]
        fn eq(&self, other: &ExchangeRateSet) -> bool {
            match *other {
                ExchangeRateSet {
                    current_rate: ref __self_1_0,
                    next_rate: ref __self_1_1,
                } => match *self {
                    ExchangeRateSet {
                        current_rate: ref __self_0_0,
                        next_rate: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ExchangeRateSet) -> bool {
            match *other {
                ExchangeRateSet {
                    current_rate: ref __self_1_0,
                    next_rate: ref __self_1_1,
                } => match *self {
                    ExchangeRateSet {
                        current_rate: ref __self_0_0,
                        next_rate: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ExchangeRateSet {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.current_rate {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.next_rate {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ExchangeRateSet";
            match tag {
                1u32 => {
                    let mut value = &mut self.current_rate;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "current_rate");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.next_rate;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "next_rate");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .current_rate
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .next_rate
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.current_rate = ::core::option::Option::None;
            self.next_rate = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ExchangeRateSet {
        fn default() -> Self {
            ExchangeRateSet {
                current_rate: ::core::default::Default::default(),
                next_rate: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ExchangeRateSet {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ExchangeRateSet");
            let builder = {
                let wrapper = &self.current_rate;
                builder.field("current_rate", &wrapper)
            };
            let builder = {
                let wrapper = &self.next_rate;
                builder.field("next_rate", &wrapper)
            };
            builder.finish()
        }
    }
    /// The summary of a transaction's result so far. If the transaction has not reached consensus, this
    /// result will be necessarily incomplete.
    pub struct TransactionReceipt {
        /// The consensus status of the transaction; is UNKNOWN if consensus has not been reached, or if
        /// the associated transaction did not have a valid payer signature
        #[prost(enumeration = "ResponseCodeEnum", tag = "1")]
        pub status: i32,
        /// In the receipt of a CryptoCreate, the id of the newly created account
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
        /// In the receipt of a FileCreate, the id of the newly created file
        #[prost(message, optional, tag = "3")]
        pub file_id: ::core::option::Option<FileId>,
        /// In the receipt of a ContractCreate, the id of the newly created contract
        #[prost(message, optional, tag = "4")]
        pub contract_id: ::core::option::Option<ContractId>,
        /// The exchange rates in effect when the transaction reached consensus
        #[prost(message, optional, tag = "5")]
        pub exchange_rate: ::core::option::Option<ExchangeRateSet>,
        /// In the receipt of a ConsensusCreateTopic, the id of the newly created topic.
        #[prost(message, optional, tag = "6")]
        pub topic_id: ::core::option::Option<TopicId>,
        /// In the receipt of a ConsensusSubmitMessage, the new sequence number of the topic that
        /// received the message
        #[prost(uint64, tag = "7")]
        pub topic_sequence_number: u64,
        /// In the receipt of a ConsensusSubmitMessage, the new running hash of the topic that received
        /// the message.  This 48-byte field is the output of a particular SHA-384 digest whose input
        /// data are determined by the value of the topicRunningHashVersion below. The bytes of each
        /// uint64 or uint32 are to be in Big-Endian format.
        ///
        /// IF the topicRunningHashVersion is '0' or '1', then the input data to the SHA-384 digest are,
        /// in order:
        /// ---
        /// 1. The previous running hash of the topic (48 bytes)
        /// 2. The topic's shard (8 bytes)
        /// 3. The topic's realm (8 bytes)
        /// 4. The topic's number (8 bytes)
        /// 5. The number of seconds since the epoch before the ConsensusSubmitMessage reached
        ///    consensus (8 bytes)
        /// 6. The number of nanoseconds since 5. before the ConsensusSubmitMessage reached
        ///    consensus (4 bytes)
        /// 7. The topicSequenceNumber from above (8 bytes)
        /// 8. The message bytes from the ConsensusSubmitMessage (variable).
        ///
        /// IF the topicRunningHashVersion is '2', then the input data to the SHA-384 digest are, in
        /// order:
        /// ---
        /// 1. The previous running hash of the topic (48 bytes)
        /// 2. The topicRunningHashVersion below (8 bytes)
        /// 3. The topic's shard (8 bytes)
        /// 4. The topic's realm (8 bytes)
        /// 5. The topic's number (8 bytes)
        /// 6. The number of seconds since the epoch before the ConsensusSubmitMessage reached
        ///    consensus (8 bytes)
        /// 7. The number of nanoseconds since 6. before the ConsensusSubmitMessage reached
        ///    consensus (4 bytes)
        /// 8. The topicSequenceNumber from above (8 bytes)
        /// 9. The output of the SHA-384 digest of the message bytes from the
        ///    consensusSubmitMessage (48 bytes)
        ///
        /// Otherwise, IF the topicRunningHashVersion is '3', then the input data to the SHA-384 digest
        /// are, in order:
        /// ---
        /// 1. The previous running hash of the topic (48 bytes)
        /// 2. The topicRunningHashVersion below (8 bytes)
        /// 3. The payer account's shard (8 bytes)
        /// 4. The payer account's realm (8 bytes)
        /// 5. The payer account's number (8 bytes)
        /// 6. The topic's shard (8 bytes)
        /// 7. The topic's realm (8 bytes)
        /// 8. The topic's number (8 bytes)
        /// 9. The number of seconds since the epoch before the ConsensusSubmitMessage reached
        ///    consensus (8 bytes)
        /// 10. The number of nanoseconds since 9. before the ConsensusSubmitMessage reached
        ///     consensus (4 bytes)
        /// 11. The topicSequenceNumber from above (8 bytes)
        /// 12. The output of the SHA-384 digest of the message bytes from the
        ///     consensusSubmitMessage (48 bytes)
        #[prost(bytes = "vec", tag = "8")]
        pub topic_running_hash: ::prost::alloc::vec::Vec<u8>,
        /// In the receipt of a ConsensusSubmitMessage, the version of the SHA-384 digest used to update
        /// the running hash.
        #[prost(uint64, tag = "9")]
        pub topic_running_hash_version: u64,
        /// In the receipt of a CreateToken, the id of the newly created token
        #[prost(message, optional, tag = "10")]
        pub token_id: ::core::option::Option<TokenId>,
        /// In the receipt of TokenMint, TokenWipe, TokenBurn, For fungible tokens - the current total
        /// supply of this token. For non fungible tokens - the total number of NFTs issued for a given
        /// tokenID
        #[prost(uint64, tag = "11")]
        pub new_total_supply: u64,
        /// In the receipt of a ScheduleCreate, the id of the newly created Scheduled Entity
        #[prost(message, optional, tag = "12")]
        pub schedule_id: ::core::option::Option<ScheduleId>,
        /// In the receipt of a ScheduleCreate or ScheduleSign that resolves to SUCCESS, the
        /// TransactionID that should be used to query for the receipt or record of the relevant
        /// scheduled transaction
        #[prost(message, optional, tag = "13")]
        pub scheduled_transaction_id: ::core::option::Option<TransactionId>,
        /// In the receipt of a TokenMint for tokens of type NON_FUNGIBLE_UNIQUE, the serial numbers of
        /// the newly created NFTs
        #[prost(int64, repeated, tag = "14")]
        pub serial_numbers: ::prost::alloc::vec::Vec<i64>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionReceipt {
        #[inline]
        fn clone(&self) -> TransactionReceipt {
            match *self {
                TransactionReceipt {
                    status: ref __self_0_0,
                    account_id: ref __self_0_1,
                    file_id: ref __self_0_2,
                    contract_id: ref __self_0_3,
                    exchange_rate: ref __self_0_4,
                    topic_id: ref __self_0_5,
                    topic_sequence_number: ref __self_0_6,
                    topic_running_hash: ref __self_0_7,
                    topic_running_hash_version: ref __self_0_8,
                    token_id: ref __self_0_9,
                    new_total_supply: ref __self_0_10,
                    schedule_id: ref __self_0_11,
                    scheduled_transaction_id: ref __self_0_12,
                    serial_numbers: ref __self_0_13,
                } => TransactionReceipt {
                    status: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    file_id: ::core::clone::Clone::clone(&(*__self_0_2)),
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_3)),
                    exchange_rate: ::core::clone::Clone::clone(&(*__self_0_4)),
                    topic_id: ::core::clone::Clone::clone(&(*__self_0_5)),
                    topic_sequence_number: ::core::clone::Clone::clone(&(*__self_0_6)),
                    topic_running_hash: ::core::clone::Clone::clone(&(*__self_0_7)),
                    topic_running_hash_version: ::core::clone::Clone::clone(&(*__self_0_8)),
                    token_id: ::core::clone::Clone::clone(&(*__self_0_9)),
                    new_total_supply: ::core::clone::Clone::clone(&(*__self_0_10)),
                    schedule_id: ::core::clone::Clone::clone(&(*__self_0_11)),
                    scheduled_transaction_id: ::core::clone::Clone::clone(&(*__self_0_12)),
                    serial_numbers: ::core::clone::Clone::clone(&(*__self_0_13)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionReceipt {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionReceipt {
        #[inline]
        fn eq(&self, other: &TransactionReceipt) -> bool {
            match *other {
                TransactionReceipt {
                    status: ref __self_1_0,
                    account_id: ref __self_1_1,
                    file_id: ref __self_1_2,
                    contract_id: ref __self_1_3,
                    exchange_rate: ref __self_1_4,
                    topic_id: ref __self_1_5,
                    topic_sequence_number: ref __self_1_6,
                    topic_running_hash: ref __self_1_7,
                    topic_running_hash_version: ref __self_1_8,
                    token_id: ref __self_1_9,
                    new_total_supply: ref __self_1_10,
                    schedule_id: ref __self_1_11,
                    scheduled_transaction_id: ref __self_1_12,
                    serial_numbers: ref __self_1_13,
                } => match *self {
                    TransactionReceipt {
                        status: ref __self_0_0,
                        account_id: ref __self_0_1,
                        file_id: ref __self_0_2,
                        contract_id: ref __self_0_3,
                        exchange_rate: ref __self_0_4,
                        topic_id: ref __self_0_5,
                        topic_sequence_number: ref __self_0_6,
                        topic_running_hash: ref __self_0_7,
                        topic_running_hash_version: ref __self_0_8,
                        token_id: ref __self_0_9,
                        new_total_supply: ref __self_0_10,
                        schedule_id: ref __self_0_11,
                        scheduled_transaction_id: ref __self_0_12,
                        serial_numbers: ref __self_0_13,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                            && (*__self_0_11) == (*__self_1_11)
                            && (*__self_0_12) == (*__self_1_12)
                            && (*__self_0_13) == (*__self_1_13)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionReceipt) -> bool {
            match *other {
                TransactionReceipt {
                    status: ref __self_1_0,
                    account_id: ref __self_1_1,
                    file_id: ref __self_1_2,
                    contract_id: ref __self_1_3,
                    exchange_rate: ref __self_1_4,
                    topic_id: ref __self_1_5,
                    topic_sequence_number: ref __self_1_6,
                    topic_running_hash: ref __self_1_7,
                    topic_running_hash_version: ref __self_1_8,
                    token_id: ref __self_1_9,
                    new_total_supply: ref __self_1_10,
                    schedule_id: ref __self_1_11,
                    scheduled_transaction_id: ref __self_1_12,
                    serial_numbers: ref __self_1_13,
                } => match *self {
                    TransactionReceipt {
                        status: ref __self_0_0,
                        account_id: ref __self_0_1,
                        file_id: ref __self_0_2,
                        contract_id: ref __self_0_3,
                        exchange_rate: ref __self_0_4,
                        topic_id: ref __self_0_5,
                        topic_sequence_number: ref __self_0_6,
                        topic_running_hash: ref __self_0_7,
                        topic_running_hash_version: ref __self_0_8,
                        token_id: ref __self_0_9,
                        new_total_supply: ref __self_0_10,
                        schedule_id: ref __self_0_11,
                        scheduled_transaction_id: ref __self_0_12,
                        serial_numbers: ref __self_0_13,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                            || (*__self_0_11) != (*__self_1_11)
                            || (*__self_0_12) != (*__self_1_12)
                            || (*__self_0_13) != (*__self_1_13)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TransactionReceipt {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.status != ResponseCodeEnum::default() as i32 {
                ::prost::encoding::int32::encode(1u32, &self.status, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.file_id {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            if let Some(ref msg) = self.exchange_rate {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
            if let Some(ref msg) = self.topic_id {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            if self.topic_sequence_number != 0u64 {
                ::prost::encoding::uint64::encode(7u32, &self.topic_sequence_number, buf);
            }
            if self.topic_running_hash != b"" as &[u8] {
                ::prost::encoding::bytes::encode(8u32, &self.topic_running_hash, buf);
            }
            if self.topic_running_hash_version != 0u64 {
                ::prost::encoding::uint64::encode(9u32, &self.topic_running_hash_version, buf);
            }
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(10u32, msg, buf);
            }
            if self.new_total_supply != 0u64 {
                ::prost::encoding::uint64::encode(11u32, &self.new_total_supply, buf);
            }
            if let Some(ref msg) = self.schedule_id {
                ::prost::encoding::message::encode(12u32, msg, buf);
            }
            if let Some(ref msg) = self.scheduled_transaction_id {
                ::prost::encoding::message::encode(13u32, msg, buf);
            }
            ::prost::encoding::int64::encode_packed(14u32, &self.serial_numbers, buf);
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionReceipt";
            match tag {
                1u32 => {
                    let mut value = &mut self.status;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "status");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.file_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "file_id");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                5u32 => {
                    let mut value = &mut self.exchange_rate;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "exchange_rate");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.topic_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "topic_id");
                        error
                    })
                }
                7u32 => {
                    let mut value = &mut self.topic_sequence_number;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "topic_sequence_number");
                            error
                        },
                    )
                }
                8u32 => {
                    let mut value = &mut self.topic_running_hash;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "topic_running_hash");
                            error
                        },
                    )
                }
                9u32 => {
                    let mut value = &mut self.topic_running_hash_version;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "topic_running_hash_version");
                            error
                        },
                    )
                }
                10u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                11u32 => {
                    let mut value = &mut self.new_total_supply;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "new_total_supply");
                            error
                        },
                    )
                }
                12u32 => {
                    let mut value = &mut self.schedule_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "schedule_id");
                        error
                    })
                }
                13u32 => {
                    let mut value = &mut self.scheduled_transaction_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "scheduled_transaction_id");
                        error
                    })
                }
                14u32 => {
                    let mut value = &mut self.serial_numbers;
                    ::prost::encoding::int64::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "serial_numbers");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.status != ResponseCodeEnum::default() as i32 {
                ::prost::encoding::int32::encoded_len(1u32, &self.status)
            } else {
                0
            } + self
                .account_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .file_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .contract_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + self
                    .exchange_rate
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                + self
                    .topic_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                + if self.topic_sequence_number != 0u64 {
                    ::prost::encoding::uint64::encoded_len(7u32, &self.topic_sequence_number)
                } else {
                    0
                }
                + if self.topic_running_hash != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(8u32, &self.topic_running_hash)
                } else {
                    0
                }
                + if self.topic_running_hash_version != 0u64 {
                    ::prost::encoding::uint64::encoded_len(9u32, &self.topic_running_hash_version)
                } else {
                    0
                }
                + self
                    .token_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(10u32, msg))
                + if self.new_total_supply != 0u64 {
                    ::prost::encoding::uint64::encoded_len(11u32, &self.new_total_supply)
                } else {
                    0
                }
                + self
                    .schedule_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(12u32, msg))
                + self
                    .scheduled_transaction_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(13u32, msg))
                + ::prost::encoding::int64::encoded_len_packed(14u32, &self.serial_numbers)
        }
        fn clear(&mut self) {
            self.status = ResponseCodeEnum::default() as i32;
            self.account_id = ::core::option::Option::None;
            self.file_id = ::core::option::Option::None;
            self.contract_id = ::core::option::Option::None;
            self.exchange_rate = ::core::option::Option::None;
            self.topic_id = ::core::option::Option::None;
            self.topic_sequence_number = 0u64;
            self.topic_running_hash.clear();
            self.topic_running_hash_version = 0u64;
            self.token_id = ::core::option::Option::None;
            self.new_total_supply = 0u64;
            self.schedule_id = ::core::option::Option::None;
            self.scheduled_transaction_id = ::core::option::Option::None;
            self.serial_numbers.clear();
        }
    }
    impl ::core::default::Default for TransactionReceipt {
        fn default() -> Self {
            TransactionReceipt {
                status: ResponseCodeEnum::default() as i32,
                account_id: ::core::default::Default::default(),
                file_id: ::core::default::Default::default(),
                contract_id: ::core::default::Default::default(),
                exchange_rate: ::core::default::Default::default(),
                topic_id: ::core::default::Default::default(),
                topic_sequence_number: 0u64,
                topic_running_hash: ::core::default::Default::default(),
                topic_running_hash_version: 0u64,
                token_id: ::core::default::Default::default(),
                new_total_supply: 0u64,
                schedule_id: ::core::default::Default::default(),
                scheduled_transaction_id: ::core::default::Default::default(),
                serial_numbers: ::prost::alloc::vec::Vec::new(),
            }
        }
    }
    impl ::core::fmt::Debug for TransactionReceipt {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionReceipt");
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match ResponseCodeEnum::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.status)
                };
                builder.field("status", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.file_id;
                builder.field("file_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.exchange_rate;
                builder.field("exchange_rate", &wrapper)
            };
            let builder = {
                let wrapper = &self.topic_id;
                builder.field("topic_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.topic_sequence_number)
                };
                builder.field("topic_sequence_number", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.topic_running_hash)
                };
                builder.field("topic_running_hash", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.topic_running_hash_version)
                };
                builder.field("topic_running_hash_version", &wrapper)
            };
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.new_total_supply)
                };
                builder.field("new_total_supply", &wrapper)
            };
            let builder = {
                let wrapper = &self.schedule_id;
                builder.field("schedule_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.scheduled_transaction_id;
                builder.field("scheduled_transaction_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i64>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.serial_numbers)
                };
                builder.field("serial_numbers", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl TransactionReceipt {
        ///Returns the enum value of `status`, or the default if the field is set to an invalid enum value.
        pub fn status(&self) -> ResponseCodeEnum {
            ResponseCodeEnum::from_i32(self.status).unwrap_or(ResponseCodeEnum::default())
        }
        ///Sets `status` to the provided enum value.
        pub fn set_status(&mut self, value: ResponseCodeEnum) {
            self.status = value as i32;
        }
    }
    /// The log information for an event returned by a smart contract function call. One function call
    /// may return several such events.
    pub struct ContractLoginfo {
        /// address of a contract that emitted the event
        #[prost(message, optional, tag = "1")]
        pub contract_id: ::core::option::Option<ContractId>,
        /// bloom filter for a particular log
        #[prost(bytes = "vec", tag = "2")]
        pub bloom: ::prost::alloc::vec::Vec<u8>,
        /// topics of a particular event
        #[prost(bytes = "vec", repeated, tag = "3")]
        pub topic: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
        /// event data
        #[prost(bytes = "vec", tag = "4")]
        pub data: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractLoginfo {
        #[inline]
        fn clone(&self) -> ContractLoginfo {
            match *self {
                ContractLoginfo {
                    contract_id: ref __self_0_0,
                    bloom: ref __self_0_1,
                    topic: ref __self_0_2,
                    data: ref __self_0_3,
                } => ContractLoginfo {
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    bloom: ::core::clone::Clone::clone(&(*__self_0_1)),
                    topic: ::core::clone::Clone::clone(&(*__self_0_2)),
                    data: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractLoginfo {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractLoginfo {
        #[inline]
        fn eq(&self, other: &ContractLoginfo) -> bool {
            match *other {
                ContractLoginfo {
                    contract_id: ref __self_1_0,
                    bloom: ref __self_1_1,
                    topic: ref __self_1_2,
                    data: ref __self_1_3,
                } => match *self {
                    ContractLoginfo {
                        contract_id: ref __self_0_0,
                        bloom: ref __self_0_1,
                        topic: ref __self_0_2,
                        data: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractLoginfo) -> bool {
            match *other {
                ContractLoginfo {
                    contract_id: ref __self_1_0,
                    bloom: ref __self_1_1,
                    topic: ref __self_1_2,
                    data: ref __self_1_3,
                } => match *self {
                    ContractLoginfo {
                        contract_id: ref __self_0_0,
                        bloom: ref __self_0_1,
                        topic: ref __self_0_2,
                        data: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ContractLoginfo {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.bloom != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.bloom, buf);
            }
            ::prost::encoding::bytes::encode_repeated(3u32, &self.topic, buf);
            if self.data != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.data, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractLoginfo";
            match tag {
                1u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.bloom;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "bloom");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.topic;
                    ::prost::encoding::bytes::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "topic");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.data;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "data");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .contract_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.bloom != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(2u32, &self.bloom)
                } else {
                    0
                }
                + ::prost::encoding::bytes::encoded_len_repeated(3u32, &self.topic)
                + if self.data != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(4u32, &self.data)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.contract_id = ::core::option::Option::None;
            self.bloom.clear();
            self.topic.clear();
            self.data.clear();
        }
    }
    impl ::core::default::Default for ContractLoginfo {
        fn default() -> Self {
            ContractLoginfo {
                contract_id: ::core::default::Default::default(),
                bloom: ::core::default::Default::default(),
                topic: ::prost::alloc::vec::Vec::new(),
                data: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractLoginfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractLoginfo");
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.bloom)
                };
                builder.field("bloom", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(
                        &'a ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
                    );
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.topic)
                };
                builder.field("topic", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.data)
                };
                builder.field("data", &wrapper)
            };
            builder.finish()
        }
    }
    /// The result returned by a call to a smart contract function. This is part of the response to a
    /// ContractCallLocal query, and is in the record for a ContractCall or ContractCreateInstance
    /// transaction. The ContractCreateInstance transaction record has the results of the call to the
    /// constructor.
    pub struct ContractFunctionResult {
        /// the smart contract instance whose function was called
        #[prost(message, optional, tag = "1")]
        pub contract_id: ::core::option::Option<ContractId>,
        /// the result returned by the function
        #[prost(bytes = "vec", tag = "2")]
        pub contract_call_result: ::prost::alloc::vec::Vec<u8>,
        /// message In case there was an error during smart contract execution
        #[prost(string, tag = "3")]
        pub error_message: ::prost::alloc::string::String,
        /// bloom filter for record
        #[prost(bytes = "vec", tag = "4")]
        pub bloom: ::prost::alloc::vec::Vec<u8>,
        /// units of gas used to execute contract
        #[prost(uint64, tag = "5")]
        pub gas_used: u64,
        /// the log info for events returned by the function
        #[prost(message, repeated, tag = "6")]
        pub log_info: ::prost::alloc::vec::Vec<ContractLoginfo>,
        /// \[DEPRECATED\] the list of smart contracts that were created by the function call.
        ///
        /// The created ids will now _also_ be externalized through internal transaction
        /// records, where each record has its alias field populated with the new contract's
        /// EVM address. (This is needed for contracts created with CREATE2, since
        /// there is no longer a simple relationship between the new contract's 0.0.X id
        /// and its Solidity address.)
        #[deprecated]
        #[prost(message, repeated, tag = "7")]
        pub created_contract_i_ds: ::prost::alloc::vec::Vec<ContractId>,
        /// the list of state reads and changes caused by this function call
        #[prost(message, repeated, tag = "8")]
        pub state_changes: ::prost::alloc::vec::Vec<ContractStateChange>,
        /// The new contract's 20-byte EVM address. Only populated after release 0.23,
        /// where each created contract will have its own record. (This is an important
        /// point--the field is not <tt>repeated</tt> because there will be a separate
        /// child record for each created contract.)
        ///
        /// Every contract has an EVM address determined by its <tt>shard.realm.num</tt> id.
        /// This address is as follows:
        ///   <ol>
        ///     <li>The first 4 bytes are the big-endian representation of the shard.</li>
        ///     <li>The next 8 bytes are the big-endian representation of the realm.</li>
        ///     <li>The final 8 bytes are the big-endian representation of the number.</li>
        ///   </ol>  
        ///
        /// Contracts created via CREATE2 have an <b>additional, primary address</b> that is
        /// derived from the <a href="<https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>>
        /// specification, and does not have a simple relation to a <tt>shard.realm.num</tt> id.
        ///
        /// (Please do note that CREATE2 contracts can also be referenced by the three-part
        /// EVM address described above.)
        #[prost(message, optional, tag = "9")]
        pub evm_address: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
        /// The amount of gas available for the call, aka the gasLimit.
        ///
        /// This field should only be populated when the paired TransactionBody in the record stream is not a
        /// ContractCreateTransactionBody or a ContractCallTransactionBody.     
        #[prost(int64, tag = "10")]
        pub gas: i64,
        /// Number of tinybars sent (the function must be payable if this is nonzero).
        ///
        /// This field should only be populated when the paired TransactionBody in the record stream is not a
        /// ContractCreateTransactionBody or a ContractCallTransactionBody.     
        #[prost(int64, tag = "11")]
        pub amount: i64,
        /// The parameters passed into the contract call.
        ///
        /// This field should only be populated when the paired TransactionBody in the record stream is not a
        /// ContractCreateTransactionBody or a ContractCallTransactionBody.     
        #[prost(bytes = "vec", tag = "12")]
        pub function_parameters: ::prost::alloc::vec::Vec<u8>,
        /// The account that is the "sender." If not present it is the accountId from the transactionId.
        ///
        /// This field should only be populated when the paired TransactionBody in the record stream is not a
        /// ContractCreateTransactionBody or a ContractCallTransactionBody.     
        #[prost(message, optional, tag = "13")]
        pub sender_id: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractFunctionResult {
        #[inline]
        fn clone(&self) -> ContractFunctionResult {
            match *self {
                ContractFunctionResult {
                    contract_id: ref __self_0_0,
                    contract_call_result: ref __self_0_1,
                    error_message: ref __self_0_2,
                    bloom: ref __self_0_3,
                    gas_used: ref __self_0_4,
                    log_info: ref __self_0_5,
                    created_contract_i_ds: ref __self_0_6,
                    state_changes: ref __self_0_7,
                    evm_address: ref __self_0_8,
                    gas: ref __self_0_9,
                    amount: ref __self_0_10,
                    function_parameters: ref __self_0_11,
                    sender_id: ref __self_0_12,
                } => ContractFunctionResult {
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    contract_call_result: ::core::clone::Clone::clone(&(*__self_0_1)),
                    error_message: ::core::clone::Clone::clone(&(*__self_0_2)),
                    bloom: ::core::clone::Clone::clone(&(*__self_0_3)),
                    gas_used: ::core::clone::Clone::clone(&(*__self_0_4)),
                    log_info: ::core::clone::Clone::clone(&(*__self_0_5)),
                    created_contract_i_ds: ::core::clone::Clone::clone(&(*__self_0_6)),
                    state_changes: ::core::clone::Clone::clone(&(*__self_0_7)),
                    evm_address: ::core::clone::Clone::clone(&(*__self_0_8)),
                    gas: ::core::clone::Clone::clone(&(*__self_0_9)),
                    amount: ::core::clone::Clone::clone(&(*__self_0_10)),
                    function_parameters: ::core::clone::Clone::clone(&(*__self_0_11)),
                    sender_id: ::core::clone::Clone::clone(&(*__self_0_12)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractFunctionResult {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractFunctionResult {
        #[inline]
        fn eq(&self, other: &ContractFunctionResult) -> bool {
            match *other {
                ContractFunctionResult {
                    contract_id: ref __self_1_0,
                    contract_call_result: ref __self_1_1,
                    error_message: ref __self_1_2,
                    bloom: ref __self_1_3,
                    gas_used: ref __self_1_4,
                    log_info: ref __self_1_5,
                    created_contract_i_ds: ref __self_1_6,
                    state_changes: ref __self_1_7,
                    evm_address: ref __self_1_8,
                    gas: ref __self_1_9,
                    amount: ref __self_1_10,
                    function_parameters: ref __self_1_11,
                    sender_id: ref __self_1_12,
                } => match *self {
                    ContractFunctionResult {
                        contract_id: ref __self_0_0,
                        contract_call_result: ref __self_0_1,
                        error_message: ref __self_0_2,
                        bloom: ref __self_0_3,
                        gas_used: ref __self_0_4,
                        log_info: ref __self_0_5,
                        created_contract_i_ds: ref __self_0_6,
                        state_changes: ref __self_0_7,
                        evm_address: ref __self_0_8,
                        gas: ref __self_0_9,
                        amount: ref __self_0_10,
                        function_parameters: ref __self_0_11,
                        sender_id: ref __self_0_12,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                            && (*__self_0_11) == (*__self_1_11)
                            && (*__self_0_12) == (*__self_1_12)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractFunctionResult) -> bool {
            match *other {
                ContractFunctionResult {
                    contract_id: ref __self_1_0,
                    contract_call_result: ref __self_1_1,
                    error_message: ref __self_1_2,
                    bloom: ref __self_1_3,
                    gas_used: ref __self_1_4,
                    log_info: ref __self_1_5,
                    created_contract_i_ds: ref __self_1_6,
                    state_changes: ref __self_1_7,
                    evm_address: ref __self_1_8,
                    gas: ref __self_1_9,
                    amount: ref __self_1_10,
                    function_parameters: ref __self_1_11,
                    sender_id: ref __self_1_12,
                } => match *self {
                    ContractFunctionResult {
                        contract_id: ref __self_0_0,
                        contract_call_result: ref __self_0_1,
                        error_message: ref __self_0_2,
                        bloom: ref __self_0_3,
                        gas_used: ref __self_0_4,
                        log_info: ref __self_0_5,
                        created_contract_i_ds: ref __self_0_6,
                        state_changes: ref __self_0_7,
                        evm_address: ref __self_0_8,
                        gas: ref __self_0_9,
                        amount: ref __self_0_10,
                        function_parameters: ref __self_0_11,
                        sender_id: ref __self_0_12,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                            || (*__self_0_11) != (*__self_1_11)
                            || (*__self_0_12) != (*__self_1_12)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ContractFunctionResult {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.contract_call_result != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.contract_call_result, buf);
            }
            if self.error_message != "" {
                ::prost::encoding::string::encode(3u32, &self.error_message, buf);
            }
            if self.bloom != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.bloom, buf);
            }
            if self.gas_used != 0u64 {
                ::prost::encoding::uint64::encode(5u32, &self.gas_used, buf);
            }
            for msg in &self.log_info {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            for msg in &self.created_contract_i_ds {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            for msg in &self.state_changes {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
            if let Some(ref msg) = self.evm_address {
                ::prost::encoding::message::encode(9u32, msg, buf);
            }
            if self.gas != 0i64 {
                ::prost::encoding::int64::encode(10u32, &self.gas, buf);
            }
            if self.amount != 0i64 {
                ::prost::encoding::int64::encode(11u32, &self.amount, buf);
            }
            if self.function_parameters != b"" as &[u8] {
                ::prost::encoding::bytes::encode(12u32, &self.function_parameters, buf);
            }
            if let Some(ref msg) = self.sender_id {
                ::prost::encoding::message::encode(13u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractFunctionResult";
            match tag {
                1u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.contract_call_result;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "contract_call_result");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.error_message;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "error_message");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.bloom;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "bloom");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.gas_used;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "gas_used");
                            error
                        },
                    )
                }
                6u32 => {
                    let mut value = &mut self.log_info;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "log_info");
                            error
                        },
                    )
                }
                7u32 => {
                    let mut value = &mut self.created_contract_i_ds;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "created_contract_i_ds");
                            error
                        },
                    )
                }
                8u32 => {
                    let mut value = &mut self.state_changes;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "state_changes");
                            error
                        },
                    )
                }
                9u32 => {
                    let mut value = &mut self.evm_address;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "evm_address");
                        error
                    })
                }
                10u32 => {
                    let mut value = &mut self.gas;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "gas");
                            error
                        },
                    )
                }
                11u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                12u32 => {
                    let mut value = &mut self.function_parameters;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "function_parameters");
                            error
                        },
                    )
                }
                13u32 => {
                    let mut value = &mut self.sender_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "sender_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .contract_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.contract_call_result != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(2u32, &self.contract_call_result)
                } else {
                    0
                }
                + if self.error_message != "" {
                    ::prost::encoding::string::encoded_len(3u32, &self.error_message)
                } else {
                    0
                }
                + if self.bloom != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(4u32, &self.bloom)
                } else {
                    0
                }
                + if self.gas_used != 0u64 {
                    ::prost::encoding::uint64::encoded_len(5u32, &self.gas_used)
                } else {
                    0
                }
                + ::prost::encoding::message::encoded_len_repeated(6u32, &self.log_info)
                + ::prost::encoding::message::encoded_len_repeated(
                    7u32,
                    &self.created_contract_i_ds,
                )
                + ::prost::encoding::message::encoded_len_repeated(8u32, &self.state_changes)
                + self
                    .evm_address
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(9u32, msg))
                + if self.gas != 0i64 {
                    ::prost::encoding::int64::encoded_len(10u32, &self.gas)
                } else {
                    0
                }
                + if self.amount != 0i64 {
                    ::prost::encoding::int64::encoded_len(11u32, &self.amount)
                } else {
                    0
                }
                + if self.function_parameters != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(12u32, &self.function_parameters)
                } else {
                    0
                }
                + self
                    .sender_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(13u32, msg))
        }
        fn clear(&mut self) {
            self.contract_id = ::core::option::Option::None;
            self.contract_call_result.clear();
            self.error_message.clear();
            self.bloom.clear();
            self.gas_used = 0u64;
            self.log_info.clear();
            self.created_contract_i_ds.clear();
            self.state_changes.clear();
            self.evm_address = ::core::option::Option::None;
            self.gas = 0i64;
            self.amount = 0i64;
            self.function_parameters.clear();
            self.sender_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ContractFunctionResult {
        fn default() -> Self {
            ContractFunctionResult {
                contract_id: ::core::default::Default::default(),
                contract_call_result: ::core::default::Default::default(),
                error_message: ::prost::alloc::string::String::new(),
                bloom: ::core::default::Default::default(),
                gas_used: 0u64,
                log_info: ::core::default::Default::default(),
                created_contract_i_ds: ::core::default::Default::default(),
                state_changes: ::core::default::Default::default(),
                evm_address: ::core::default::Default::default(),
                gas: 0i64,
                amount: 0i64,
                function_parameters: ::core::default::Default::default(),
                sender_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractFunctionResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractFunctionResult");
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.contract_call_result)
                };
                builder.field("contract_call_result", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.error_message)
                };
                builder.field("error_message", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.bloom)
                };
                builder.field("bloom", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.gas_used)
                };
                builder.field("gas_used", &wrapper)
            };
            let builder = {
                let wrapper = &self.log_info;
                builder.field("log_info", &wrapper)
            };
            let builder = {
                let wrapper = &self.created_contract_i_ds;
                builder.field("created_contract_i_ds", &wrapper)
            };
            let builder = {
                let wrapper = &self.state_changes;
                builder.field("state_changes", &wrapper)
            };
            let builder = {
                let wrapper = &self.evm_address;
                builder.field("evm_address", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.gas)
                };
                builder.field("gas", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.function_parameters)
                };
                builder.field("function_parameters", &wrapper)
            };
            let builder = {
                let wrapper = &self.sender_id;
                builder.field("sender_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Call a function of the given smart contract instance, giving it functionParameters as its inputs.
    /// This is performed locally on the particular node that the client is communicating with.
    /// It cannot change the state of the contract instance (and so, cannot spend anything from the instance's cryptocurrency account).
    /// It will not have a consensus timestamp. It cannot generate a record or a receipt. The response will contain the output
    /// returned by the function call.  This is useful for calling getter functions, which purely read the state and don't change it.
    /// It is faster and cheaper than a normal call, because it is purely local to a single  node.
    ///
    /// Unlike a ContractCall transaction, the node will consume the entire amount of provided gas in determining
    /// the fee for this query.
    pub struct ContractCallLocalQuery {
        /// standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither). The payment must cover the fees and all of the gas offered.
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The contract to make a static call against
        #[prost(message, optional, tag = "2")]
        pub contract_id: ::core::option::Option<ContractId>,
        /// The amount of gas to use for the call; all of the gas offered will be used and charged a corresponding fee
        #[prost(int64, tag = "3")]
        pub gas: i64,
        /// which function to call, and the parameters to pass to the function
        #[prost(bytes = "vec", tag = "4")]
        pub function_parameters: ::prost::alloc::vec::Vec<u8>,
        /// max number of bytes that the result might include. The run will fail if it would have returned more than this number of bytes.
        #[deprecated]
        #[prost(int64, tag = "5")]
        pub max_result_size: i64,
        /// The account that is the "sender." If not present it is the accountId from the transactionId.
        /// Typically a different value than specified in the transactionId requires a valid signature
        /// over either the hedera transaction or foreign transaction data.
        #[prost(message, optional, tag = "6")]
        pub sender_id: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractCallLocalQuery {
        #[inline]
        fn clone(&self) -> ContractCallLocalQuery {
            match *self {
                ContractCallLocalQuery {
                    header: ref __self_0_0,
                    contract_id: ref __self_0_1,
                    gas: ref __self_0_2,
                    function_parameters: ref __self_0_3,
                    max_result_size: ref __self_0_4,
                    sender_id: ref __self_0_5,
                } => ContractCallLocalQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    gas: ::core::clone::Clone::clone(&(*__self_0_2)),
                    function_parameters: ::core::clone::Clone::clone(&(*__self_0_3)),
                    max_result_size: ::core::clone::Clone::clone(&(*__self_0_4)),
                    sender_id: ::core::clone::Clone::clone(&(*__self_0_5)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractCallLocalQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractCallLocalQuery {
        #[inline]
        fn eq(&self, other: &ContractCallLocalQuery) -> bool {
            match *other {
                ContractCallLocalQuery {
                    header: ref __self_1_0,
                    contract_id: ref __self_1_1,
                    gas: ref __self_1_2,
                    function_parameters: ref __self_1_3,
                    max_result_size: ref __self_1_4,
                    sender_id: ref __self_1_5,
                } => match *self {
                    ContractCallLocalQuery {
                        header: ref __self_0_0,
                        contract_id: ref __self_0_1,
                        gas: ref __self_0_2,
                        function_parameters: ref __self_0_3,
                        max_result_size: ref __self_0_4,
                        sender_id: ref __self_0_5,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractCallLocalQuery) -> bool {
            match *other {
                ContractCallLocalQuery {
                    header: ref __self_1_0,
                    contract_id: ref __self_1_1,
                    gas: ref __self_1_2,
                    function_parameters: ref __self_1_3,
                    max_result_size: ref __self_1_4,
                    sender_id: ref __self_1_5,
                } => match *self {
                    ContractCallLocalQuery {
                        header: ref __self_0_0,
                        contract_id: ref __self_0_1,
                        gas: ref __self_0_2,
                        function_parameters: ref __self_0_3,
                        max_result_size: ref __self_0_4,
                        sender_id: ref __self_0_5,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ContractCallLocalQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.gas != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.gas, buf);
            }
            if self.function_parameters != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.function_parameters, buf);
            }
            if self.max_result_size != 0i64 {
                ::prost::encoding::int64::encode(5u32, &self.max_result_size, buf);
            }
            if let Some(ref msg) = self.sender_id {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractCallLocalQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.gas;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "gas");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.function_parameters;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "function_parameters");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.max_result_size;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "max_result_size");
                            error
                        },
                    )
                }
                6u32 => {
                    let mut value = &mut self.sender_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "sender_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .contract_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.gas != 0i64 {
                    ::prost::encoding::int64::encoded_len(3u32, &self.gas)
                } else {
                    0
                }
                + if self.function_parameters != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(4u32, &self.function_parameters)
                } else {
                    0
                }
                + if self.max_result_size != 0i64 {
                    ::prost::encoding::int64::encoded_len(5u32, &self.max_result_size)
                } else {
                    0
                }
                + self
                    .sender_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.contract_id = ::core::option::Option::None;
            self.gas = 0i64;
            self.function_parameters.clear();
            self.max_result_size = 0i64;
            self.sender_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ContractCallLocalQuery {
        fn default() -> Self {
            ContractCallLocalQuery {
                header: ::core::default::Default::default(),
                contract_id: ::core::default::Default::default(),
                gas: 0i64,
                function_parameters: ::core::default::Default::default(),
                max_result_size: 0i64,
                sender_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractCallLocalQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractCallLocalQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.gas)
                };
                builder.field("gas", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.function_parameters)
                };
                builder.field("function_parameters", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.max_result_size)
                };
                builder.field("max_result_size", &wrapper)
            };
            let builder = {
                let wrapper = &self.sender_id;
                builder.field("sender_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node ContractCallLocalQuery
    pub struct ContractCallLocalResponse {
        /// standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// the value returned by the function (if it completed and didn't fail)
        #[prost(message, optional, tag = "2")]
        pub function_result: ::core::option::Option<ContractFunctionResult>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractCallLocalResponse {
        #[inline]
        fn clone(&self) -> ContractCallLocalResponse {
            match *self {
                ContractCallLocalResponse {
                    header: ref __self_0_0,
                    function_result: ref __self_0_1,
                } => ContractCallLocalResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    function_result: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractCallLocalResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractCallLocalResponse {
        #[inline]
        fn eq(&self, other: &ContractCallLocalResponse) -> bool {
            match *other {
                ContractCallLocalResponse {
                    header: ref __self_1_0,
                    function_result: ref __self_1_1,
                } => match *self {
                    ContractCallLocalResponse {
                        header: ref __self_0_0,
                        function_result: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractCallLocalResponse) -> bool {
            match *other {
                ContractCallLocalResponse {
                    header: ref __self_1_0,
                    function_result: ref __self_1_1,
                } => match *self {
                    ContractCallLocalResponse {
                        header: ref __self_0_0,
                        function_result: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ContractCallLocalResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.function_result {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractCallLocalResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.function_result;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "function_result");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .function_result
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.function_result = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ContractCallLocalResponse {
        fn default() -> Self {
            ContractCallLocalResponse {
                header: ::core::default::Default::default(),
                function_result: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractCallLocalResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractCallLocalResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.function_result;
                builder.field("function_result", &wrapper)
            };
            builder.finish()
        }
    }
    /// The storage changes to a smart contract's storage as a side effect of the function call.
    pub struct ContractStateChange {
        /// The contract to which the storage changes apply to
        #[prost(message, optional, tag = "1")]
        pub contract_id: ::core::option::Option<ContractId>,
        /// The list of storage changes.
        #[prost(message, repeated, tag = "2")]
        pub storage_changes: ::prost::alloc::vec::Vec<StorageChange>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractStateChange {
        #[inline]
        fn clone(&self) -> ContractStateChange {
            match *self {
                ContractStateChange {
                    contract_id: ref __self_0_0,
                    storage_changes: ref __self_0_1,
                } => ContractStateChange {
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    storage_changes: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractStateChange {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractStateChange {
        #[inline]
        fn eq(&self, other: &ContractStateChange) -> bool {
            match *other {
                ContractStateChange {
                    contract_id: ref __self_1_0,
                    storage_changes: ref __self_1_1,
                } => match *self {
                    ContractStateChange {
                        contract_id: ref __self_0_0,
                        storage_changes: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractStateChange) -> bool {
            match *other {
                ContractStateChange {
                    contract_id: ref __self_1_0,
                    storage_changes: ref __self_1_1,
                } => match *self {
                    ContractStateChange {
                        contract_id: ref __self_0_0,
                        storage_changes: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ContractStateChange {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.storage_changes {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractStateChange";
            match tag {
                1u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.storage_changes;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "storage_changes");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .contract_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.storage_changes)
        }
        fn clear(&mut self) {
            self.contract_id = ::core::option::Option::None;
            self.storage_changes.clear();
        }
    }
    impl ::core::default::Default for ContractStateChange {
        fn default() -> Self {
            ContractStateChange {
                contract_id: ::core::default::Default::default(),
                storage_changes: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractStateChange {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractStateChange");
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.storage_changes;
                builder.field("storage_changes", &wrapper)
            };
            builder.finish()
        }
    }
    /// A storage slot change description.
    pub struct StorageChange {
        /// The storage slot changed.  Up to 32 bytes, big-endian, zero bytes left trimmed.
        #[prost(bytes = "vec", tag = "1")]
        pub slot: ::prost::alloc::vec::Vec<u8>,
        /// The value read from the storage slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
        ///
        /// Because of the way SSTORE operations are charged the slot is always read before being written to.
        #[prost(bytes = "vec", tag = "2")]
        pub value_read: ::prost::alloc::vec::Vec<u8>,
        /// The new value written to the slot.  Up to 32 bytes, big-endian, zero bytes left trimmed.
        ///
        /// If a value of zero is written the valueWritten will be present but the inner value will be absent.
        ///
        /// If a value was read and not written this value will not be present.
        #[prost(message, optional, tag = "3")]
        pub value_written: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StorageChange {
        #[inline]
        fn clone(&self) -> StorageChange {
            match *self {
                StorageChange {
                    slot: ref __self_0_0,
                    value_read: ref __self_0_1,
                    value_written: ref __self_0_2,
                } => StorageChange {
                    slot: ::core::clone::Clone::clone(&(*__self_0_0)),
                    value_read: ::core::clone::Clone::clone(&(*__self_0_1)),
                    value_written: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for StorageChange {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StorageChange {
        #[inline]
        fn eq(&self, other: &StorageChange) -> bool {
            match *other {
                StorageChange {
                    slot: ref __self_1_0,
                    value_read: ref __self_1_1,
                    value_written: ref __self_1_2,
                } => match *self {
                    StorageChange {
                        slot: ref __self_0_0,
                        value_read: ref __self_0_1,
                        value_written: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &StorageChange) -> bool {
            match *other {
                StorageChange {
                    slot: ref __self_1_0,
                    value_read: ref __self_1_1,
                    value_written: ref __self_1_2,
                } => match *self {
                    StorageChange {
                        slot: ref __self_0_0,
                        value_read: ref __self_0_1,
                        value_written: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for StorageChange {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.slot != b"" as &[u8] {
                ::prost::encoding::bytes::encode(1u32, &self.slot, buf);
            }
            if self.value_read != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.value_read, buf);
            }
            if let Some(ref msg) = self.value_written {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "StorageChange";
            match tag {
                1u32 => {
                    let mut value = &mut self.slot;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "slot");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.value_read;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "value_read");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.value_written;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "value_written");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.slot != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(1u32, &self.slot)
            } else {
                0
            } + if self.value_read != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(2u32, &self.value_read)
            } else {
                0
            } + self
                .value_written
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
        }
        fn clear(&mut self) {
            self.slot.clear();
            self.value_read.clear();
            self.value_written = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for StorageChange {
        fn default() -> Self {
            StorageChange {
                slot: ::core::default::Default::default(),
                value_read: ::core::default::Default::default(),
                value_written: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for StorageChange {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("StorageChange");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.slot)
                };
                builder.field("slot", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.value_read)
                };
                builder.field("value_read", &wrapper)
            };
            let builder = {
                let wrapper = &self.value_written;
                builder.field("value_written", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node TransactionGetRecordResponse
    pub struct TransactionRecord {
        /// The status (reach consensus, or failed, or is unknown) and the ID of any new
        /// account/file/instance created.
        #[prost(message, optional, tag = "1")]
        pub receipt: ::core::option::Option<TransactionReceipt>,
        /// The hash of the Transaction that executed (not the hash of any Transaction that failed for
        /// having a duplicate TransactionID)
        #[prost(bytes = "vec", tag = "2")]
        pub transaction_hash: ::prost::alloc::vec::Vec<u8>,
        /// The consensus timestamp (or null if didn't reach consensus yet)
        #[prost(message, optional, tag = "3")]
        pub consensus_timestamp: ::core::option::Option<Timestamp>,
        /// The ID of the transaction this record represents
        #[prost(message, optional, tag = "4")]
        pub transaction_id: ::core::option::Option<TransactionId>,
        /// The memo that was submitted as part of the transaction (max 100 bytes)
        #[prost(string, tag = "5")]
        pub memo: ::prost::alloc::string::String,
        /// The actual transaction fee charged, not the original transactionFee value from
        /// TransactionBody
        #[prost(uint64, tag = "6")]
        pub transaction_fee: u64,
        /// All hbar transfers as a result of this transaction, such as fees, or transfers performed by
        /// the transaction, or by a smart contract it calls, or by the creation of threshold records
        /// that it triggers.
        #[prost(message, optional, tag = "10")]
        pub transfer_list: ::core::option::Option<TransferList>,
        /// All Token transfers as a result of this transaction
        #[prost(message, repeated, tag = "11")]
        pub token_transfer_lists: ::prost::alloc::vec::Vec<TokenTransferList>,
        /// Reference to the scheduled transaction ID that this transaction record represent
        #[prost(message, optional, tag = "12")]
        pub schedule_ref: ::core::option::Option<ScheduleId>,
        /// All custom fees that were assessed during a CryptoTransfer, and must be paid if the
        /// transaction status resolved to SUCCESS
        #[prost(message, repeated, tag = "13")]
        pub assessed_custom_fees: ::prost::alloc::vec::Vec<AssessedCustomFee>,
        /// All token associations implicitly created while handling this transaction
        #[prost(message, repeated, tag = "14")]
        pub automatic_token_associations: ::prost::alloc::vec::Vec<TokenAssociation>,
        /// In the record of an internal transaction, the consensus timestamp of the user
        /// transaction that spawned it.
        #[prost(message, optional, tag = "15")]
        pub parent_consensus_timestamp: ::core::option::Option<Timestamp>,
        /// In the record of an internal CryptoCreate transaction triggered by a user
        /// transaction with a (previously unused) alias, the new account's alias.
        #[prost(bytes = "vec", tag = "16")]
        pub alias: ::prost::alloc::vec::Vec<u8>,
        /// The keccak256 hash of the ethereumData. This field will only be populated for
        /// EthereumTransaction.
        #[prost(bytes = "vec", tag = "17")]
        pub ethereum_hash: ::prost::alloc::vec::Vec<u8>,
        /// List of accounts with the corresponding staking rewards paid as a result of a transaction.
        #[prost(message, repeated, tag = "18")]
        pub paid_staking_rewards: ::prost::alloc::vec::Vec<AccountAmount>,
        #[prost(oneof = "transaction_record::Body", tags = "7, 8")]
        pub body: ::core::option::Option<transaction_record::Body>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionRecord {
        #[inline]
        fn clone(&self) -> TransactionRecord {
            match *self {
                TransactionRecord {
                    receipt: ref __self_0_0,
                    transaction_hash: ref __self_0_1,
                    consensus_timestamp: ref __self_0_2,
                    transaction_id: ref __self_0_3,
                    memo: ref __self_0_4,
                    transaction_fee: ref __self_0_5,
                    transfer_list: ref __self_0_6,
                    token_transfer_lists: ref __self_0_7,
                    schedule_ref: ref __self_0_8,
                    assessed_custom_fees: ref __self_0_9,
                    automatic_token_associations: ref __self_0_10,
                    parent_consensus_timestamp: ref __self_0_11,
                    alias: ref __self_0_12,
                    ethereum_hash: ref __self_0_13,
                    paid_staking_rewards: ref __self_0_14,
                    body: ref __self_0_15,
                } => TransactionRecord {
                    receipt: ::core::clone::Clone::clone(&(*__self_0_0)),
                    transaction_hash: ::core::clone::Clone::clone(&(*__self_0_1)),
                    consensus_timestamp: ::core::clone::Clone::clone(&(*__self_0_2)),
                    transaction_id: ::core::clone::Clone::clone(&(*__self_0_3)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_4)),
                    transaction_fee: ::core::clone::Clone::clone(&(*__self_0_5)),
                    transfer_list: ::core::clone::Clone::clone(&(*__self_0_6)),
                    token_transfer_lists: ::core::clone::Clone::clone(&(*__self_0_7)),
                    schedule_ref: ::core::clone::Clone::clone(&(*__self_0_8)),
                    assessed_custom_fees: ::core::clone::Clone::clone(&(*__self_0_9)),
                    automatic_token_associations: ::core::clone::Clone::clone(&(*__self_0_10)),
                    parent_consensus_timestamp: ::core::clone::Clone::clone(&(*__self_0_11)),
                    alias: ::core::clone::Clone::clone(&(*__self_0_12)),
                    ethereum_hash: ::core::clone::Clone::clone(&(*__self_0_13)),
                    paid_staking_rewards: ::core::clone::Clone::clone(&(*__self_0_14)),
                    body: ::core::clone::Clone::clone(&(*__self_0_15)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionRecord {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionRecord {
        #[inline]
        fn eq(&self, other: &TransactionRecord) -> bool {
            match *other {
                TransactionRecord {
                    receipt: ref __self_1_0,
                    transaction_hash: ref __self_1_1,
                    consensus_timestamp: ref __self_1_2,
                    transaction_id: ref __self_1_3,
                    memo: ref __self_1_4,
                    transaction_fee: ref __self_1_5,
                    transfer_list: ref __self_1_6,
                    token_transfer_lists: ref __self_1_7,
                    schedule_ref: ref __self_1_8,
                    assessed_custom_fees: ref __self_1_9,
                    automatic_token_associations: ref __self_1_10,
                    parent_consensus_timestamp: ref __self_1_11,
                    alias: ref __self_1_12,
                    ethereum_hash: ref __self_1_13,
                    paid_staking_rewards: ref __self_1_14,
                    body: ref __self_1_15,
                } => match *self {
                    TransactionRecord {
                        receipt: ref __self_0_0,
                        transaction_hash: ref __self_0_1,
                        consensus_timestamp: ref __self_0_2,
                        transaction_id: ref __self_0_3,
                        memo: ref __self_0_4,
                        transaction_fee: ref __self_0_5,
                        transfer_list: ref __self_0_6,
                        token_transfer_lists: ref __self_0_7,
                        schedule_ref: ref __self_0_8,
                        assessed_custom_fees: ref __self_0_9,
                        automatic_token_associations: ref __self_0_10,
                        parent_consensus_timestamp: ref __self_0_11,
                        alias: ref __self_0_12,
                        ethereum_hash: ref __self_0_13,
                        paid_staking_rewards: ref __self_0_14,
                        body: ref __self_0_15,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                            && (*__self_0_11) == (*__self_1_11)
                            && (*__self_0_12) == (*__self_1_12)
                            && (*__self_0_13) == (*__self_1_13)
                            && (*__self_0_14) == (*__self_1_14)
                            && (*__self_0_15) == (*__self_1_15)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionRecord) -> bool {
            match *other {
                TransactionRecord {
                    receipt: ref __self_1_0,
                    transaction_hash: ref __self_1_1,
                    consensus_timestamp: ref __self_1_2,
                    transaction_id: ref __self_1_3,
                    memo: ref __self_1_4,
                    transaction_fee: ref __self_1_5,
                    transfer_list: ref __self_1_6,
                    token_transfer_lists: ref __self_1_7,
                    schedule_ref: ref __self_1_8,
                    assessed_custom_fees: ref __self_1_9,
                    automatic_token_associations: ref __self_1_10,
                    parent_consensus_timestamp: ref __self_1_11,
                    alias: ref __self_1_12,
                    ethereum_hash: ref __self_1_13,
                    paid_staking_rewards: ref __self_1_14,
                    body: ref __self_1_15,
                } => match *self {
                    TransactionRecord {
                        receipt: ref __self_0_0,
                        transaction_hash: ref __self_0_1,
                        consensus_timestamp: ref __self_0_2,
                        transaction_id: ref __self_0_3,
                        memo: ref __self_0_4,
                        transaction_fee: ref __self_0_5,
                        transfer_list: ref __self_0_6,
                        token_transfer_lists: ref __self_0_7,
                        schedule_ref: ref __self_0_8,
                        assessed_custom_fees: ref __self_0_9,
                        automatic_token_associations: ref __self_0_10,
                        parent_consensus_timestamp: ref __self_0_11,
                        alias: ref __self_0_12,
                        ethereum_hash: ref __self_0_13,
                        paid_staking_rewards: ref __self_0_14,
                        body: ref __self_0_15,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                            || (*__self_0_11) != (*__self_1_11)
                            || (*__self_0_12) != (*__self_1_12)
                            || (*__self_0_13) != (*__self_1_13)
                            || (*__self_0_14) != (*__self_1_14)
                            || (*__self_0_15) != (*__self_1_15)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TransactionRecord {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.receipt {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.transaction_hash != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.transaction_hash, buf);
            }
            if let Some(ref msg) = self.consensus_timestamp {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.transaction_id {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            if self.memo != "" {
                ::prost::encoding::string::encode(5u32, &self.memo, buf);
            }
            if self.transaction_fee != 0u64 {
                ::prost::encoding::uint64::encode(6u32, &self.transaction_fee, buf);
            }
            if let Some(ref oneof) = self.body {
                oneof.encode(buf)
            }
            if let Some(ref msg) = self.transfer_list {
                ::prost::encoding::message::encode(10u32, msg, buf);
            }
            for msg in &self.token_transfer_lists {
                ::prost::encoding::message::encode(11u32, msg, buf);
            }
            if let Some(ref msg) = self.schedule_ref {
                ::prost::encoding::message::encode(12u32, msg, buf);
            }
            for msg in &self.assessed_custom_fees {
                ::prost::encoding::message::encode(13u32, msg, buf);
            }
            for msg in &self.automatic_token_associations {
                ::prost::encoding::message::encode(14u32, msg, buf);
            }
            if let Some(ref msg) = self.parent_consensus_timestamp {
                ::prost::encoding::message::encode(15u32, msg, buf);
            }
            if self.alias != b"" as &[u8] {
                ::prost::encoding::bytes::encode(16u32, &self.alias, buf);
            }
            if self.ethereum_hash != b"" as &[u8] {
                ::prost::encoding::bytes::encode(17u32, &self.ethereum_hash, buf);
            }
            for msg in &self.paid_staking_rewards {
                ::prost::encoding::message::encode(18u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionRecord";
            match tag {
                1u32 => {
                    let mut value = &mut self.receipt;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "receipt");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.transaction_hash;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "transaction_hash");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.consensus_timestamp;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "consensus_timestamp");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.transaction_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transaction_id");
                        error
                    })
                }
                5u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                6u32 => {
                    let mut value = &mut self.transaction_fee;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "transaction_fee");
                            error
                        },
                    )
                }
                7u32 | 8u32 => {
                    let mut value = &mut self.body;
                    transaction_record::Body::merge(value, tag, wire_type, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "body");
                            error
                        },
                    )
                }
                10u32 => {
                    let mut value = &mut self.transfer_list;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transfer_list");
                        error
                    })
                }
                11u32 => {
                    let mut value = &mut self.token_transfer_lists;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "token_transfer_lists");
                            error
                        },
                    )
                }
                12u32 => {
                    let mut value = &mut self.schedule_ref;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "schedule_ref");
                        error
                    })
                }
                13u32 => {
                    let mut value = &mut self.assessed_custom_fees;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "assessed_custom_fees");
                            error
                        },
                    )
                }
                14u32 => {
                    let mut value = &mut self.automatic_token_associations;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "automatic_token_associations");
                            error
                        },
                    )
                }
                15u32 => {
                    let mut value = &mut self.parent_consensus_timestamp;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "parent_consensus_timestamp");
                        error
                    })
                }
                16u32 => {
                    let mut value = &mut self.alias;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "alias");
                            error
                        },
                    )
                }
                17u32 => {
                    let mut value = &mut self.ethereum_hash;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "ethereum_hash");
                            error
                        },
                    )
                }
                18u32 => {
                    let mut value = &mut self.paid_staking_rewards;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "paid_staking_rewards");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .receipt
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.transaction_hash != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(2u32, &self.transaction_hash)
                } else {
                    0
                }
                + self
                    .consensus_timestamp
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .transaction_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + if self.memo != "" {
                    ::prost::encoding::string::encoded_len(5u32, &self.memo)
                } else {
                    0
                }
                + if self.transaction_fee != 0u64 {
                    ::prost::encoding::uint64::encoded_len(6u32, &self.transaction_fee)
                } else {
                    0
                }
                + self
                    .body
                    .as_ref()
                    .map_or(0, transaction_record::Body::encoded_len)
                + self
                    .transfer_list
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(10u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(
                    11u32,
                    &self.token_transfer_lists,
                )
                + self
                    .schedule_ref
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(12u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(
                    13u32,
                    &self.assessed_custom_fees,
                )
                + ::prost::encoding::message::encoded_len_repeated(
                    14u32,
                    &self.automatic_token_associations,
                )
                + self
                    .parent_consensus_timestamp
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(15u32, msg))
                + if self.alias != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(16u32, &self.alias)
                } else {
                    0
                }
                + if self.ethereum_hash != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(17u32, &self.ethereum_hash)
                } else {
                    0
                }
                + ::prost::encoding::message::encoded_len_repeated(
                    18u32,
                    &self.paid_staking_rewards,
                )
        }
        fn clear(&mut self) {
            self.receipt = ::core::option::Option::None;
            self.transaction_hash.clear();
            self.consensus_timestamp = ::core::option::Option::None;
            self.transaction_id = ::core::option::Option::None;
            self.memo.clear();
            self.transaction_fee = 0u64;
            self.body = ::core::option::Option::None;
            self.transfer_list = ::core::option::Option::None;
            self.token_transfer_lists.clear();
            self.schedule_ref = ::core::option::Option::None;
            self.assessed_custom_fees.clear();
            self.automatic_token_associations.clear();
            self.parent_consensus_timestamp = ::core::option::Option::None;
            self.alias.clear();
            self.ethereum_hash.clear();
            self.paid_staking_rewards.clear();
        }
    }
    impl ::core::default::Default for TransactionRecord {
        fn default() -> Self {
            TransactionRecord {
                receipt: ::core::default::Default::default(),
                transaction_hash: ::core::default::Default::default(),
                consensus_timestamp: ::core::default::Default::default(),
                transaction_id: ::core::default::Default::default(),
                memo: ::prost::alloc::string::String::new(),
                transaction_fee: 0u64,
                body: ::core::default::Default::default(),
                transfer_list: ::core::default::Default::default(),
                token_transfer_lists: ::core::default::Default::default(),
                schedule_ref: ::core::default::Default::default(),
                assessed_custom_fees: ::core::default::Default::default(),
                automatic_token_associations: ::core::default::Default::default(),
                parent_consensus_timestamp: ::core::default::Default::default(),
                alias: ::core::default::Default::default(),
                ethereum_hash: ::core::default::Default::default(),
                paid_staking_rewards: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TransactionRecord {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionRecord");
            let builder = {
                let wrapper = &self.receipt;
                builder.field("receipt", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.transaction_hash)
                };
                builder.field("transaction_hash", &wrapper)
            };
            let builder = {
                let wrapper = &self.consensus_timestamp;
                builder.field("consensus_timestamp", &wrapper)
            };
            let builder = {
                let wrapper = &self.transaction_id;
                builder.field("transaction_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.transaction_fee)
                };
                builder.field("transaction_fee", &wrapper)
            };
            let builder = {
                let wrapper = &self.transfer_list;
                builder.field("transfer_list", &wrapper)
            };
            let builder = {
                let wrapper = &self.token_transfer_lists;
                builder.field("token_transfer_lists", &wrapper)
            };
            let builder = {
                let wrapper = &self.schedule_ref;
                builder.field("schedule_ref", &wrapper)
            };
            let builder = {
                let wrapper = &self.assessed_custom_fees;
                builder.field("assessed_custom_fees", &wrapper)
            };
            let builder = {
                let wrapper = &self.automatic_token_associations;
                builder.field("automatic_token_associations", &wrapper)
            };
            let builder = {
                let wrapper = &self.parent_consensus_timestamp;
                builder.field("parent_consensus_timestamp", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.alias)
                };
                builder.field("alias", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.ethereum_hash)
                };
                builder.field("ethereum_hash", &wrapper)
            };
            let builder = {
                let wrapper = &self.paid_staking_rewards;
                builder.field("paid_staking_rewards", &wrapper)
            };
            let builder = {
                let wrapper = &self.body;
                builder.field("body", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `TransactionRecord`.
    pub mod transaction_record {
        pub enum Body {
            /// Record of the value returned by the smart contract function (if it completed and didn't
            /// fail) from ContractCallTransaction
            #[prost(message, tag = "7")]
            ContractCallResult(super::ContractFunctionResult),
            /// Record of the value returned by the smart contract constructor (if it completed and
            /// didn't fail) from ContractCreateTransaction
            #[prost(message, tag = "8")]
            ContractCreateResult(super::ContractFunctionResult),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Body {
            #[inline]
            fn clone(&self) -> Body {
                match (&*self,) {
                    (&Body::ContractCallResult(ref __self_0),) => {
                        Body::ContractCallResult(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Body::ContractCreateResult(ref __self_0),) => {
                        Body::ContractCreateResult(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Body {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Body {
            #[inline]
            fn eq(&self, other: &Body) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Body::ContractCallResult(ref __self_0),
                                &Body::ContractCallResult(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Body::ContractCreateResult(ref __self_0),
                                &Body::ContractCreateResult(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Body) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Body::ContractCallResult(ref __self_0),
                                &Body::ContractCallResult(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Body::ContractCreateResult(ref __self_0),
                                &Body::ContractCreateResult(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Body {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Body::ContractCallResult(ref value) => {
                        ::prost::encoding::message::encode(7u32, &*value, buf);
                    }
                    Body::ContractCreateResult(ref value) => {
                        ::prost::encoding::message::encode(8u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Body>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    7u32 => match field {
                        ::core::option::Option::Some(Body::ContractCallResult(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Body::ContractCallResult(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    8u32 => match field {
                        ::core::option::Option::Some(Body::ContractCreateResult(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Body::ContractCreateResult(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Body tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Body::ContractCallResult(ref value) => {
                        ::prost::encoding::message::encoded_len(7u32, &*value)
                    }
                    Body::ContractCreateResult(ref value) => {
                        ::prost::encoding::message::encoded_len(8u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Body {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Body::ContractCallResult(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractCallResult").field(&wrapper).finish()
                    }
                    Body::ContractCreateResult(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractCreateResult")
                            .field(&wrapper)
                            .finish()
                    }
                }
            }
        }
    }
    /// Get the record for a transaction. If the transaction requested a record, then the record lasts
    /// for one hour, and a state proof is available for it. If the transaction created an account, file,
    /// or smart contract instance, then the record will contain the ID for what it created. If the
    /// transaction called a smart contract function, then the record contains the result of that call.
    /// If the transaction was a cryptocurrency transfer, then the record includes the TransferList which
    /// gives the details of that transfer. If the transaction didn't return anything that should be in
    /// the record, then the results field will be set to nothing.
    pub struct TransactionGetRecordQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The ID of the transaction for which the record is requested.
        #[prost(message, optional, tag = "2")]
        pub transaction_id: ::core::option::Option<TransactionId>,
        /// Whether records of processing duplicate transactions should be returned along with the record
        /// of processing the first consensus transaction with the given id whose status was neither
        /// <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no such
        /// record exists, the record of processing the first transaction to reach consensus with the
        /// given transaction id..
        #[prost(bool, tag = "3")]
        pub include_duplicates: bool,
        /// Whether the response should include the records of any child transactions spawned by the
        /// top-level transaction with the given transactionID.
        #[prost(bool, tag = "4")]
        pub include_child_records: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionGetRecordQuery {
        #[inline]
        fn clone(&self) -> TransactionGetRecordQuery {
            match *self {
                TransactionGetRecordQuery {
                    header: ref __self_0_0,
                    transaction_id: ref __self_0_1,
                    include_duplicates: ref __self_0_2,
                    include_child_records: ref __self_0_3,
                } => TransactionGetRecordQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    transaction_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    include_duplicates: ::core::clone::Clone::clone(&(*__self_0_2)),
                    include_child_records: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionGetRecordQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionGetRecordQuery {
        #[inline]
        fn eq(&self, other: &TransactionGetRecordQuery) -> bool {
            match *other {
                TransactionGetRecordQuery {
                    header: ref __self_1_0,
                    transaction_id: ref __self_1_1,
                    include_duplicates: ref __self_1_2,
                    include_child_records: ref __self_1_3,
                } => match *self {
                    TransactionGetRecordQuery {
                        header: ref __self_0_0,
                        transaction_id: ref __self_0_1,
                        include_duplicates: ref __self_0_2,
                        include_child_records: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionGetRecordQuery) -> bool {
            match *other {
                TransactionGetRecordQuery {
                    header: ref __self_1_0,
                    transaction_id: ref __self_1_1,
                    include_duplicates: ref __self_1_2,
                    include_child_records: ref __self_1_3,
                } => match *self {
                    TransactionGetRecordQuery {
                        header: ref __self_0_0,
                        transaction_id: ref __self_0_1,
                        include_duplicates: ref __self_0_2,
                        include_child_records: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TransactionGetRecordQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.transaction_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.include_duplicates != false {
                ::prost::encoding::bool::encode(3u32, &self.include_duplicates, buf);
            }
            if self.include_child_records != false {
                ::prost::encoding::bool::encode(4u32, &self.include_child_records, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionGetRecordQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.transaction_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transaction_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.include_duplicates;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "include_duplicates");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.include_child_records;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "include_child_records");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .transaction_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.include_duplicates != false {
                    ::prost::encoding::bool::encoded_len(3u32, &self.include_duplicates)
                } else {
                    0
                }
                + if self.include_child_records != false {
                    ::prost::encoding::bool::encoded_len(4u32, &self.include_child_records)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.transaction_id = ::core::option::Option::None;
            self.include_duplicates = false;
            self.include_child_records = false;
        }
    }
    impl ::core::default::Default for TransactionGetRecordQuery {
        fn default() -> Self {
            TransactionGetRecordQuery {
                header: ::core::default::Default::default(),
                transaction_id: ::core::default::Default::default(),
                include_duplicates: false,
                include_child_records: false,
            }
        }
    }
    impl ::core::fmt::Debug for TransactionGetRecordQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionGetRecordQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.transaction_id;
                builder.field("transaction_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.include_duplicates)
                };
                builder.field("include_duplicates", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.include_child_records)
                };
                builder.field("include_child_records", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node TransactionGetRecordQuery
    pub struct TransactionGetRecordResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither.
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// Either the record of processing the first consensus transaction with the given id whose
        /// status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
        /// <b>or</b>, if no such record exists, the record of processing the first transaction to reach
        /// consensus with the given transaction id.
        #[prost(message, optional, tag = "3")]
        pub transaction_record: ::core::option::Option<TransactionRecord>,
        /// The records of processing all consensus transaction with the same id as the distinguished
        /// record above, in chronological order.
        #[prost(message, repeated, tag = "4")]
        pub duplicate_transaction_records: ::prost::alloc::vec::Vec<TransactionRecord>,
        /// The records of processing all child transaction spawned by the transaction with the given
        /// top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
        #[prost(message, repeated, tag = "5")]
        pub child_transaction_records: ::prost::alloc::vec::Vec<TransactionRecord>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionGetRecordResponse {
        #[inline]
        fn clone(&self) -> TransactionGetRecordResponse {
            match *self {
                TransactionGetRecordResponse {
                    header: ref __self_0_0,
                    transaction_record: ref __self_0_1,
                    duplicate_transaction_records: ref __self_0_2,
                    child_transaction_records: ref __self_0_3,
                } => TransactionGetRecordResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    transaction_record: ::core::clone::Clone::clone(&(*__self_0_1)),
                    duplicate_transaction_records: ::core::clone::Clone::clone(&(*__self_0_2)),
                    child_transaction_records: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionGetRecordResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionGetRecordResponse {
        #[inline]
        fn eq(&self, other: &TransactionGetRecordResponse) -> bool {
            match *other {
                TransactionGetRecordResponse {
                    header: ref __self_1_0,
                    transaction_record: ref __self_1_1,
                    duplicate_transaction_records: ref __self_1_2,
                    child_transaction_records: ref __self_1_3,
                } => match *self {
                    TransactionGetRecordResponse {
                        header: ref __self_0_0,
                        transaction_record: ref __self_0_1,
                        duplicate_transaction_records: ref __self_0_2,
                        child_transaction_records: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionGetRecordResponse) -> bool {
            match *other {
                TransactionGetRecordResponse {
                    header: ref __self_1_0,
                    transaction_record: ref __self_1_1,
                    duplicate_transaction_records: ref __self_1_2,
                    child_transaction_records: ref __self_1_3,
                } => match *self {
                    TransactionGetRecordResponse {
                        header: ref __self_0_0,
                        transaction_record: ref __self_0_1,
                        duplicate_transaction_records: ref __self_0_2,
                        child_transaction_records: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TransactionGetRecordResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.transaction_record {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            for msg in &self.duplicate_transaction_records {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            for msg in &self.child_transaction_records {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionGetRecordResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.transaction_record;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transaction_record");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.duplicate_transaction_records;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "duplicate_transaction_records");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.child_transaction_records;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "child_transaction_records");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .transaction_record
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(
                    4u32,
                    &self.duplicate_transaction_records,
                )
                + ::prost::encoding::message::encoded_len_repeated(
                    5u32,
                    &self.child_transaction_records,
                )
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.transaction_record = ::core::option::Option::None;
            self.duplicate_transaction_records.clear();
            self.child_transaction_records.clear();
        }
    }
    impl ::core::default::Default for TransactionGetRecordResponse {
        fn default() -> Self {
            TransactionGetRecordResponse {
                header: ::core::default::Default::default(),
                transaction_record: ::core::default::Default::default(),
                duplicate_transaction_records: ::core::default::Default::default(),
                child_transaction_records: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TransactionGetRecordResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionGetRecordResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.transaction_record;
                builder.field("transaction_record", &wrapper)
            };
            let builder = {
                let wrapper = &self.duplicate_transaction_records;
                builder.field("duplicate_transaction_records", &wrapper)
            };
            let builder = {
                let wrapper = &self.child_transaction_records;
                builder.field("child_transaction_records", &wrapper)
            };
            builder.finish()
        }
    }
    /// Get all accounts, claims, files, and smart contract instances whose associated keys include the
    /// given Key. The given Key must not be a contractID or a ThresholdKey. This is not yet implemented
    /// in the API, but will be in the future.
    pub struct GetByKeyQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The key to search for. It must not contain a contractID nor a ThresholdSignature.
        #[prost(message, optional, tag = "2")]
        pub key: ::core::option::Option<Key>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for GetByKeyQuery {
        #[inline]
        fn clone(&self) -> GetByKeyQuery {
            match *self {
                GetByKeyQuery {
                    header: ref __self_0_0,
                    key: ref __self_0_1,
                } => GetByKeyQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    key: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for GetByKeyQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for GetByKeyQuery {
        #[inline]
        fn eq(&self, other: &GetByKeyQuery) -> bool {
            match *other {
                GetByKeyQuery {
                    header: ref __self_1_0,
                    key: ref __self_1_1,
                } => match *self {
                    GetByKeyQuery {
                        header: ref __self_0_0,
                        key: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GetByKeyQuery) -> bool {
            match *other {
                GetByKeyQuery {
                    header: ref __self_1_0,
                    key: ref __self_1_1,
                } => match *self {
                    GetByKeyQuery {
                        header: ref __self_0_0,
                        key: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for GetByKeyQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.key {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "GetByKeyQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "key");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.key = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for GetByKeyQuery {
        fn default() -> Self {
            GetByKeyQuery {
                header: ::core::default::Default::default(),
                key: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for GetByKeyQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("GetByKeyQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.key;
                builder.field("key", &wrapper)
            };
            builder.finish()
        }
    }
    /// the ID for a single entity (account, livehash, file, or smart contract instance)
    pub struct EntityId {
        #[prost(oneof = "entity_id::Entity", tags = "1, 2, 3, 4")]
        pub entity: ::core::option::Option<entity_id::Entity>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for EntityId {
        #[inline]
        fn clone(&self) -> EntityId {
            match *self {
                EntityId {
                    entity: ref __self_0_0,
                } => EntityId {
                    entity: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for EntityId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for EntityId {
        #[inline]
        fn eq(&self, other: &EntityId) -> bool {
            match *other {
                EntityId {
                    entity: ref __self_1_0,
                } => match *self {
                    EntityId {
                        entity: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &EntityId) -> bool {
            match *other {
                EntityId {
                    entity: ref __self_1_0,
                } => match *self {
                    EntityId {
                        entity: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for EntityId {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.entity {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "EntityId";
            match tag {
                1u32 | 2u32 | 3u32 | 4u32 => {
                    let mut value = &mut self.entity;
                    entity_id::Entity::merge(value, tag, wire_type, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "entity");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .entity
                .as_ref()
                .map_or(0, entity_id::Entity::encoded_len)
        }
        fn clear(&mut self) {
            self.entity = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for EntityId {
        fn default() -> Self {
            EntityId {
                entity: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for EntityId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("EntityId");
            let builder = {
                let wrapper = &self.entity;
                builder.field("entity", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `EntityID`.
    pub mod entity_id {
        pub enum Entity {
            /// The Account ID for the cryptocurrency account
            #[prost(message, tag = "1")]
            AccountId(super::AccountId),
            /// A uniquely identifying livehash of an acount
            #[prost(message, tag = "2")]
            LiveHash(super::LiveHash),
            /// The file ID of the file
            #[prost(message, tag = "3")]
            FileId(super::FileId),
            /// The smart contract ID that identifies instance
            #[prost(message, tag = "4")]
            ContractId(super::ContractId),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Entity {
            #[inline]
            fn clone(&self) -> Entity {
                match (&*self,) {
                    (&Entity::AccountId(ref __self_0),) => {
                        Entity::AccountId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Entity::LiveHash(ref __self_0),) => {
                        Entity::LiveHash(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Entity::FileId(ref __self_0),) => {
                        Entity::FileId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Entity::ContractId(ref __self_0),) => {
                        Entity::ContractId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Entity {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Entity {
            #[inline]
            fn eq(&self, other: &Entity) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Entity::AccountId(ref __self_0),
                                &Entity::AccountId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (&Entity::LiveHash(ref __self_0), &Entity::LiveHash(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (&Entity::FileId(ref __self_0), &Entity::FileId(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Entity::ContractId(ref __self_0),
                                &Entity::ContractId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Entity) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Entity::AccountId(ref __self_0),
                                &Entity::AccountId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (&Entity::LiveHash(ref __self_0), &Entity::LiveHash(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (&Entity::FileId(ref __self_0), &Entity::FileId(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Entity::ContractId(ref __self_0),
                                &Entity::ContractId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Entity {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Entity::AccountId(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                    Entity::LiveHash(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    Entity::FileId(ref value) => {
                        ::prost::encoding::message::encode(3u32, &*value, buf);
                    }
                    Entity::ContractId(ref value) => {
                        ::prost::encoding::message::encode(4u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Entity>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => match field {
                        ::core::option::Option::Some(Entity::AccountId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Entity::AccountId(owned_value))
                                },
                            )
                        }
                    },
                    2u32 => match field {
                        ::core::option::Option::Some(Entity::LiveHash(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Entity::LiveHash(owned_value))
                                },
                            )
                        }
                    },
                    3u32 => match field {
                        ::core::option::Option::Some(Entity::FileId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Entity::FileId(owned_value))
                                },
                            )
                        }
                    },
                    4u32 => match field {
                        ::core::option::Option::Some(Entity::ContractId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Entity::ContractId(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Entity tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Entity::AccountId(ref value) => {
                        ::prost::encoding::message::encoded_len(1u32, &*value)
                    }
                    Entity::LiveHash(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                    Entity::FileId(ref value) => {
                        ::prost::encoding::message::encoded_len(3u32, &*value)
                    }
                    Entity::ContractId(ref value) => {
                        ::prost::encoding::message::encoded_len(4u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Entity {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Entity::AccountId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("AccountId").field(&wrapper).finish()
                    }
                    Entity::LiveHash(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("LiveHash").field(&wrapper).finish()
                    }
                    Entity::FileId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileId").field(&wrapper).finish()
                    }
                    Entity::ContractId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractId").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// Response when the client sends the node GetByKeyQuery
    pub struct GetByKeyResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The list of entities that include this public key in their associated Key list
        #[prost(message, repeated, tag = "2")]
        pub entities: ::prost::alloc::vec::Vec<EntityId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for GetByKeyResponse {
        #[inline]
        fn clone(&self) -> GetByKeyResponse {
            match *self {
                GetByKeyResponse {
                    header: ref __self_0_0,
                    entities: ref __self_0_1,
                } => GetByKeyResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    entities: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for GetByKeyResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for GetByKeyResponse {
        #[inline]
        fn eq(&self, other: &GetByKeyResponse) -> bool {
            match *other {
                GetByKeyResponse {
                    header: ref __self_1_0,
                    entities: ref __self_1_1,
                } => match *self {
                    GetByKeyResponse {
                        header: ref __self_0_0,
                        entities: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GetByKeyResponse) -> bool {
            match *other {
                GetByKeyResponse {
                    header: ref __self_1_0,
                    entities: ref __self_1_1,
                } => match *self {
                    GetByKeyResponse {
                        header: ref __self_0_0,
                        entities: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for GetByKeyResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.entities {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "GetByKeyResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.entities;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "entities");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.entities)
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.entities.clear();
        }
    }
    impl ::core::default::Default for GetByKeyResponse {
        fn default() -> Self {
            GetByKeyResponse {
                header: ::core::default::Default::default(),
                entities: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for GetByKeyResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("GetByKeyResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.entities;
                builder.field("entities", &wrapper)
            };
            builder.finish()
        }
    }
    /// Get the IDs in the format used by transactions, given the ID in the format used by Solidity. If
    /// the Solidity ID is for a smart contract instance, then both the ContractID and associated
    /// AccountID will be returned.
    pub struct GetBySolidityIdQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The ID in the format used by Solidity
        #[prost(string, tag = "2")]
        pub solidity_id: ::prost::alloc::string::String,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for GetBySolidityIdQuery {
        #[inline]
        fn clone(&self) -> GetBySolidityIdQuery {
            match *self {
                GetBySolidityIdQuery {
                    header: ref __self_0_0,
                    solidity_id: ref __self_0_1,
                } => GetBySolidityIdQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    solidity_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for GetBySolidityIdQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for GetBySolidityIdQuery {
        #[inline]
        fn eq(&self, other: &GetBySolidityIdQuery) -> bool {
            match *other {
                GetBySolidityIdQuery {
                    header: ref __self_1_0,
                    solidity_id: ref __self_1_1,
                } => match *self {
                    GetBySolidityIdQuery {
                        header: ref __self_0_0,
                        solidity_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GetBySolidityIdQuery) -> bool {
            match *other {
                GetBySolidityIdQuery {
                    header: ref __self_1_0,
                    solidity_id: ref __self_1_1,
                } => match *self {
                    GetBySolidityIdQuery {
                        header: ref __self_0_0,
                        solidity_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for GetBySolidityIdQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.solidity_id != "" {
                ::prost::encoding::string::encode(2u32, &self.solidity_id, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "GetBySolidityIdQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.solidity_id;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "solidity_id");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.solidity_id != "" {
                    ::prost::encoding::string::encoded_len(2u32, &self.solidity_id)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.solidity_id.clear();
        }
    }
    impl ::core::default::Default for GetBySolidityIdQuery {
        fn default() -> Self {
            GetBySolidityIdQuery {
                header: ::core::default::Default::default(),
                solidity_id: ::prost::alloc::string::String::new(),
            }
        }
    }
    impl ::core::fmt::Debug for GetBySolidityIdQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("GetBySolidityIdQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.solidity_id)
                };
                builder.field("solidity_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node GetBySolidityIDQuery
    pub struct GetBySolidityIdResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The Account ID for the cryptocurrency account
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
        /// The file Id for the file
        #[prost(message, optional, tag = "3")]
        pub file_id: ::core::option::Option<FileId>,
        /// A smart contract ID for the instance (if this is included, then the associated accountID will
        /// also be included)
        #[prost(message, optional, tag = "4")]
        pub contract_id: ::core::option::Option<ContractId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for GetBySolidityIdResponse {
        #[inline]
        fn clone(&self) -> GetBySolidityIdResponse {
            match *self {
                GetBySolidityIdResponse {
                    header: ref __self_0_0,
                    account_id: ref __self_0_1,
                    file_id: ref __self_0_2,
                    contract_id: ref __self_0_3,
                } => GetBySolidityIdResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    file_id: ::core::clone::Clone::clone(&(*__self_0_2)),
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for GetBySolidityIdResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for GetBySolidityIdResponse {
        #[inline]
        fn eq(&self, other: &GetBySolidityIdResponse) -> bool {
            match *other {
                GetBySolidityIdResponse {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                    file_id: ref __self_1_2,
                    contract_id: ref __self_1_3,
                } => match *self {
                    GetBySolidityIdResponse {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                        file_id: ref __self_0_2,
                        contract_id: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GetBySolidityIdResponse) -> bool {
            match *other {
                GetBySolidityIdResponse {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                    file_id: ref __self_1_2,
                    contract_id: ref __self_1_3,
                } => match *self {
                    GetBySolidityIdResponse {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                        file_id: ref __self_0_2,
                        contract_id: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for GetBySolidityIdResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.file_id {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "GetBySolidityIdResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.file_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "file_id");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .file_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + self
                    .contract_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
            self.file_id = ::core::option::Option::None;
            self.contract_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for GetBySolidityIdResponse {
        fn default() -> Self {
            GetBySolidityIdResponse {
                header: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
                file_id: ::core::default::Default::default(),
                contract_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for GetBySolidityIdResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("GetBySolidityIdResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.file_id;
                builder.field("file_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Get information about a smart contract instance. This includes the account that it uses, the file
    /// containing its initcode (if a file was used to initialize the contract), and the time when it will expire.
    pub struct ContractGetInfoQuery {
        /// standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// the contract for which information is requested
        #[prost(message, optional, tag = "2")]
        pub contract_id: ::core::option::Option<ContractId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractGetInfoQuery {
        #[inline]
        fn clone(&self) -> ContractGetInfoQuery {
            match *self {
                ContractGetInfoQuery {
                    header: ref __self_0_0,
                    contract_id: ref __self_0_1,
                } => ContractGetInfoQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractGetInfoQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractGetInfoQuery {
        #[inline]
        fn eq(&self, other: &ContractGetInfoQuery) -> bool {
            match *other {
                ContractGetInfoQuery {
                    header: ref __self_1_0,
                    contract_id: ref __self_1_1,
                } => match *self {
                    ContractGetInfoQuery {
                        header: ref __self_0_0,
                        contract_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractGetInfoQuery) -> bool {
            match *other {
                ContractGetInfoQuery {
                    header: ref __self_1_0,
                    contract_id: ref __self_1_1,
                } => match *self {
                    ContractGetInfoQuery {
                        header: ref __self_0_0,
                        contract_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ContractGetInfoQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractGetInfoQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .contract_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.contract_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ContractGetInfoQuery {
        fn default() -> Self {
            ContractGetInfoQuery {
                header: ::core::default::Default::default(),
                contract_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractGetInfoQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractGetInfoQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node ContractGetInfoQuery
    pub struct ContractGetInfoResponse {
        /// standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// the information about this contract instance (a state proof can be generated for this)
        #[prost(message, optional, tag = "2")]
        pub contract_info: ::core::option::Option<contract_get_info_response::ContractInfo>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractGetInfoResponse {
        #[inline]
        fn clone(&self) -> ContractGetInfoResponse {
            match *self {
                ContractGetInfoResponse {
                    header: ref __self_0_0,
                    contract_info: ref __self_0_1,
                } => ContractGetInfoResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    contract_info: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractGetInfoResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractGetInfoResponse {
        #[inline]
        fn eq(&self, other: &ContractGetInfoResponse) -> bool {
            match *other {
                ContractGetInfoResponse {
                    header: ref __self_1_0,
                    contract_info: ref __self_1_1,
                } => match *self {
                    ContractGetInfoResponse {
                        header: ref __self_0_0,
                        contract_info: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractGetInfoResponse) -> bool {
            match *other {
                ContractGetInfoResponse {
                    header: ref __self_1_0,
                    contract_info: ref __self_1_1,
                } => match *self {
                    ContractGetInfoResponse {
                        header: ref __self_0_0,
                        contract_info: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ContractGetInfoResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.contract_info {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractGetInfoResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.contract_info;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_info");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .contract_info
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.contract_info = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ContractGetInfoResponse {
        fn default() -> Self {
            ContractGetInfoResponse {
                header: ::core::default::Default::default(),
                contract_info: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractGetInfoResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractGetInfoResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.contract_info;
                builder.field("contract_info", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `ContractGetInfoResponse`.
    pub mod contract_get_info_response {
        pub struct ContractInfo {
            /// ID of the contract instance, in the format used in transactions
            #[prost(message, optional, tag = "1")]
            pub contract_id: ::core::option::Option<super::ContractId>,
            /// ID of the cryptocurrency account owned by the contract instance, in the format used in
            /// transactions
            #[prost(message, optional, tag = "2")]
            pub account_id: ::core::option::Option<super::AccountId>,
            /// ID of both the contract instance and the cryptocurrency account owned by the contract
            /// instance, in the format used by Solidity
            #[prost(string, tag = "3")]
            pub contract_account_id: ::prost::alloc::string::String,
            /// the state of the instance and its fields can be modified arbitrarily if this key signs a
            /// transaction to modify it. If this is null, then such modifications are not possible, and
            /// there is no administrator that can override the normal operation of this smart contract
            /// instance. Note that if it is created with no admin keys, then there is no administrator
            /// to authorize changing the admin keys, so there can never be any admin keys for that
            /// instance.
            #[prost(message, optional, tag = "4")]
            pub admin_key: ::core::option::Option<super::Key>,
            /// the current time at which this contract instance (and its account) is set to expire
            #[prost(message, optional, tag = "5")]
            pub expiration_time: ::core::option::Option<super::Timestamp>,
            /// the expiration time will extend every this many seconds. If there are insufficient funds,
            /// then it extends as long as possible. If the account is empty when it expires, then it is
            /// deleted.
            #[prost(message, optional, tag = "6")]
            pub auto_renew_period: ::core::option::Option<super::Duration>,
            /// number of bytes of storage being used by this instance (which affects the cost to extend
            /// the expiration time)
            #[prost(int64, tag = "7")]
            pub storage: i64,
            /// the memo associated with the contract (max 100 bytes)
            #[prost(string, tag = "8")]
            pub memo: ::prost::alloc::string::String,
            /// The current balance, in tinybars
            #[prost(uint64, tag = "9")]
            pub balance: u64,
            /// Whether the contract has been deleted
            #[prost(bool, tag = "10")]
            pub deleted: bool,
            /// The tokens associated to the contract
            #[prost(message, repeated, tag = "11")]
            pub token_relationships: ::prost::alloc::vec::Vec<super::TokenRelationship>,
            /// The ledger ID the response was returned from; please see <a href="<https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a>> for the network-specific IDs.
            #[prost(bytes = "vec", tag = "12")]
            pub ledger_id: ::prost::alloc::vec::Vec<u8>,
            /// ID of the an account to charge for auto-renewal of this contract. If not set, or set to an account with zero hbar
            /// balance, the contract's own hbar balance will be used to cover auto-renewal fees.
            #[prost(message, optional, tag = "13")]
            pub auto_renew_account_id: ::core::option::Option<super::AccountId>,
            /// The maximum number of tokens that a contract can be implicitly associated with.
            #[prost(int32, tag = "14")]
            pub max_automatic_token_associations: i32,
            /// Staking metadata for this contract.
            #[prost(message, optional, tag = "15")]
            pub staking_info: ::core::option::Option<super::StakingInfo>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ContractInfo {
            #[inline]
            fn clone(&self) -> ContractInfo {
                match *self {
                    ContractInfo {
                        contract_id: ref __self_0_0,
                        account_id: ref __self_0_1,
                        contract_account_id: ref __self_0_2,
                        admin_key: ref __self_0_3,
                        expiration_time: ref __self_0_4,
                        auto_renew_period: ref __self_0_5,
                        storage: ref __self_0_6,
                        memo: ref __self_0_7,
                        balance: ref __self_0_8,
                        deleted: ref __self_0_9,
                        token_relationships: ref __self_0_10,
                        ledger_id: ref __self_0_11,
                        auto_renew_account_id: ref __self_0_12,
                        max_automatic_token_associations: ref __self_0_13,
                        staking_info: ref __self_0_14,
                    } => ContractInfo {
                        contract_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                        account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                        contract_account_id: ::core::clone::Clone::clone(&(*__self_0_2)),
                        admin_key: ::core::clone::Clone::clone(&(*__self_0_3)),
                        expiration_time: ::core::clone::Clone::clone(&(*__self_0_4)),
                        auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_5)),
                        storage: ::core::clone::Clone::clone(&(*__self_0_6)),
                        memo: ::core::clone::Clone::clone(&(*__self_0_7)),
                        balance: ::core::clone::Clone::clone(&(*__self_0_8)),
                        deleted: ::core::clone::Clone::clone(&(*__self_0_9)),
                        token_relationships: ::core::clone::Clone::clone(&(*__self_0_10)),
                        ledger_id: ::core::clone::Clone::clone(&(*__self_0_11)),
                        auto_renew_account_id: ::core::clone::Clone::clone(&(*__self_0_12)),
                        max_automatic_token_associations: ::core::clone::Clone::clone(
                            &(*__self_0_13),
                        ),
                        staking_info: ::core::clone::Clone::clone(&(*__self_0_14)),
                    },
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ContractInfo {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ContractInfo {
            #[inline]
            fn eq(&self, other: &ContractInfo) -> bool {
                match *other {
                    ContractInfo {
                        contract_id: ref __self_1_0,
                        account_id: ref __self_1_1,
                        contract_account_id: ref __self_1_2,
                        admin_key: ref __self_1_3,
                        expiration_time: ref __self_1_4,
                        auto_renew_period: ref __self_1_5,
                        storage: ref __self_1_6,
                        memo: ref __self_1_7,
                        balance: ref __self_1_8,
                        deleted: ref __self_1_9,
                        token_relationships: ref __self_1_10,
                        ledger_id: ref __self_1_11,
                        auto_renew_account_id: ref __self_1_12,
                        max_automatic_token_associations: ref __self_1_13,
                        staking_info: ref __self_1_14,
                    } => match *self {
                        ContractInfo {
                            contract_id: ref __self_0_0,
                            account_id: ref __self_0_1,
                            contract_account_id: ref __self_0_2,
                            admin_key: ref __self_0_3,
                            expiration_time: ref __self_0_4,
                            auto_renew_period: ref __self_0_5,
                            storage: ref __self_0_6,
                            memo: ref __self_0_7,
                            balance: ref __self_0_8,
                            deleted: ref __self_0_9,
                            token_relationships: ref __self_0_10,
                            ledger_id: ref __self_0_11,
                            auto_renew_account_id: ref __self_0_12,
                            max_automatic_token_associations: ref __self_0_13,
                            staking_info: ref __self_0_14,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                                && (*__self_0_4) == (*__self_1_4)
                                && (*__self_0_5) == (*__self_1_5)
                                && (*__self_0_6) == (*__self_1_6)
                                && (*__self_0_7) == (*__self_1_7)
                                && (*__self_0_8) == (*__self_1_8)
                                && (*__self_0_9) == (*__self_1_9)
                                && (*__self_0_10) == (*__self_1_10)
                                && (*__self_0_11) == (*__self_1_11)
                                && (*__self_0_12) == (*__self_1_12)
                                && (*__self_0_13) == (*__self_1_13)
                                && (*__self_0_14) == (*__self_1_14)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &ContractInfo) -> bool {
                match *other {
                    ContractInfo {
                        contract_id: ref __self_1_0,
                        account_id: ref __self_1_1,
                        contract_account_id: ref __self_1_2,
                        admin_key: ref __self_1_3,
                        expiration_time: ref __self_1_4,
                        auto_renew_period: ref __self_1_5,
                        storage: ref __self_1_6,
                        memo: ref __self_1_7,
                        balance: ref __self_1_8,
                        deleted: ref __self_1_9,
                        token_relationships: ref __self_1_10,
                        ledger_id: ref __self_1_11,
                        auto_renew_account_id: ref __self_1_12,
                        max_automatic_token_associations: ref __self_1_13,
                        staking_info: ref __self_1_14,
                    } => match *self {
                        ContractInfo {
                            contract_id: ref __self_0_0,
                            account_id: ref __self_0_1,
                            contract_account_id: ref __self_0_2,
                            admin_key: ref __self_0_3,
                            expiration_time: ref __self_0_4,
                            auto_renew_period: ref __self_0_5,
                            storage: ref __self_0_6,
                            memo: ref __self_0_7,
                            balance: ref __self_0_8,
                            deleted: ref __self_0_9,
                            token_relationships: ref __self_0_10,
                            ledger_id: ref __self_0_11,
                            auto_renew_account_id: ref __self_0_12,
                            max_automatic_token_associations: ref __self_0_13,
                            staking_info: ref __self_0_14,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                                || (*__self_0_4) != (*__self_1_4)
                                || (*__self_0_5) != (*__self_1_5)
                                || (*__self_0_6) != (*__self_1_6)
                                || (*__self_0_7) != (*__self_1_7)
                                || (*__self_0_8) != (*__self_1_8)
                                || (*__self_0_9) != (*__self_1_9)
                                || (*__self_0_10) != (*__self_1_10)
                                || (*__self_0_11) != (*__self_1_11)
                                || (*__self_0_12) != (*__self_1_12)
                                || (*__self_0_13) != (*__self_1_13)
                                || (*__self_0_14) != (*__self_1_14)
                        }
                    },
                }
            }
        }
        impl ::prost::Message for ContractInfo {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if let Some(ref msg) = self.contract_id {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
                if let Some(ref msg) = self.account_id {
                    ::prost::encoding::message::encode(2u32, msg, buf);
                }
                if self.contract_account_id != "" {
                    ::prost::encoding::string::encode(3u32, &self.contract_account_id, buf);
                }
                if let Some(ref msg) = self.admin_key {
                    ::prost::encoding::message::encode(4u32, msg, buf);
                }
                if let Some(ref msg) = self.expiration_time {
                    ::prost::encoding::message::encode(5u32, msg, buf);
                }
                if let Some(ref msg) = self.auto_renew_period {
                    ::prost::encoding::message::encode(6u32, msg, buf);
                }
                if self.storage != 0i64 {
                    ::prost::encoding::int64::encode(7u32, &self.storage, buf);
                }
                if self.memo != "" {
                    ::prost::encoding::string::encode(8u32, &self.memo, buf);
                }
                if self.balance != 0u64 {
                    ::prost::encoding::uint64::encode(9u32, &self.balance, buf);
                }
                if self.deleted != false {
                    ::prost::encoding::bool::encode(10u32, &self.deleted, buf);
                }
                for msg in &self.token_relationships {
                    ::prost::encoding::message::encode(11u32, msg, buf);
                }
                if self.ledger_id != b"" as &[u8] {
                    ::prost::encoding::bytes::encode(12u32, &self.ledger_id, buf);
                }
                if let Some(ref msg) = self.auto_renew_account_id {
                    ::prost::encoding::message::encode(13u32, msg, buf);
                }
                if self.max_automatic_token_associations != 0i32 {
                    ::prost::encoding::int32::encode(
                        14u32,
                        &self.max_automatic_token_associations,
                        buf,
                    );
                }
                if let Some(ref msg) = self.staking_info {
                    ::prost::encoding::message::encode(15u32, msg, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "ContractInfo";
                match tag {
                    1u32 => {
                        let mut value = &mut self.contract_id;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "contract_id");
                            error
                        })
                    }
                    2u32 => {
                        let mut value = &mut self.account_id;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "account_id");
                            error
                        })
                    }
                    3u32 => {
                        let mut value = &mut self.contract_account_id;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "contract_account_id");
                                error
                            },
                        )
                    }
                    4u32 => {
                        let mut value = &mut self.admin_key;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "admin_key");
                            error
                        })
                    }
                    5u32 => {
                        let mut value = &mut self.expiration_time;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "expiration_time");
                            error
                        })
                    }
                    6u32 => {
                        let mut value = &mut self.auto_renew_period;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "auto_renew_period");
                            error
                        })
                    }
                    7u32 => {
                        let mut value = &mut self.storage;
                        ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "storage");
                                error
                            },
                        )
                    }
                    8u32 => {
                        let mut value = &mut self.memo;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "memo");
                                error
                            },
                        )
                    }
                    9u32 => {
                        let mut value = &mut self.balance;
                        ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "balance");
                                error
                            },
                        )
                    }
                    10u32 => {
                        let mut value = &mut self.deleted;
                        ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "deleted");
                                error
                            },
                        )
                    }
                    11u32 => {
                        let mut value = &mut self.token_relationships;
                        ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "token_relationships");
                                error
                            })
                    }
                    12u32 => {
                        let mut value = &mut self.ledger_id;
                        ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "ledger_id");
                                error
                            },
                        )
                    }
                    13u32 => {
                        let mut value = &mut self.auto_renew_account_id;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "auto_renew_account_id");
                            error
                        })
                    }
                    14u32 => {
                        let mut value = &mut self.max_automatic_token_associations;
                        ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "max_automatic_token_associations");
                                error
                            },
                        )
                    }
                    15u32 => {
                        let mut value = &mut self.staking_info;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "staking_info");
                            error
                        })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 + self
                    .contract_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                    + self
                        .account_id
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                    + if self.contract_account_id != "" {
                        ::prost::encoding::string::encoded_len(3u32, &self.contract_account_id)
                    } else {
                        0
                    }
                    + self
                        .admin_key
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                    + self
                        .expiration_time
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                    + self
                        .auto_renew_period
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                    + if self.storage != 0i64 {
                        ::prost::encoding::int64::encoded_len(7u32, &self.storage)
                    } else {
                        0
                    }
                    + if self.memo != "" {
                        ::prost::encoding::string::encoded_len(8u32, &self.memo)
                    } else {
                        0
                    }
                    + if self.balance != 0u64 {
                        ::prost::encoding::uint64::encoded_len(9u32, &self.balance)
                    } else {
                        0
                    }
                    + if self.deleted != false {
                        ::prost::encoding::bool::encoded_len(10u32, &self.deleted)
                    } else {
                        0
                    }
                    + ::prost::encoding::message::encoded_len_repeated(
                        11u32,
                        &self.token_relationships,
                    )
                    + if self.ledger_id != b"" as &[u8] {
                        ::prost::encoding::bytes::encoded_len(12u32, &self.ledger_id)
                    } else {
                        0
                    }
                    + self
                        .auto_renew_account_id
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(13u32, msg))
                    + if self.max_automatic_token_associations != 0i32 {
                        ::prost::encoding::int32::encoded_len(
                            14u32,
                            &self.max_automatic_token_associations,
                        )
                    } else {
                        0
                    }
                    + self
                        .staking_info
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(15u32, msg))
            }
            fn clear(&mut self) {
                self.contract_id = ::core::option::Option::None;
                self.account_id = ::core::option::Option::None;
                self.contract_account_id.clear();
                self.admin_key = ::core::option::Option::None;
                self.expiration_time = ::core::option::Option::None;
                self.auto_renew_period = ::core::option::Option::None;
                self.storage = 0i64;
                self.memo.clear();
                self.balance = 0u64;
                self.deleted = false;
                self.token_relationships.clear();
                self.ledger_id.clear();
                self.auto_renew_account_id = ::core::option::Option::None;
                self.max_automatic_token_associations = 0i32;
                self.staking_info = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for ContractInfo {
            fn default() -> Self {
                ContractInfo {
                    contract_id: ::core::default::Default::default(),
                    account_id: ::core::default::Default::default(),
                    contract_account_id: ::prost::alloc::string::String::new(),
                    admin_key: ::core::default::Default::default(),
                    expiration_time: ::core::default::Default::default(),
                    auto_renew_period: ::core::default::Default::default(),
                    storage: 0i64,
                    memo: ::prost::alloc::string::String::new(),
                    balance: 0u64,
                    deleted: false,
                    token_relationships: ::core::default::Default::default(),
                    ledger_id: ::core::default::Default::default(),
                    auto_renew_account_id: ::core::default::Default::default(),
                    max_automatic_token_associations: 0i32,
                    staking_info: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for ContractInfo {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("ContractInfo");
                let builder = {
                    let wrapper = &self.contract_id;
                    builder.field("contract_id", &wrapper)
                };
                let builder = {
                    let wrapper = &self.account_id;
                    builder.field("account_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.contract_account_id)
                    };
                    builder.field("contract_account_id", &wrapper)
                };
                let builder = {
                    let wrapper = &self.admin_key;
                    builder.field("admin_key", &wrapper)
                };
                let builder = {
                    let wrapper = &self.expiration_time;
                    builder.field("expiration_time", &wrapper)
                };
                let builder = {
                    let wrapper = &self.auto_renew_period;
                    builder.field("auto_renew_period", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.storage)
                    };
                    builder.field("storage", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.memo)
                    };
                    builder.field("memo", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.balance)
                    };
                    builder.field("balance", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.deleted)
                    };
                    builder.field("deleted", &wrapper)
                };
                let builder = {
                    let wrapper = &self.token_relationships;
                    builder.field("token_relationships", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.ledger_id)
                    };
                    builder.field("ledger_id", &wrapper)
                };
                let builder = {
                    let wrapper = &self.auto_renew_account_id;
                    builder.field("auto_renew_account_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.max_automatic_token_associations)
                    };
                    builder.field("max_automatic_token_associations", &wrapper)
                };
                let builder = {
                    let wrapper = &self.staking_info;
                    builder.field("staking_info", &wrapper)
                };
                builder.finish()
            }
        }
    }
    /// Get the runtime bytecode for a smart contract instance
    pub struct ContractGetBytecodeQuery {
        /// standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// the contract for which information is requested
        #[prost(message, optional, tag = "2")]
        pub contract_id: ::core::option::Option<ContractId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractGetBytecodeQuery {
        #[inline]
        fn clone(&self) -> ContractGetBytecodeQuery {
            match *self {
                ContractGetBytecodeQuery {
                    header: ref __self_0_0,
                    contract_id: ref __self_0_1,
                } => ContractGetBytecodeQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractGetBytecodeQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractGetBytecodeQuery {
        #[inline]
        fn eq(&self, other: &ContractGetBytecodeQuery) -> bool {
            match *other {
                ContractGetBytecodeQuery {
                    header: ref __self_1_0,
                    contract_id: ref __self_1_1,
                } => match *self {
                    ContractGetBytecodeQuery {
                        header: ref __self_0_0,
                        contract_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractGetBytecodeQuery) -> bool {
            match *other {
                ContractGetBytecodeQuery {
                    header: ref __self_1_0,
                    contract_id: ref __self_1_1,
                } => match *self {
                    ContractGetBytecodeQuery {
                        header: ref __self_0_0,
                        contract_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ContractGetBytecodeQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractGetBytecodeQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .contract_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.contract_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ContractGetBytecodeQuery {
        fn default() -> Self {
            ContractGetBytecodeQuery {
                header: ::core::default::Default::default(),
                contract_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractGetBytecodeQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractGetBytecodeQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node ContractGetBytecodeQuery
    pub struct ContractGetBytecodeResponse {
        /// standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// the runtime bytecode of the contract
        #[prost(bytes = "vec", tag = "6")]
        pub bytecode: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractGetBytecodeResponse {
        #[inline]
        fn clone(&self) -> ContractGetBytecodeResponse {
            match *self {
                ContractGetBytecodeResponse {
                    header: ref __self_0_0,
                    bytecode: ref __self_0_1,
                } => ContractGetBytecodeResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    bytecode: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractGetBytecodeResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractGetBytecodeResponse {
        #[inline]
        fn eq(&self, other: &ContractGetBytecodeResponse) -> bool {
            match *other {
                ContractGetBytecodeResponse {
                    header: ref __self_1_0,
                    bytecode: ref __self_1_1,
                } => match *self {
                    ContractGetBytecodeResponse {
                        header: ref __self_0_0,
                        bytecode: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractGetBytecodeResponse) -> bool {
            match *other {
                ContractGetBytecodeResponse {
                    header: ref __self_1_0,
                    bytecode: ref __self_1_1,
                } => match *self {
                    ContractGetBytecodeResponse {
                        header: ref __self_0_0,
                        bytecode: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ContractGetBytecodeResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.bytecode != b"" as &[u8] {
                ::prost::encoding::bytes::encode(6u32, &self.bytecode, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractGetBytecodeResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.bytecode;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "bytecode");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.bytecode != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(6u32, &self.bytecode)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.bytecode.clear();
        }
    }
    impl ::core::default::Default for ContractGetBytecodeResponse {
        fn default() -> Self {
            ContractGetBytecodeResponse {
                header: ::core::default::Default::default(),
                bytecode: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractGetBytecodeResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractGetBytecodeResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.bytecode)
                };
                builder.field("bytecode", &wrapper)
            };
            builder.finish()
        }
    }
    /// Before v0.9.0, requested records of all transactions against the given contract in the last 25 hours.
    pub struct ContractGetRecordsQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The smart contract instance for which the records should be retrieved
        #[prost(message, optional, tag = "2")]
        pub contract_id: ::core::option::Option<ContractId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractGetRecordsQuery {
        #[inline]
        fn clone(&self) -> ContractGetRecordsQuery {
            match *self {
                ContractGetRecordsQuery {
                    header: ref __self_0_0,
                    contract_id: ref __self_0_1,
                } => ContractGetRecordsQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractGetRecordsQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractGetRecordsQuery {
        #[inline]
        fn eq(&self, other: &ContractGetRecordsQuery) -> bool {
            match *other {
                ContractGetRecordsQuery {
                    header: ref __self_1_0,
                    contract_id: ref __self_1_1,
                } => match *self {
                    ContractGetRecordsQuery {
                        header: ref __self_0_0,
                        contract_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractGetRecordsQuery) -> bool {
            match *other {
                ContractGetRecordsQuery {
                    header: ref __self_1_0,
                    contract_id: ref __self_1_1,
                } => match *self {
                    ContractGetRecordsQuery {
                        header: ref __self_0_0,
                        contract_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ContractGetRecordsQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractGetRecordsQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .contract_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.contract_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ContractGetRecordsQuery {
        fn default() -> Self {
            ContractGetRecordsQuery {
                header: ::core::default::Default::default(),
                contract_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractGetRecordsQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractGetRecordsQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Before v0.9.0, returned records of all transactions against the given contract in the last 25 hours.
    pub struct ContractGetRecordsResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The smart contract instance that this record is for
        #[prost(message, optional, tag = "2")]
        pub contract_id: ::core::option::Option<ContractId>,
        /// List of records, each with contractCreateResult or contractCallResult as its body
        #[prost(message, repeated, tag = "3")]
        pub records: ::prost::alloc::vec::Vec<TransactionRecord>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ContractGetRecordsResponse {
        #[inline]
        fn clone(&self) -> ContractGetRecordsResponse {
            match *self {
                ContractGetRecordsResponse {
                    header: ref __self_0_0,
                    contract_id: ref __self_0_1,
                    records: ref __self_0_2,
                } => ContractGetRecordsResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    contract_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    records: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ContractGetRecordsResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ContractGetRecordsResponse {
        #[inline]
        fn eq(&self, other: &ContractGetRecordsResponse) -> bool {
            match *other {
                ContractGetRecordsResponse {
                    header: ref __self_1_0,
                    contract_id: ref __self_1_1,
                    records: ref __self_1_2,
                } => match *self {
                    ContractGetRecordsResponse {
                        header: ref __self_0_0,
                        contract_id: ref __self_0_1,
                        records: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ContractGetRecordsResponse) -> bool {
            match *other {
                ContractGetRecordsResponse {
                    header: ref __self_1_0,
                    contract_id: ref __self_1_1,
                    records: ref __self_1_2,
                } => match *self {
                    ContractGetRecordsResponse {
                        header: ref __self_0_0,
                        contract_id: ref __self_0_1,
                        records: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ContractGetRecordsResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.contract_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            for msg in &self.records {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ContractGetRecordsResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.contract_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "contract_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.records;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "records");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .contract_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(3u32, &self.records)
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.contract_id = ::core::option::Option::None;
            self.records.clear();
        }
    }
    impl ::core::default::Default for ContractGetRecordsResponse {
        fn default() -> Self {
            ContractGetRecordsResponse {
                header: ::core::default::Default::default(),
                contract_id: ::core::default::Default::default(),
                records: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ContractGetRecordsResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ContractGetRecordsResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.contract_id;
                builder.field("contract_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.records;
                builder.field("records", &wrapper)
            };
            builder.finish()
        }
    }
    /// Requests records of all transactions for which the given account was the effective payer in the last 3 minutes of consensus time and <tt>ledger.keepRecordsInState=true</tt> was true during <tt>handleTransaction</tt>.
    pub struct CryptoGetAccountRecordsQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The account ID for which the records should be retrieved
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoGetAccountRecordsQuery {
        #[inline]
        fn clone(&self) -> CryptoGetAccountRecordsQuery {
            match *self {
                CryptoGetAccountRecordsQuery {
                    header: ref __self_0_0,
                    account_id: ref __self_0_1,
                } => CryptoGetAccountRecordsQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoGetAccountRecordsQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoGetAccountRecordsQuery {
        #[inline]
        fn eq(&self, other: &CryptoGetAccountRecordsQuery) -> bool {
            match *other {
                CryptoGetAccountRecordsQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                } => match *self {
                    CryptoGetAccountRecordsQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoGetAccountRecordsQuery) -> bool {
            match *other {
                CryptoGetAccountRecordsQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                } => match *self {
                    CryptoGetAccountRecordsQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CryptoGetAccountRecordsQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoGetAccountRecordsQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CryptoGetAccountRecordsQuery {
        fn default() -> Self {
            CryptoGetAccountRecordsQuery {
                header: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoGetAccountRecordsQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoGetAccountRecordsQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Returns records of all transactions for which the given account was the effective payer in the last 3 minutes of consensus time and <tt>ledger.keepRecordsInState=true</tt> was true during <tt>handleTransaction</tt>.
    pub struct CryptoGetAccountRecordsResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The account that this record is for
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
        /// List of records
        #[prost(message, repeated, tag = "3")]
        pub records: ::prost::alloc::vec::Vec<TransactionRecord>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoGetAccountRecordsResponse {
        #[inline]
        fn clone(&self) -> CryptoGetAccountRecordsResponse {
            match *self {
                CryptoGetAccountRecordsResponse {
                    header: ref __self_0_0,
                    account_id: ref __self_0_1,
                    records: ref __self_0_2,
                } => CryptoGetAccountRecordsResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    records: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoGetAccountRecordsResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoGetAccountRecordsResponse {
        #[inline]
        fn eq(&self, other: &CryptoGetAccountRecordsResponse) -> bool {
            match *other {
                CryptoGetAccountRecordsResponse {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                    records: ref __self_1_2,
                } => match *self {
                    CryptoGetAccountRecordsResponse {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                        records: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoGetAccountRecordsResponse) -> bool {
            match *other {
                CryptoGetAccountRecordsResponse {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                    records: ref __self_1_2,
                } => match *self {
                    CryptoGetAccountRecordsResponse {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                        records: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for CryptoGetAccountRecordsResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            for msg in &self.records {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoGetAccountRecordsResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.records;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "records");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(3u32, &self.records)
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
            self.records.clear();
        }
    }
    impl ::core::default::Default for CryptoGetAccountRecordsResponse {
        fn default() -> Self {
            CryptoGetAccountRecordsResponse {
                header: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
                records: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoGetAccountRecordsResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoGetAccountRecordsResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.records;
                builder.field("records", &wrapper)
            };
            builder.finish()
        }
    }
    /// Get all the information about an account, including the balance. This does not get the list of
    /// account records.
    pub struct CryptoGetInfoQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The account ID for which information is requested
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoGetInfoQuery {
        #[inline]
        fn clone(&self) -> CryptoGetInfoQuery {
            match *self {
                CryptoGetInfoQuery {
                    header: ref __self_0_0,
                    account_id: ref __self_0_1,
                } => CryptoGetInfoQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoGetInfoQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoGetInfoQuery {
        #[inline]
        fn eq(&self, other: &CryptoGetInfoQuery) -> bool {
            match *other {
                CryptoGetInfoQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                } => match *self {
                    CryptoGetInfoQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoGetInfoQuery) -> bool {
            match *other {
                CryptoGetInfoQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                } => match *self {
                    CryptoGetInfoQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CryptoGetInfoQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoGetInfoQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CryptoGetInfoQuery {
        fn default() -> Self {
            CryptoGetInfoQuery {
                header: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoGetInfoQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoGetInfoQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node CryptoGetInfoQuery
    pub struct CryptoGetInfoResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// Info about the account (a state proof can be generated for this)
        #[prost(message, optional, tag = "2")]
        pub account_info: ::core::option::Option<crypto_get_info_response::AccountInfo>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoGetInfoResponse {
        #[inline]
        fn clone(&self) -> CryptoGetInfoResponse {
            match *self {
                CryptoGetInfoResponse {
                    header: ref __self_0_0,
                    account_info: ref __self_0_1,
                } => CryptoGetInfoResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_info: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoGetInfoResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoGetInfoResponse {
        #[inline]
        fn eq(&self, other: &CryptoGetInfoResponse) -> bool {
            match *other {
                CryptoGetInfoResponse {
                    header: ref __self_1_0,
                    account_info: ref __self_1_1,
                } => match *self {
                    CryptoGetInfoResponse {
                        header: ref __self_0_0,
                        account_info: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoGetInfoResponse) -> bool {
            match *other {
                CryptoGetInfoResponse {
                    header: ref __self_1_0,
                    account_info: ref __self_1_1,
                } => match *self {
                    CryptoGetInfoResponse {
                        header: ref __self_0_0,
                        account_info: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CryptoGetInfoResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_info {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoGetInfoResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_info;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_info");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_info
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.account_info = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CryptoGetInfoResponse {
        fn default() -> Self {
            CryptoGetInfoResponse {
                header: ::core::default::Default::default(),
                account_info: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoGetInfoResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoGetInfoResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_info;
                builder.field("account_info", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `CryptoGetInfoResponse`.
    pub mod crypto_get_info_response {
        pub struct AccountInfo {
            /// The account ID for which this information applies
            #[prost(message, optional, tag = "1")]
            pub account_id: ::core::option::Option<super::AccountId>,
            /// The Contract Account ID comprising of both the contract instance and the cryptocurrency
            /// account owned by the contract instance, in the format used by Solidity
            #[prost(string, tag = "2")]
            pub contract_account_id: ::prost::alloc::string::String,
            /// If true, then this account has been deleted, it will disappear when it expires, and all
            /// transactions for it will fail except the transaction to extend its expiration date
            #[prost(bool, tag = "3")]
            pub deleted: bool,
            /// \[Deprecated\] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
            /// or is an invalid account, or is an account that isn't a node, then this account is
            /// automatically proxy staked to a node chosen by the network, but without earning payments.
            /// If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
            /// running a node, then it will behave as if proxyAccountID was null.
            #[deprecated]
            #[prost(message, optional, tag = "4")]
            pub proxy_account_id: ::core::option::Option<super::AccountId>,
            /// The total number of tinybars proxy staked to this account
            #[prost(int64, tag = "6")]
            pub proxy_received: i64,
            /// The key for the account, which must sign in order to transfer out, or to modify the
            /// account in any way other than extending its expiration date.
            #[prost(message, optional, tag = "7")]
            pub key: ::core::option::Option<super::Key>,
            /// The current balance of account in tinybars
            #[prost(uint64, tag = "8")]
            pub balance: u64,
            /// \[Deprecated\]. The threshold amount, in tinybars, at which a record is created of any
            /// transaction that decreases the balance of this account by more than the threshold
            #[deprecated]
            #[prost(uint64, tag = "9")]
            pub generate_send_record_threshold: u64,
            /// \[Deprecated\]. The threshold amount, in tinybars, at which a record is created of any
            /// transaction that increases the balance of this account by more than the threshold
            #[deprecated]
            #[prost(uint64, tag = "10")]
            pub generate_receive_record_threshold: u64,
            /// If true, no transaction can transfer to this account unless signed by this account's key
            #[prost(bool, tag = "11")]
            pub receiver_sig_required: bool,
            /// The TimeStamp time at which this account is set to expire
            #[prost(message, optional, tag = "12")]
            pub expiration_time: ::core::option::Option<super::Timestamp>,
            /// The duration for expiration time will extend every this many seconds. If there are
            /// insufficient funds, then it extends as long as possible. If it is empty when it expires,
            /// then it is deleted.
            #[prost(message, optional, tag = "13")]
            pub auto_renew_period: ::core::option::Option<super::Duration>,
            /// All of the livehashes attached to the account (each of which is a hash along with the
            /// keys that authorized it and can delete it)
            #[prost(message, repeated, tag = "14")]
            pub live_hashes: ::prost::alloc::vec::Vec<super::LiveHash>,
            /// All tokens related to this account
            #[prost(message, repeated, tag = "15")]
            pub token_relationships: ::prost::alloc::vec::Vec<super::TokenRelationship>,
            /// The memo associated with the account
            #[prost(string, tag = "16")]
            pub memo: ::prost::alloc::string::String,
            /// The number of NFTs owned by this account
            #[prost(int64, tag = "17")]
            pub owned_nfts: i64,
            /// The maximum number of tokens that an Account can be implicitly associated with.
            #[prost(int32, tag = "18")]
            pub max_automatic_token_associations: i32,
            /// The alias of this account
            #[prost(bytes = "vec", tag = "19")]
            pub alias: ::prost::alloc::vec::Vec<u8>,
            /// The ledger ID the response was returned from; please see <a href="<https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a>> for the network-specific IDs.
            #[prost(bytes = "vec", tag = "20")]
            pub ledger_id: ::prost::alloc::vec::Vec<u8>,
            /// The ethereum transaction nonce associated with this account.
            #[prost(int64, tag = "21")]
            pub ethereum_nonce: i64,
            /// Staking metadata for this account.
            #[prost(message, optional, tag = "22")]
            pub staking_info: ::core::option::Option<super::StakingInfo>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for AccountInfo {
            #[inline]
            fn clone(&self) -> AccountInfo {
                match *self {
                    AccountInfo {
                        account_id: ref __self_0_0,
                        contract_account_id: ref __self_0_1,
                        deleted: ref __self_0_2,
                        proxy_account_id: ref __self_0_3,
                        proxy_received: ref __self_0_4,
                        key: ref __self_0_5,
                        balance: ref __self_0_6,
                        generate_send_record_threshold: ref __self_0_7,
                        generate_receive_record_threshold: ref __self_0_8,
                        receiver_sig_required: ref __self_0_9,
                        expiration_time: ref __self_0_10,
                        auto_renew_period: ref __self_0_11,
                        live_hashes: ref __self_0_12,
                        token_relationships: ref __self_0_13,
                        memo: ref __self_0_14,
                        owned_nfts: ref __self_0_15,
                        max_automatic_token_associations: ref __self_0_16,
                        alias: ref __self_0_17,
                        ledger_id: ref __self_0_18,
                        ethereum_nonce: ref __self_0_19,
                        staking_info: ref __self_0_20,
                    } => AccountInfo {
                        account_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                        contract_account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                        deleted: ::core::clone::Clone::clone(&(*__self_0_2)),
                        proxy_account_id: ::core::clone::Clone::clone(&(*__self_0_3)),
                        proxy_received: ::core::clone::Clone::clone(&(*__self_0_4)),
                        key: ::core::clone::Clone::clone(&(*__self_0_5)),
                        balance: ::core::clone::Clone::clone(&(*__self_0_6)),
                        generate_send_record_threshold: ::core::clone::Clone::clone(&(*__self_0_7)),
                        generate_receive_record_threshold: ::core::clone::Clone::clone(
                            &(*__self_0_8),
                        ),
                        receiver_sig_required: ::core::clone::Clone::clone(&(*__self_0_9)),
                        expiration_time: ::core::clone::Clone::clone(&(*__self_0_10)),
                        auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_11)),
                        live_hashes: ::core::clone::Clone::clone(&(*__self_0_12)),
                        token_relationships: ::core::clone::Clone::clone(&(*__self_0_13)),
                        memo: ::core::clone::Clone::clone(&(*__self_0_14)),
                        owned_nfts: ::core::clone::Clone::clone(&(*__self_0_15)),
                        max_automatic_token_associations: ::core::clone::Clone::clone(
                            &(*__self_0_16),
                        ),
                        alias: ::core::clone::Clone::clone(&(*__self_0_17)),
                        ledger_id: ::core::clone::Clone::clone(&(*__self_0_18)),
                        ethereum_nonce: ::core::clone::Clone::clone(&(*__self_0_19)),
                        staking_info: ::core::clone::Clone::clone(&(*__self_0_20)),
                    },
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for AccountInfo {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for AccountInfo {
            #[inline]
            fn eq(&self, other: &AccountInfo) -> bool {
                match *other {
                    AccountInfo {
                        account_id: ref __self_1_0,
                        contract_account_id: ref __self_1_1,
                        deleted: ref __self_1_2,
                        proxy_account_id: ref __self_1_3,
                        proxy_received: ref __self_1_4,
                        key: ref __self_1_5,
                        balance: ref __self_1_6,
                        generate_send_record_threshold: ref __self_1_7,
                        generate_receive_record_threshold: ref __self_1_8,
                        receiver_sig_required: ref __self_1_9,
                        expiration_time: ref __self_1_10,
                        auto_renew_period: ref __self_1_11,
                        live_hashes: ref __self_1_12,
                        token_relationships: ref __self_1_13,
                        memo: ref __self_1_14,
                        owned_nfts: ref __self_1_15,
                        max_automatic_token_associations: ref __self_1_16,
                        alias: ref __self_1_17,
                        ledger_id: ref __self_1_18,
                        ethereum_nonce: ref __self_1_19,
                        staking_info: ref __self_1_20,
                    } => match *self {
                        AccountInfo {
                            account_id: ref __self_0_0,
                            contract_account_id: ref __self_0_1,
                            deleted: ref __self_0_2,
                            proxy_account_id: ref __self_0_3,
                            proxy_received: ref __self_0_4,
                            key: ref __self_0_5,
                            balance: ref __self_0_6,
                            generate_send_record_threshold: ref __self_0_7,
                            generate_receive_record_threshold: ref __self_0_8,
                            receiver_sig_required: ref __self_0_9,
                            expiration_time: ref __self_0_10,
                            auto_renew_period: ref __self_0_11,
                            live_hashes: ref __self_0_12,
                            token_relationships: ref __self_0_13,
                            memo: ref __self_0_14,
                            owned_nfts: ref __self_0_15,
                            max_automatic_token_associations: ref __self_0_16,
                            alias: ref __self_0_17,
                            ledger_id: ref __self_0_18,
                            ethereum_nonce: ref __self_0_19,
                            staking_info: ref __self_0_20,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                                && (*__self_0_4) == (*__self_1_4)
                                && (*__self_0_5) == (*__self_1_5)
                                && (*__self_0_6) == (*__self_1_6)
                                && (*__self_0_7) == (*__self_1_7)
                                && (*__self_0_8) == (*__self_1_8)
                                && (*__self_0_9) == (*__self_1_9)
                                && (*__self_0_10) == (*__self_1_10)
                                && (*__self_0_11) == (*__self_1_11)
                                && (*__self_0_12) == (*__self_1_12)
                                && (*__self_0_13) == (*__self_1_13)
                                && (*__self_0_14) == (*__self_1_14)
                                && (*__self_0_15) == (*__self_1_15)
                                && (*__self_0_16) == (*__self_1_16)
                                && (*__self_0_17) == (*__self_1_17)
                                && (*__self_0_18) == (*__self_1_18)
                                && (*__self_0_19) == (*__self_1_19)
                                && (*__self_0_20) == (*__self_1_20)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &AccountInfo) -> bool {
                match *other {
                    AccountInfo {
                        account_id: ref __self_1_0,
                        contract_account_id: ref __self_1_1,
                        deleted: ref __self_1_2,
                        proxy_account_id: ref __self_1_3,
                        proxy_received: ref __self_1_4,
                        key: ref __self_1_5,
                        balance: ref __self_1_6,
                        generate_send_record_threshold: ref __self_1_7,
                        generate_receive_record_threshold: ref __self_1_8,
                        receiver_sig_required: ref __self_1_9,
                        expiration_time: ref __self_1_10,
                        auto_renew_period: ref __self_1_11,
                        live_hashes: ref __self_1_12,
                        token_relationships: ref __self_1_13,
                        memo: ref __self_1_14,
                        owned_nfts: ref __self_1_15,
                        max_automatic_token_associations: ref __self_1_16,
                        alias: ref __self_1_17,
                        ledger_id: ref __self_1_18,
                        ethereum_nonce: ref __self_1_19,
                        staking_info: ref __self_1_20,
                    } => match *self {
                        AccountInfo {
                            account_id: ref __self_0_0,
                            contract_account_id: ref __self_0_1,
                            deleted: ref __self_0_2,
                            proxy_account_id: ref __self_0_3,
                            proxy_received: ref __self_0_4,
                            key: ref __self_0_5,
                            balance: ref __self_0_6,
                            generate_send_record_threshold: ref __self_0_7,
                            generate_receive_record_threshold: ref __self_0_8,
                            receiver_sig_required: ref __self_0_9,
                            expiration_time: ref __self_0_10,
                            auto_renew_period: ref __self_0_11,
                            live_hashes: ref __self_0_12,
                            token_relationships: ref __self_0_13,
                            memo: ref __self_0_14,
                            owned_nfts: ref __self_0_15,
                            max_automatic_token_associations: ref __self_0_16,
                            alias: ref __self_0_17,
                            ledger_id: ref __self_0_18,
                            ethereum_nonce: ref __self_0_19,
                            staking_info: ref __self_0_20,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                                || (*__self_0_4) != (*__self_1_4)
                                || (*__self_0_5) != (*__self_1_5)
                                || (*__self_0_6) != (*__self_1_6)
                                || (*__self_0_7) != (*__self_1_7)
                                || (*__self_0_8) != (*__self_1_8)
                                || (*__self_0_9) != (*__self_1_9)
                                || (*__self_0_10) != (*__self_1_10)
                                || (*__self_0_11) != (*__self_1_11)
                                || (*__self_0_12) != (*__self_1_12)
                                || (*__self_0_13) != (*__self_1_13)
                                || (*__self_0_14) != (*__self_1_14)
                                || (*__self_0_15) != (*__self_1_15)
                                || (*__self_0_16) != (*__self_1_16)
                                || (*__self_0_17) != (*__self_1_17)
                                || (*__self_0_18) != (*__self_1_18)
                                || (*__self_0_19) != (*__self_1_19)
                                || (*__self_0_20) != (*__self_1_20)
                        }
                    },
                }
            }
        }
        impl ::prost::Message for AccountInfo {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if let Some(ref msg) = self.account_id {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
                if self.contract_account_id != "" {
                    ::prost::encoding::string::encode(2u32, &self.contract_account_id, buf);
                }
                if self.deleted != false {
                    ::prost::encoding::bool::encode(3u32, &self.deleted, buf);
                }
                if let Some(ref msg) = self.proxy_account_id {
                    ::prost::encoding::message::encode(4u32, msg, buf);
                }
                if self.proxy_received != 0i64 {
                    ::prost::encoding::int64::encode(6u32, &self.proxy_received, buf);
                }
                if let Some(ref msg) = self.key {
                    ::prost::encoding::message::encode(7u32, msg, buf);
                }
                if self.balance != 0u64 {
                    ::prost::encoding::uint64::encode(8u32, &self.balance, buf);
                }
                if self.generate_send_record_threshold != 0u64 {
                    ::prost::encoding::uint64::encode(
                        9u32,
                        &self.generate_send_record_threshold,
                        buf,
                    );
                }
                if self.generate_receive_record_threshold != 0u64 {
                    ::prost::encoding::uint64::encode(
                        10u32,
                        &self.generate_receive_record_threshold,
                        buf,
                    );
                }
                if self.receiver_sig_required != false {
                    ::prost::encoding::bool::encode(11u32, &self.receiver_sig_required, buf);
                }
                if let Some(ref msg) = self.expiration_time {
                    ::prost::encoding::message::encode(12u32, msg, buf);
                }
                if let Some(ref msg) = self.auto_renew_period {
                    ::prost::encoding::message::encode(13u32, msg, buf);
                }
                for msg in &self.live_hashes {
                    ::prost::encoding::message::encode(14u32, msg, buf);
                }
                for msg in &self.token_relationships {
                    ::prost::encoding::message::encode(15u32, msg, buf);
                }
                if self.memo != "" {
                    ::prost::encoding::string::encode(16u32, &self.memo, buf);
                }
                if self.owned_nfts != 0i64 {
                    ::prost::encoding::int64::encode(17u32, &self.owned_nfts, buf);
                }
                if self.max_automatic_token_associations != 0i32 {
                    ::prost::encoding::int32::encode(
                        18u32,
                        &self.max_automatic_token_associations,
                        buf,
                    );
                }
                if self.alias != b"" as &[u8] {
                    ::prost::encoding::bytes::encode(19u32, &self.alias, buf);
                }
                if self.ledger_id != b"" as &[u8] {
                    ::prost::encoding::bytes::encode(20u32, &self.ledger_id, buf);
                }
                if self.ethereum_nonce != 0i64 {
                    ::prost::encoding::int64::encode(21u32, &self.ethereum_nonce, buf);
                }
                if let Some(ref msg) = self.staking_info {
                    ::prost::encoding::message::encode(22u32, msg, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "AccountInfo";
                match tag {
                    1u32 => {
                        let mut value = &mut self.account_id;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "account_id");
                            error
                        })
                    }
                    2u32 => {
                        let mut value = &mut self.contract_account_id;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "contract_account_id");
                                error
                            },
                        )
                    }
                    3u32 => {
                        let mut value = &mut self.deleted;
                        ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "deleted");
                                error
                            },
                        )
                    }
                    4u32 => {
                        let mut value = &mut self.proxy_account_id;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "proxy_account_id");
                            error
                        })
                    }
                    6u32 => {
                        let mut value = &mut self.proxy_received;
                        ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "proxy_received");
                                error
                            },
                        )
                    }
                    7u32 => {
                        let mut value = &mut self.key;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "key");
                            error
                        })
                    }
                    8u32 => {
                        let mut value = &mut self.balance;
                        ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "balance");
                                error
                            },
                        )
                    }
                    9u32 => {
                        let mut value = &mut self.generate_send_record_threshold;
                        ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "generate_send_record_threshold");
                                error
                            },
                        )
                    }
                    10u32 => {
                        let mut value = &mut self.generate_receive_record_threshold;
                        ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "generate_receive_record_threshold");
                                error
                            },
                        )
                    }
                    11u32 => {
                        let mut value = &mut self.receiver_sig_required;
                        ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "receiver_sig_required");
                                error
                            },
                        )
                    }
                    12u32 => {
                        let mut value = &mut self.expiration_time;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "expiration_time");
                            error
                        })
                    }
                    13u32 => {
                        let mut value = &mut self.auto_renew_period;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "auto_renew_period");
                            error
                        })
                    }
                    14u32 => {
                        let mut value = &mut self.live_hashes;
                        ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "live_hashes");
                                error
                            })
                    }
                    15u32 => {
                        let mut value = &mut self.token_relationships;
                        ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "token_relationships");
                                error
                            })
                    }
                    16u32 => {
                        let mut value = &mut self.memo;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "memo");
                                error
                            },
                        )
                    }
                    17u32 => {
                        let mut value = &mut self.owned_nfts;
                        ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "owned_nfts");
                                error
                            },
                        )
                    }
                    18u32 => {
                        let mut value = &mut self.max_automatic_token_associations;
                        ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "max_automatic_token_associations");
                                error
                            },
                        )
                    }
                    19u32 => {
                        let mut value = &mut self.alias;
                        ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "alias");
                                error
                            },
                        )
                    }
                    20u32 => {
                        let mut value = &mut self.ledger_id;
                        ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "ledger_id");
                                error
                            },
                        )
                    }
                    21u32 => {
                        let mut value = &mut self.ethereum_nonce;
                        ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "ethereum_nonce");
                                error
                            },
                        )
                    }
                    22u32 => {
                        let mut value = &mut self.staking_info;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "staking_info");
                            error
                        })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                    + if self.contract_account_id != "" {
                        ::prost::encoding::string::encoded_len(2u32, &self.contract_account_id)
                    } else {
                        0
                    }
                    + if self.deleted != false {
                        ::prost::encoding::bool::encoded_len(3u32, &self.deleted)
                    } else {
                        0
                    }
                    + self
                        .proxy_account_id
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                    + if self.proxy_received != 0i64 {
                        ::prost::encoding::int64::encoded_len(6u32, &self.proxy_received)
                    } else {
                        0
                    }
                    + self
                        .key
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                    + if self.balance != 0u64 {
                        ::prost::encoding::uint64::encoded_len(8u32, &self.balance)
                    } else {
                        0
                    }
                    + if self.generate_send_record_threshold != 0u64 {
                        ::prost::encoding::uint64::encoded_len(
                            9u32,
                            &self.generate_send_record_threshold,
                        )
                    } else {
                        0
                    }
                    + if self.generate_receive_record_threshold != 0u64 {
                        ::prost::encoding::uint64::encoded_len(
                            10u32,
                            &self.generate_receive_record_threshold,
                        )
                    } else {
                        0
                    }
                    + if self.receiver_sig_required != false {
                        ::prost::encoding::bool::encoded_len(11u32, &self.receiver_sig_required)
                    } else {
                        0
                    }
                    + self
                        .expiration_time
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(12u32, msg))
                    + self
                        .auto_renew_period
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(13u32, msg))
                    + ::prost::encoding::message::encoded_len_repeated(14u32, &self.live_hashes)
                    + ::prost::encoding::message::encoded_len_repeated(
                        15u32,
                        &self.token_relationships,
                    )
                    + if self.memo != "" {
                        ::prost::encoding::string::encoded_len(16u32, &self.memo)
                    } else {
                        0
                    }
                    + if self.owned_nfts != 0i64 {
                        ::prost::encoding::int64::encoded_len(17u32, &self.owned_nfts)
                    } else {
                        0
                    }
                    + if self.max_automatic_token_associations != 0i32 {
                        ::prost::encoding::int32::encoded_len(
                            18u32,
                            &self.max_automatic_token_associations,
                        )
                    } else {
                        0
                    }
                    + if self.alias != b"" as &[u8] {
                        ::prost::encoding::bytes::encoded_len(19u32, &self.alias)
                    } else {
                        0
                    }
                    + if self.ledger_id != b"" as &[u8] {
                        ::prost::encoding::bytes::encoded_len(20u32, &self.ledger_id)
                    } else {
                        0
                    }
                    + if self.ethereum_nonce != 0i64 {
                        ::prost::encoding::int64::encoded_len(21u32, &self.ethereum_nonce)
                    } else {
                        0
                    }
                    + self
                        .staking_info
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(22u32, msg))
            }
            fn clear(&mut self) {
                self.account_id = ::core::option::Option::None;
                self.contract_account_id.clear();
                self.deleted = false;
                self.proxy_account_id = ::core::option::Option::None;
                self.proxy_received = 0i64;
                self.key = ::core::option::Option::None;
                self.balance = 0u64;
                self.generate_send_record_threshold = 0u64;
                self.generate_receive_record_threshold = 0u64;
                self.receiver_sig_required = false;
                self.expiration_time = ::core::option::Option::None;
                self.auto_renew_period = ::core::option::Option::None;
                self.live_hashes.clear();
                self.token_relationships.clear();
                self.memo.clear();
                self.owned_nfts = 0i64;
                self.max_automatic_token_associations = 0i32;
                self.alias.clear();
                self.ledger_id.clear();
                self.ethereum_nonce = 0i64;
                self.staking_info = ::core::option::Option::None;
            }
        }
        impl ::core::default::Default for AccountInfo {
            fn default() -> Self {
                AccountInfo {
                    account_id: ::core::default::Default::default(),
                    contract_account_id: ::prost::alloc::string::String::new(),
                    deleted: false,
                    proxy_account_id: ::core::default::Default::default(),
                    proxy_received: 0i64,
                    key: ::core::default::Default::default(),
                    balance: 0u64,
                    generate_send_record_threshold: 0u64,
                    generate_receive_record_threshold: 0u64,
                    receiver_sig_required: false,
                    expiration_time: ::core::default::Default::default(),
                    auto_renew_period: ::core::default::Default::default(),
                    live_hashes: ::core::default::Default::default(),
                    token_relationships: ::core::default::Default::default(),
                    memo: ::prost::alloc::string::String::new(),
                    owned_nfts: 0i64,
                    max_automatic_token_associations: 0i32,
                    alias: ::core::default::Default::default(),
                    ledger_id: ::core::default::Default::default(),
                    ethereum_nonce: 0i64,
                    staking_info: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for AccountInfo {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("AccountInfo");
                let builder = {
                    let wrapper = &self.account_id;
                    builder.field("account_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.contract_account_id)
                    };
                    builder.field("contract_account_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.deleted)
                    };
                    builder.field("deleted", &wrapper)
                };
                let builder = {
                    let wrapper = &self.proxy_account_id;
                    builder.field("proxy_account_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.proxy_received)
                    };
                    builder.field("proxy_received", &wrapper)
                };
                let builder = {
                    let wrapper = &self.key;
                    builder.field("key", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.balance)
                    };
                    builder.field("balance", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.generate_send_record_threshold)
                    };
                    builder.field("generate_send_record_threshold", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.generate_receive_record_threshold)
                    };
                    builder.field("generate_receive_record_threshold", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.receiver_sig_required)
                    };
                    builder.field("receiver_sig_required", &wrapper)
                };
                let builder = {
                    let wrapper = &self.expiration_time;
                    builder.field("expiration_time", &wrapper)
                };
                let builder = {
                    let wrapper = &self.auto_renew_period;
                    builder.field("auto_renew_period", &wrapper)
                };
                let builder = {
                    let wrapper = &self.live_hashes;
                    builder.field("live_hashes", &wrapper)
                };
                let builder = {
                    let wrapper = &self.token_relationships;
                    builder.field("token_relationships", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.memo)
                    };
                    builder.field("memo", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.owned_nfts)
                    };
                    builder.field("owned_nfts", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.max_automatic_token_associations)
                    };
                    builder.field("max_automatic_token_associations", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.alias)
                    };
                    builder.field("alias", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.ledger_id)
                    };
                    builder.field("ledger_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.ethereum_nonce)
                    };
                    builder.field("ethereum_nonce", &wrapper)
                };
                let builder = {
                    let wrapper = &self.staking_info;
                    builder.field("staking_info", &wrapper)
                };
                builder.finish()
            }
        }
    }
    /// Requests a livehash associated to an account.
    pub struct CryptoGetLiveHashQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The account to which the livehash is associated
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
        /// The SHA-384 data in the livehash
        #[prost(bytes = "vec", tag = "3")]
        pub hash: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoGetLiveHashQuery {
        #[inline]
        fn clone(&self) -> CryptoGetLiveHashQuery {
            match *self {
                CryptoGetLiveHashQuery {
                    header: ref __self_0_0,
                    account_id: ref __self_0_1,
                    hash: ref __self_0_2,
                } => CryptoGetLiveHashQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    hash: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoGetLiveHashQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoGetLiveHashQuery {
        #[inline]
        fn eq(&self, other: &CryptoGetLiveHashQuery) -> bool {
            match *other {
                CryptoGetLiveHashQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                    hash: ref __self_1_2,
                } => match *self {
                    CryptoGetLiveHashQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                        hash: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoGetLiveHashQuery) -> bool {
            match *other {
                CryptoGetLiveHashQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                    hash: ref __self_1_2,
                } => match *self {
                    CryptoGetLiveHashQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                        hash: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for CryptoGetLiveHashQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.hash != b"" as &[u8] {
                ::prost::encoding::bytes::encode(3u32, &self.hash, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoGetLiveHashQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.hash;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "hash");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.hash != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(3u32, &self.hash)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
            self.hash.clear();
        }
    }
    impl ::core::default::Default for CryptoGetLiveHashQuery {
        fn default() -> Self {
            CryptoGetLiveHashQuery {
                header: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
                hash: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoGetLiveHashQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoGetLiveHashQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.hash)
                };
                builder.field("hash", &wrapper)
            };
            builder.finish()
        }
    }
    /// Returns the full livehash associated to an account, if it is present. Note that the only way to
    /// obtain a state proof exhibiting the absence of a livehash from an account is to retrieve a state
    /// proof of the entire account with its list of livehashes.
    pub struct CryptoGetLiveHashResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The livehash, if present
        #[prost(message, optional, tag = "2")]
        pub live_hash: ::core::option::Option<LiveHash>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoGetLiveHashResponse {
        #[inline]
        fn clone(&self) -> CryptoGetLiveHashResponse {
            match *self {
                CryptoGetLiveHashResponse {
                    header: ref __self_0_0,
                    live_hash: ref __self_0_1,
                } => CryptoGetLiveHashResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    live_hash: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoGetLiveHashResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoGetLiveHashResponse {
        #[inline]
        fn eq(&self, other: &CryptoGetLiveHashResponse) -> bool {
            match *other {
                CryptoGetLiveHashResponse {
                    header: ref __self_1_0,
                    live_hash: ref __self_1_1,
                } => match *self {
                    CryptoGetLiveHashResponse {
                        header: ref __self_0_0,
                        live_hash: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoGetLiveHashResponse) -> bool {
            match *other {
                CryptoGetLiveHashResponse {
                    header: ref __self_1_0,
                    live_hash: ref __self_1_1,
                } => match *self {
                    CryptoGetLiveHashResponse {
                        header: ref __self_0_0,
                        live_hash: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CryptoGetLiveHashResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.live_hash {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoGetLiveHashResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.live_hash;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "live_hash");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .live_hash
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.live_hash = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CryptoGetLiveHashResponse {
        fn default() -> Self {
            CryptoGetLiveHashResponse {
                header: ::core::default::Default::default(),
                live_hash: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoGetLiveHashResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoGetLiveHashResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.live_hash;
                builder.field("live_hash", &wrapper)
            };
            builder.finish()
        }
    }
    /// Get all the accounts that are proxy staking to this account. For each of them, give the amount
    /// currently staked. This is not yet implemented, but will be in a future version of the API.
    pub struct CryptoGetStakersQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The Account ID for which the records should be retrieved
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoGetStakersQuery {
        #[inline]
        fn clone(&self) -> CryptoGetStakersQuery {
            match *self {
                CryptoGetStakersQuery {
                    header: ref __self_0_0,
                    account_id: ref __self_0_1,
                } => CryptoGetStakersQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoGetStakersQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoGetStakersQuery {
        #[inline]
        fn eq(&self, other: &CryptoGetStakersQuery) -> bool {
            match *other {
                CryptoGetStakersQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                } => match *self {
                    CryptoGetStakersQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoGetStakersQuery) -> bool {
            match *other {
                CryptoGetStakersQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                } => match *self {
                    CryptoGetStakersQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CryptoGetStakersQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoGetStakersQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CryptoGetStakersQuery {
        fn default() -> Self {
            CryptoGetStakersQuery {
                header: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoGetStakersQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoGetStakersQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// information about a single account that is proxy staking
    pub struct ProxyStaker {
        /// The Account ID that is proxy staking
        #[prost(message, optional, tag = "1")]
        pub account_id: ::core::option::Option<AccountId>,
        /// The number of hbars that are currently proxy staked
        #[prost(int64, tag = "2")]
        pub amount: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ProxyStaker {
        #[inline]
        fn clone(&self) -> ProxyStaker {
            match *self {
                ProxyStaker {
                    account_id: ref __self_0_0,
                    amount: ref __self_0_1,
                } => ProxyStaker {
                    account_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    amount: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ProxyStaker {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ProxyStaker {
        #[inline]
        fn eq(&self, other: &ProxyStaker) -> bool {
            match *other {
                ProxyStaker {
                    account_id: ref __self_1_0,
                    amount: ref __self_1_1,
                } => match *self {
                    ProxyStaker {
                        account_id: ref __self_0_0,
                        amount: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ProxyStaker) -> bool {
            match *other {
                ProxyStaker {
                    account_id: ref __self_1_0,
                    amount: ref __self_1_1,
                } => match *self {
                    ProxyStaker {
                        account_id: ref __self_0_0,
                        amount: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ProxyStaker {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.amount != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.amount, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ProxyStaker";
            match tag {
                1u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .account_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.amount != 0i64 {
                    ::prost::encoding::int64::encoded_len(2u32, &self.amount)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.account_id = ::core::option::Option::None;
            self.amount = 0i64;
        }
    }
    impl ::core::default::Default for ProxyStaker {
        fn default() -> Self {
            ProxyStaker {
                account_id: ::core::default::Default::default(),
                amount: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for ProxyStaker {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ProxyStaker");
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            builder.finish()
        }
    }
    /// all of the accounts proxy staking to a given account, and the amounts proxy staked
    pub struct AllProxyStakers {
        /// The Account ID that is being proxy staked to
        #[prost(message, optional, tag = "1")]
        pub account_id: ::core::option::Option<AccountId>,
        /// Each of the proxy staking accounts, and the amount they are proxy staking
        #[prost(message, repeated, tag = "2")]
        pub proxy_staker: ::prost::alloc::vec::Vec<ProxyStaker>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for AllProxyStakers {
        #[inline]
        fn clone(&self) -> AllProxyStakers {
            match *self {
                AllProxyStakers {
                    account_id: ref __self_0_0,
                    proxy_staker: ref __self_0_1,
                } => AllProxyStakers {
                    account_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    proxy_staker: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for AllProxyStakers {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for AllProxyStakers {
        #[inline]
        fn eq(&self, other: &AllProxyStakers) -> bool {
            match *other {
                AllProxyStakers {
                    account_id: ref __self_1_0,
                    proxy_staker: ref __self_1_1,
                } => match *self {
                    AllProxyStakers {
                        account_id: ref __self_0_0,
                        proxy_staker: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &AllProxyStakers) -> bool {
            match *other {
                AllProxyStakers {
                    account_id: ref __self_1_0,
                    proxy_staker: ref __self_1_1,
                } => match *self {
                    AllProxyStakers {
                        account_id: ref __self_0_0,
                        proxy_staker: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for AllProxyStakers {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.proxy_staker {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "AllProxyStakers";
            match tag {
                1u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.proxy_staker;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "proxy_staker");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .account_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.proxy_staker)
        }
        fn clear(&mut self) {
            self.account_id = ::core::option::Option::None;
            self.proxy_staker.clear();
        }
    }
    impl ::core::default::Default for AllProxyStakers {
        fn default() -> Self {
            AllProxyStakers {
                account_id: ::core::default::Default::default(),
                proxy_staker: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for AllProxyStakers {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("AllProxyStakers");
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.proxy_staker;
                builder.field("proxy_staker", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node CryptoGetStakersQuery
    pub struct CryptoGetStakersResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// List of accounts proxy staking to this account, and the amount each is currently proxy
        /// staking
        #[prost(message, optional, tag = "3")]
        pub stakers: ::core::option::Option<AllProxyStakers>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CryptoGetStakersResponse {
        #[inline]
        fn clone(&self) -> CryptoGetStakersResponse {
            match *self {
                CryptoGetStakersResponse {
                    header: ref __self_0_0,
                    stakers: ref __self_0_1,
                } => CryptoGetStakersResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    stakers: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for CryptoGetStakersResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CryptoGetStakersResponse {
        #[inline]
        fn eq(&self, other: &CryptoGetStakersResponse) -> bool {
            match *other {
                CryptoGetStakersResponse {
                    header: ref __self_1_0,
                    stakers: ref __self_1_1,
                } => match *self {
                    CryptoGetStakersResponse {
                        header: ref __self_0_0,
                        stakers: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &CryptoGetStakersResponse) -> bool {
            match *other {
                CryptoGetStakersResponse {
                    header: ref __self_1_0,
                    stakers: ref __self_1_1,
                } => match *self {
                    CryptoGetStakersResponse {
                        header: ref __self_0_0,
                        stakers: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for CryptoGetStakersResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.stakers {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "CryptoGetStakersResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.stakers;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "stakers");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .stakers
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.stakers = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for CryptoGetStakersResponse {
        fn default() -> Self {
            CryptoGetStakersResponse {
                header: ::core::default::Default::default(),
                stakers: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for CryptoGetStakersResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("CryptoGetStakersResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.stakers;
                builder.field("stakers", &wrapper)
            };
            builder.finish()
        }
    }
    /// Get the contents of a file. The content field is empty (no bytes) if the file is empty.
    pub struct FileGetContentsQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The file ID of the file whose contents are requested
        #[prost(message, optional, tag = "2")]
        pub file_id: ::core::option::Option<FileId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FileGetContentsQuery {
        #[inline]
        fn clone(&self) -> FileGetContentsQuery {
            match *self {
                FileGetContentsQuery {
                    header: ref __self_0_0,
                    file_id: ref __self_0_1,
                } => FileGetContentsQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    file_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FileGetContentsQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FileGetContentsQuery {
        #[inline]
        fn eq(&self, other: &FileGetContentsQuery) -> bool {
            match *other {
                FileGetContentsQuery {
                    header: ref __self_1_0,
                    file_id: ref __self_1_1,
                } => match *self {
                    FileGetContentsQuery {
                        header: ref __self_0_0,
                        file_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FileGetContentsQuery) -> bool {
            match *other {
                FileGetContentsQuery {
                    header: ref __self_1_0,
                    file_id: ref __self_1_1,
                } => match *self {
                    FileGetContentsQuery {
                        header: ref __self_0_0,
                        file_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for FileGetContentsQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.file_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FileGetContentsQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.file_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "file_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .file_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.file_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for FileGetContentsQuery {
        fn default() -> Self {
            FileGetContentsQuery {
                header: ::core::default::Default::default(),
                file_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for FileGetContentsQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FileGetContentsQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.file_id;
                builder.field("file_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node FileGetContentsQuery
    pub struct FileGetContentsResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// the file ID and contents (a state proof can be generated for this)
        #[prost(message, optional, tag = "2")]
        pub file_contents: ::core::option::Option<file_get_contents_response::FileContents>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FileGetContentsResponse {
        #[inline]
        fn clone(&self) -> FileGetContentsResponse {
            match *self {
                FileGetContentsResponse {
                    header: ref __self_0_0,
                    file_contents: ref __self_0_1,
                } => FileGetContentsResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    file_contents: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FileGetContentsResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FileGetContentsResponse {
        #[inline]
        fn eq(&self, other: &FileGetContentsResponse) -> bool {
            match *other {
                FileGetContentsResponse {
                    header: ref __self_1_0,
                    file_contents: ref __self_1_1,
                } => match *self {
                    FileGetContentsResponse {
                        header: ref __self_0_0,
                        file_contents: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FileGetContentsResponse) -> bool {
            match *other {
                FileGetContentsResponse {
                    header: ref __self_1_0,
                    file_contents: ref __self_1_1,
                } => match *self {
                    FileGetContentsResponse {
                        header: ref __self_0_0,
                        file_contents: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for FileGetContentsResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.file_contents {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FileGetContentsResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.file_contents;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "file_contents");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .file_contents
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.file_contents = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for FileGetContentsResponse {
        fn default() -> Self {
            FileGetContentsResponse {
                header: ::core::default::Default::default(),
                file_contents: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for FileGetContentsResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FileGetContentsResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.file_contents;
                builder.field("file_contents", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `FileGetContentsResponse`.
    pub mod file_get_contents_response {
        pub struct FileContents {
            /// The file ID of the file whose contents are being returned
            #[prost(message, optional, tag = "1")]
            pub file_id: ::core::option::Option<super::FileId>,
            /// The bytes contained in the file
            #[prost(bytes = "vec", tag = "2")]
            pub contents: ::prost::alloc::vec::Vec<u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for FileContents {
            #[inline]
            fn clone(&self) -> FileContents {
                match *self {
                    FileContents {
                        file_id: ref __self_0_0,
                        contents: ref __self_0_1,
                    } => FileContents {
                        file_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                        contents: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for FileContents {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for FileContents {
            #[inline]
            fn eq(&self, other: &FileContents) -> bool {
                match *other {
                    FileContents {
                        file_id: ref __self_1_0,
                        contents: ref __self_1_1,
                    } => match *self {
                        FileContents {
                            file_id: ref __self_0_0,
                            contents: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &FileContents) -> bool {
                match *other {
                    FileContents {
                        file_id: ref __self_1_0,
                        contents: ref __self_1_1,
                    } => match *self {
                        FileContents {
                            file_id: ref __self_0_0,
                            contents: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        impl ::prost::Message for FileContents {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if let Some(ref msg) = self.file_id {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
                if self.contents != b"" as &[u8] {
                    ::prost::encoding::bytes::encode(2u32, &self.contents, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "FileContents";
                match tag {
                    1u32 => {
                        let mut value = &mut self.file_id;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "file_id");
                            error
                        })
                    }
                    2u32 => {
                        let mut value = &mut self.contents;
                        ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "contents");
                                error
                            },
                        )
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 + self
                    .file_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                    + if self.contents != b"" as &[u8] {
                        ::prost::encoding::bytes::encoded_len(2u32, &self.contents)
                    } else {
                        0
                    }
            }
            fn clear(&mut self) {
                self.file_id = ::core::option::Option::None;
                self.contents.clear();
            }
        }
        impl ::core::default::Default for FileContents {
            fn default() -> Self {
                FileContents {
                    file_id: ::core::default::Default::default(),
                    contents: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for FileContents {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("FileContents");
                let builder = {
                    let wrapper = &self.file_id;
                    builder.field("file_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.contents)
                    };
                    builder.field("contents", &wrapper)
                };
                builder.finish()
            }
        }
    }
    /// Get all of the information about a file, except for its contents. When a file expires, it no
    /// longer exists, and there will be no info about it, and the fileInfo field will be blank. If a
    /// transaction or smart contract deletes the file, but it has not yet expired, then the fileInfo
    /// field will be non-empty, the deleted field will be true, its size will be 0, and its contents
    /// will be empty.
    pub struct FileGetInfoQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The file ID of the file for which information is requested
        #[prost(message, optional, tag = "2")]
        pub file_id: ::core::option::Option<FileId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FileGetInfoQuery {
        #[inline]
        fn clone(&self) -> FileGetInfoQuery {
            match *self {
                FileGetInfoQuery {
                    header: ref __self_0_0,
                    file_id: ref __self_0_1,
                } => FileGetInfoQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    file_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FileGetInfoQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FileGetInfoQuery {
        #[inline]
        fn eq(&self, other: &FileGetInfoQuery) -> bool {
            match *other {
                FileGetInfoQuery {
                    header: ref __self_1_0,
                    file_id: ref __self_1_1,
                } => match *self {
                    FileGetInfoQuery {
                        header: ref __self_0_0,
                        file_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FileGetInfoQuery) -> bool {
            match *other {
                FileGetInfoQuery {
                    header: ref __self_1_0,
                    file_id: ref __self_1_1,
                } => match *self {
                    FileGetInfoQuery {
                        header: ref __self_0_0,
                        file_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for FileGetInfoQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.file_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FileGetInfoQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.file_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "file_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .file_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.file_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for FileGetInfoQuery {
        fn default() -> Self {
            FileGetInfoQuery {
                header: ::core::default::Default::default(),
                file_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for FileGetInfoQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FileGetInfoQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.file_id;
                builder.field("file_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node FileGetInfoQuery
    pub struct FileGetInfoResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The information about the file
        #[prost(message, optional, tag = "2")]
        pub file_info: ::core::option::Option<file_get_info_response::FileInfo>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for FileGetInfoResponse {
        #[inline]
        fn clone(&self) -> FileGetInfoResponse {
            match *self {
                FileGetInfoResponse {
                    header: ref __self_0_0,
                    file_info: ref __self_0_1,
                } => FileGetInfoResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    file_info: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for FileGetInfoResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for FileGetInfoResponse {
        #[inline]
        fn eq(&self, other: &FileGetInfoResponse) -> bool {
            match *other {
                FileGetInfoResponse {
                    header: ref __self_1_0,
                    file_info: ref __self_1_1,
                } => match *self {
                    FileGetInfoResponse {
                        header: ref __self_0_0,
                        file_info: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FileGetInfoResponse) -> bool {
            match *other {
                FileGetInfoResponse {
                    header: ref __self_1_0,
                    file_info: ref __self_1_1,
                } => match *self {
                    FileGetInfoResponse {
                        header: ref __self_0_0,
                        file_info: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for FileGetInfoResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.file_info {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "FileGetInfoResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.file_info;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "file_info");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .file_info
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.file_info = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for FileGetInfoResponse {
        fn default() -> Self {
            FileGetInfoResponse {
                header: ::core::default::Default::default(),
                file_info: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for FileGetInfoResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("FileGetInfoResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.file_info;
                builder.field("file_info", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `FileGetInfoResponse`.
    pub mod file_get_info_response {
        pub struct FileInfo {
            /// The file ID of the file for which information is requested
            #[prost(message, optional, tag = "1")]
            pub file_id: ::core::option::Option<super::FileId>,
            /// Number of bytes in contents
            #[prost(int64, tag = "2")]
            pub size: i64,
            /// The current time at which this account is set to expire
            #[prost(message, optional, tag = "3")]
            pub expiration_time: ::core::option::Option<super::Timestamp>,
            /// True if deleted but not yet expired
            #[prost(bool, tag = "4")]
            pub deleted: bool,
            /// One of these keys must sign in order to modify or delete the file
            #[prost(message, optional, tag = "5")]
            pub keys: ::core::option::Option<super::KeyList>,
            /// The memo associated with the file
            #[prost(string, tag = "6")]
            pub memo: ::prost::alloc::string::String,
            /// The ledger ID the response was returned from; please see <a href="<https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a>> for the network-specific IDs.
            #[prost(bytes = "vec", tag = "7")]
            pub ledger_id: ::prost::alloc::vec::Vec<u8>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for FileInfo {
            #[inline]
            fn clone(&self) -> FileInfo {
                match *self {
                    FileInfo {
                        file_id: ref __self_0_0,
                        size: ref __self_0_1,
                        expiration_time: ref __self_0_2,
                        deleted: ref __self_0_3,
                        keys: ref __self_0_4,
                        memo: ref __self_0_5,
                        ledger_id: ref __self_0_6,
                    } => FileInfo {
                        file_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                        size: ::core::clone::Clone::clone(&(*__self_0_1)),
                        expiration_time: ::core::clone::Clone::clone(&(*__self_0_2)),
                        deleted: ::core::clone::Clone::clone(&(*__self_0_3)),
                        keys: ::core::clone::Clone::clone(&(*__self_0_4)),
                        memo: ::core::clone::Clone::clone(&(*__self_0_5)),
                        ledger_id: ::core::clone::Clone::clone(&(*__self_0_6)),
                    },
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for FileInfo {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for FileInfo {
            #[inline]
            fn eq(&self, other: &FileInfo) -> bool {
                match *other {
                    FileInfo {
                        file_id: ref __self_1_0,
                        size: ref __self_1_1,
                        expiration_time: ref __self_1_2,
                        deleted: ref __self_1_3,
                        keys: ref __self_1_4,
                        memo: ref __self_1_5,
                        ledger_id: ref __self_1_6,
                    } => match *self {
                        FileInfo {
                            file_id: ref __self_0_0,
                            size: ref __self_0_1,
                            expiration_time: ref __self_0_2,
                            deleted: ref __self_0_3,
                            keys: ref __self_0_4,
                            memo: ref __self_0_5,
                            ledger_id: ref __self_0_6,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                                && (*__self_0_4) == (*__self_1_4)
                                && (*__self_0_5) == (*__self_1_5)
                                && (*__self_0_6) == (*__self_1_6)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &FileInfo) -> bool {
                match *other {
                    FileInfo {
                        file_id: ref __self_1_0,
                        size: ref __self_1_1,
                        expiration_time: ref __self_1_2,
                        deleted: ref __self_1_3,
                        keys: ref __self_1_4,
                        memo: ref __self_1_5,
                        ledger_id: ref __self_1_6,
                    } => match *self {
                        FileInfo {
                            file_id: ref __self_0_0,
                            size: ref __self_0_1,
                            expiration_time: ref __self_0_2,
                            deleted: ref __self_0_3,
                            keys: ref __self_0_4,
                            memo: ref __self_0_5,
                            ledger_id: ref __self_0_6,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                                || (*__self_0_4) != (*__self_1_4)
                                || (*__self_0_5) != (*__self_1_5)
                                || (*__self_0_6) != (*__self_1_6)
                        }
                    },
                }
            }
        }
        impl ::prost::Message for FileInfo {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if let Some(ref msg) = self.file_id {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
                if self.size != 0i64 {
                    ::prost::encoding::int64::encode(2u32, &self.size, buf);
                }
                if let Some(ref msg) = self.expiration_time {
                    ::prost::encoding::message::encode(3u32, msg, buf);
                }
                if self.deleted != false {
                    ::prost::encoding::bool::encode(4u32, &self.deleted, buf);
                }
                if let Some(ref msg) = self.keys {
                    ::prost::encoding::message::encode(5u32, msg, buf);
                }
                if self.memo != "" {
                    ::prost::encoding::string::encode(6u32, &self.memo, buf);
                }
                if self.ledger_id != b"" as &[u8] {
                    ::prost::encoding::bytes::encode(7u32, &self.ledger_id, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "FileInfo";
                match tag {
                    1u32 => {
                        let mut value = &mut self.file_id;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "file_id");
                            error
                        })
                    }
                    2u32 => {
                        let mut value = &mut self.size;
                        ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "size");
                                error
                            },
                        )
                    }
                    3u32 => {
                        let mut value = &mut self.expiration_time;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "expiration_time");
                            error
                        })
                    }
                    4u32 => {
                        let mut value = &mut self.deleted;
                        ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "deleted");
                                error
                            },
                        )
                    }
                    5u32 => {
                        let mut value = &mut self.keys;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "keys");
                            error
                        })
                    }
                    6u32 => {
                        let mut value = &mut self.memo;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "memo");
                                error
                            },
                        )
                    }
                    7u32 => {
                        let mut value = &mut self.ledger_id;
                        ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "ledger_id");
                                error
                            },
                        )
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 + self
                    .file_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                    + if self.size != 0i64 {
                        ::prost::encoding::int64::encoded_len(2u32, &self.size)
                    } else {
                        0
                    }
                    + self
                        .expiration_time
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                    + if self.deleted != false {
                        ::prost::encoding::bool::encoded_len(4u32, &self.deleted)
                    } else {
                        0
                    }
                    + self
                        .keys
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                    + if self.memo != "" {
                        ::prost::encoding::string::encoded_len(6u32, &self.memo)
                    } else {
                        0
                    }
                    + if self.ledger_id != b"" as &[u8] {
                        ::prost::encoding::bytes::encoded_len(7u32, &self.ledger_id)
                    } else {
                        0
                    }
            }
            fn clear(&mut self) {
                self.file_id = ::core::option::Option::None;
                self.size = 0i64;
                self.expiration_time = ::core::option::Option::None;
                self.deleted = false;
                self.keys = ::core::option::Option::None;
                self.memo.clear();
                self.ledger_id.clear();
            }
        }
        impl ::core::default::Default for FileInfo {
            fn default() -> Self {
                FileInfo {
                    file_id: ::core::default::Default::default(),
                    size: 0i64,
                    expiration_time: ::core::default::Default::default(),
                    deleted: false,
                    keys: ::core::default::Default::default(),
                    memo: ::prost::alloc::string::String::new(),
                    ledger_id: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for FileInfo {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("FileInfo");
                let builder = {
                    let wrapper = &self.file_id;
                    builder.field("file_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.size)
                    };
                    builder.field("size", &wrapper)
                };
                let builder = {
                    let wrapper = &self.expiration_time;
                    builder.field("expiration_time", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.deleted)
                    };
                    builder.field("deleted", &wrapper)
                };
                let builder = {
                    let wrapper = &self.keys;
                    builder.field("keys", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.memo)
                    };
                    builder.field("memo", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.ledger_id)
                    };
                    builder.field("ledger_id", &wrapper)
                };
                builder.finish()
            }
        }
    }
    /// Get the receipt of a transaction, given its transaction ID. Once a transaction reaches consensus,
    /// then information about whether it succeeded or failed will be available until the end of the
    /// receipt period.  Before and after the receipt period, and for a transaction that was never
    /// submitted, the receipt is unknown.  This query is free (the payment field is left empty). No
    /// State proof is available for this response
    pub struct TransactionGetReceiptQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The ID of the transaction for which the receipt is requested.
        #[prost(message, optional, tag = "2")]
        pub transaction_id: ::core::option::Option<TransactionId>,
        /// Whether receipts of processing duplicate transactions should be returned along with the
        /// receipt of processing the first consensus transaction with the given id whose status was
        /// neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>; <b>or</b>, if no
        /// such receipt exists, the receipt of processing the first transaction to reach consensus with
        /// the given transaction id.
        #[prost(bool, tag = "3")]
        pub include_duplicates: bool,
        /// Whether the response should include the receipts of any child transactions spawned by the
        /// top-level transaction with the given transactionID.
        #[prost(bool, tag = "4")]
        pub include_child_receipts: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionGetReceiptQuery {
        #[inline]
        fn clone(&self) -> TransactionGetReceiptQuery {
            match *self {
                TransactionGetReceiptQuery {
                    header: ref __self_0_0,
                    transaction_id: ref __self_0_1,
                    include_duplicates: ref __self_0_2,
                    include_child_receipts: ref __self_0_3,
                } => TransactionGetReceiptQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    transaction_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    include_duplicates: ::core::clone::Clone::clone(&(*__self_0_2)),
                    include_child_receipts: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionGetReceiptQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionGetReceiptQuery {
        #[inline]
        fn eq(&self, other: &TransactionGetReceiptQuery) -> bool {
            match *other {
                TransactionGetReceiptQuery {
                    header: ref __self_1_0,
                    transaction_id: ref __self_1_1,
                    include_duplicates: ref __self_1_2,
                    include_child_receipts: ref __self_1_3,
                } => match *self {
                    TransactionGetReceiptQuery {
                        header: ref __self_0_0,
                        transaction_id: ref __self_0_1,
                        include_duplicates: ref __self_0_2,
                        include_child_receipts: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionGetReceiptQuery) -> bool {
            match *other {
                TransactionGetReceiptQuery {
                    header: ref __self_1_0,
                    transaction_id: ref __self_1_1,
                    include_duplicates: ref __self_1_2,
                    include_child_receipts: ref __self_1_3,
                } => match *self {
                    TransactionGetReceiptQuery {
                        header: ref __self_0_0,
                        transaction_id: ref __self_0_1,
                        include_duplicates: ref __self_0_2,
                        include_child_receipts: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TransactionGetReceiptQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.transaction_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.include_duplicates != false {
                ::prost::encoding::bool::encode(3u32, &self.include_duplicates, buf);
            }
            if self.include_child_receipts != false {
                ::prost::encoding::bool::encode(4u32, &self.include_child_receipts, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionGetReceiptQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.transaction_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transaction_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.include_duplicates;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "include_duplicates");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.include_child_receipts;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "include_child_receipts");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .transaction_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.include_duplicates != false {
                    ::prost::encoding::bool::encoded_len(3u32, &self.include_duplicates)
                } else {
                    0
                }
                + if self.include_child_receipts != false {
                    ::prost::encoding::bool::encoded_len(4u32, &self.include_child_receipts)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.transaction_id = ::core::option::Option::None;
            self.include_duplicates = false;
            self.include_child_receipts = false;
        }
    }
    impl ::core::default::Default for TransactionGetReceiptQuery {
        fn default() -> Self {
            TransactionGetReceiptQuery {
                header: ::core::default::Default::default(),
                transaction_id: ::core::default::Default::default(),
                include_duplicates: false,
                include_child_receipts: false,
            }
        }
    }
    impl ::core::fmt::Debug for TransactionGetReceiptQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionGetReceiptQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.transaction_id;
                builder.field("transaction_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.include_duplicates)
                };
                builder.field("include_duplicates", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.include_child_receipts)
                };
                builder.field("include_child_receipts", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node TransactionGetReceiptQuery. If it created a new entity
    /// (account, file, or smart contract instance) then one of the three ID fields will be filled in
    /// with the ID of the new entity. Sometimes a single transaction will create more than one new
    /// entity, such as when a new contract instance is created, and this also creates the new account
    /// that it owned by that instance. No State proof is available for this response
    pub struct TransactionGetReceiptResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// Either the receipt of processing the first consensus transaction with the given id whose
        /// status was neither <tt>INVALID_NODE_ACCOUNT</tt> nor <tt>INVALID_PAYER_SIGNATURE</tt>;
        /// <b>or</b>, if no such receipt exists, the receipt of processing the first transaction to
        /// reach consensus with the given transaction id.
        #[prost(message, optional, tag = "2")]
        pub receipt: ::core::option::Option<TransactionReceipt>,
        /// The receipts of processing all transactions with the given id, in consensus time order.
        #[prost(message, repeated, tag = "4")]
        pub duplicate_transaction_receipts: ::prost::alloc::vec::Vec<TransactionReceipt>,
        /// The receipts (if any) of all child transactions spawned by the transaction with the
        /// given top-level id, in consensus order. Always empty if the top-level status is UNKNOWN.
        #[prost(message, repeated, tag = "5")]
        pub child_transaction_receipts: ::prost::alloc::vec::Vec<TransactionReceipt>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionGetReceiptResponse {
        #[inline]
        fn clone(&self) -> TransactionGetReceiptResponse {
            match *self {
                TransactionGetReceiptResponse {
                    header: ref __self_0_0,
                    receipt: ref __self_0_1,
                    duplicate_transaction_receipts: ref __self_0_2,
                    child_transaction_receipts: ref __self_0_3,
                } => TransactionGetReceiptResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    receipt: ::core::clone::Clone::clone(&(*__self_0_1)),
                    duplicate_transaction_receipts: ::core::clone::Clone::clone(&(*__self_0_2)),
                    child_transaction_receipts: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionGetReceiptResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionGetReceiptResponse {
        #[inline]
        fn eq(&self, other: &TransactionGetReceiptResponse) -> bool {
            match *other {
                TransactionGetReceiptResponse {
                    header: ref __self_1_0,
                    receipt: ref __self_1_1,
                    duplicate_transaction_receipts: ref __self_1_2,
                    child_transaction_receipts: ref __self_1_3,
                } => match *self {
                    TransactionGetReceiptResponse {
                        header: ref __self_0_0,
                        receipt: ref __self_0_1,
                        duplicate_transaction_receipts: ref __self_0_2,
                        child_transaction_receipts: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionGetReceiptResponse) -> bool {
            match *other {
                TransactionGetReceiptResponse {
                    header: ref __self_1_0,
                    receipt: ref __self_1_1,
                    duplicate_transaction_receipts: ref __self_1_2,
                    child_transaction_receipts: ref __self_1_3,
                } => match *self {
                    TransactionGetReceiptResponse {
                        header: ref __self_0_0,
                        receipt: ref __self_0_1,
                        duplicate_transaction_receipts: ref __self_0_2,
                        child_transaction_receipts: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TransactionGetReceiptResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.receipt {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            for msg in &self.duplicate_transaction_receipts {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            for msg in &self.child_transaction_receipts {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionGetReceiptResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.receipt;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "receipt");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.duplicate_transaction_receipts;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "duplicate_transaction_receipts");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.child_transaction_receipts;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "child_transaction_receipts");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .receipt
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(
                    4u32,
                    &self.duplicate_transaction_receipts,
                )
                + ::prost::encoding::message::encoded_len_repeated(
                    5u32,
                    &self.child_transaction_receipts,
                )
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.receipt = ::core::option::Option::None;
            self.duplicate_transaction_receipts.clear();
            self.child_transaction_receipts.clear();
        }
    }
    impl ::core::default::Default for TransactionGetReceiptResponse {
        fn default() -> Self {
            TransactionGetReceiptResponse {
                header: ::core::default::Default::default(),
                receipt: ::core::default::Default::default(),
                duplicate_transaction_receipts: ::core::default::Default::default(),
                child_transaction_receipts: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TransactionGetReceiptResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionGetReceiptResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.receipt;
                builder.field("receipt", &wrapper)
            };
            let builder = {
                let wrapper = &self.duplicate_transaction_receipts;
                builder.field("duplicate_transaction_receipts", &wrapper)
            };
            let builder = {
                let wrapper = &self.child_transaction_receipts;
                builder.field("child_transaction_receipts", &wrapper)
            };
            builder.finish()
        }
    }
    /// Get the tx record of a transaction, given its transaction ID. Once a transaction reaches
    /// consensus, then information about whether it succeeded or failed will be available until the end
    /// of the receipt period.  Before and after the receipt period, and for a transaction that was never
    /// submitted, the receipt is unknown.  This query is free (the payment field is left empty).
    pub struct TransactionGetFastRecordQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The ID of the transaction for which the record is requested.
        #[prost(message, optional, tag = "2")]
        pub transaction_id: ::core::option::Option<TransactionId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionGetFastRecordQuery {
        #[inline]
        fn clone(&self) -> TransactionGetFastRecordQuery {
            match *self {
                TransactionGetFastRecordQuery {
                    header: ref __self_0_0,
                    transaction_id: ref __self_0_1,
                } => TransactionGetFastRecordQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    transaction_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionGetFastRecordQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionGetFastRecordQuery {
        #[inline]
        fn eq(&self, other: &TransactionGetFastRecordQuery) -> bool {
            match *other {
                TransactionGetFastRecordQuery {
                    header: ref __self_1_0,
                    transaction_id: ref __self_1_1,
                } => match *self {
                    TransactionGetFastRecordQuery {
                        header: ref __self_0_0,
                        transaction_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionGetFastRecordQuery) -> bool {
            match *other {
                TransactionGetFastRecordQuery {
                    header: ref __self_1_0,
                    transaction_id: ref __self_1_1,
                } => match *self {
                    TransactionGetFastRecordQuery {
                        header: ref __self_0_0,
                        transaction_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TransactionGetFastRecordQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.transaction_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionGetFastRecordQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.transaction_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transaction_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .transaction_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.transaction_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TransactionGetFastRecordQuery {
        fn default() -> Self {
            TransactionGetFastRecordQuery {
                header: ::core::default::Default::default(),
                transaction_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TransactionGetFastRecordQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionGetFastRecordQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.transaction_id;
                builder.field("transaction_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node TransactionGetFastRecordQuery. If it created a new entity
    /// (account, file, or smart contract instance) then one of the three ID fields will be filled in
    /// with the ID of the new entity. Sometimes a single transaction will create more than one new
    /// entity, such as when a new contract instance is created, and this also creates the new account
    /// that it owned by that instance.
    pub struct TransactionGetFastRecordResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The requested transaction records
        #[prost(message, optional, tag = "2")]
        pub transaction_record: ::core::option::Option<TransactionRecord>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TransactionGetFastRecordResponse {
        #[inline]
        fn clone(&self) -> TransactionGetFastRecordResponse {
            match *self {
                TransactionGetFastRecordResponse {
                    header: ref __self_0_0,
                    transaction_record: ref __self_0_1,
                } => TransactionGetFastRecordResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    transaction_record: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TransactionGetFastRecordResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TransactionGetFastRecordResponse {
        #[inline]
        fn eq(&self, other: &TransactionGetFastRecordResponse) -> bool {
            match *other {
                TransactionGetFastRecordResponse {
                    header: ref __self_1_0,
                    transaction_record: ref __self_1_1,
                } => match *self {
                    TransactionGetFastRecordResponse {
                        header: ref __self_0_0,
                        transaction_record: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TransactionGetFastRecordResponse) -> bool {
            match *other {
                TransactionGetFastRecordResponse {
                    header: ref __self_1_0,
                    transaction_record: ref __self_1_1,
                } => match *self {
                    TransactionGetFastRecordResponse {
                        header: ref __self_0_0,
                        transaction_record: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TransactionGetFastRecordResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.transaction_record {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TransactionGetFastRecordResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.transaction_record;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "transaction_record");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .transaction_record
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.transaction_record = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TransactionGetFastRecordResponse {
        fn default() -> Self {
            TransactionGetFastRecordResponse {
                header: ::core::default::Default::default(),
                transaction_record: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TransactionGetFastRecordResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TransactionGetFastRecordResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.transaction_record;
                builder.field("transaction_record", &wrapper)
            };
            builder.finish()
        }
    }
    /// Current state of a topic.
    pub struct ConsensusTopicInfo {
        /// The memo associated with the topic (UTF-8 encoding max 100 bytes)
        #[prost(string, tag = "1")]
        pub memo: ::prost::alloc::string::String,
        /// When a topic is created, its running hash is initialized to 48 bytes of binary zeros.
        /// For each submitted message, the topic's running hash is then updated to the output
        /// of a particular SHA-384 digest whose input data include the previous running hash.
        ///
        /// See the TransactionReceipt.proto documentation for an exact description of the
        /// data included in the SHA-384 digest used for the update.
        #[prost(bytes = "vec", tag = "2")]
        pub running_hash: ::prost::alloc::vec::Vec<u8>,
        /// Sequence number (starting at 1 for the first submitMessage) of messages on the topic.
        #[prost(uint64, tag = "3")]
        pub sequence_number: u64,
        /// Effective consensus timestamp at (and after) which submitMessage calls will no longer succeed on the topic
        /// and the topic will expire and after AUTORENEW_GRACE_PERIOD be automatically deleted.
        #[prost(message, optional, tag = "4")]
        pub expiration_time: ::core::option::Option<Timestamp>,
        /// Access control for update/delete of the topic. Null if there is no key.
        #[prost(message, optional, tag = "5")]
        pub admin_key: ::core::option::Option<Key>,
        /// Access control for ConsensusService.submitMessage. Null if there is no key.
        #[prost(message, optional, tag = "6")]
        pub submit_key: ::core::option::Option<Key>,
        /// If an auto-renew account is specified, when the topic expires, its lifetime will be extended
        /// by up to this duration (depending on the solvency of the auto-renew account). If the
        /// auto-renew account has no funds at all, the topic will be deleted instead.
        #[prost(message, optional, tag = "7")]
        pub auto_renew_period: ::core::option::Option<Duration>,
        /// The account, if any, to charge for automatic renewal of the topic's lifetime upon expiry.
        #[prost(message, optional, tag = "8")]
        pub auto_renew_account: ::core::option::Option<AccountId>,
        /// The ledger ID the response was returned from; please see <a href="<https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a>> for the network-specific IDs.
        #[prost(bytes = "vec", tag = "9")]
        pub ledger_id: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ConsensusTopicInfo {
        #[inline]
        fn clone(&self) -> ConsensusTopicInfo {
            match *self {
                ConsensusTopicInfo {
                    memo: ref __self_0_0,
                    running_hash: ref __self_0_1,
                    sequence_number: ref __self_0_2,
                    expiration_time: ref __self_0_3,
                    admin_key: ref __self_0_4,
                    submit_key: ref __self_0_5,
                    auto_renew_period: ref __self_0_6,
                    auto_renew_account: ref __self_0_7,
                    ledger_id: ref __self_0_8,
                } => ConsensusTopicInfo {
                    memo: ::core::clone::Clone::clone(&(*__self_0_0)),
                    running_hash: ::core::clone::Clone::clone(&(*__self_0_1)),
                    sequence_number: ::core::clone::Clone::clone(&(*__self_0_2)),
                    expiration_time: ::core::clone::Clone::clone(&(*__self_0_3)),
                    admin_key: ::core::clone::Clone::clone(&(*__self_0_4)),
                    submit_key: ::core::clone::Clone::clone(&(*__self_0_5)),
                    auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_6)),
                    auto_renew_account: ::core::clone::Clone::clone(&(*__self_0_7)),
                    ledger_id: ::core::clone::Clone::clone(&(*__self_0_8)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ConsensusTopicInfo {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ConsensusTopicInfo {
        #[inline]
        fn eq(&self, other: &ConsensusTopicInfo) -> bool {
            match *other {
                ConsensusTopicInfo {
                    memo: ref __self_1_0,
                    running_hash: ref __self_1_1,
                    sequence_number: ref __self_1_2,
                    expiration_time: ref __self_1_3,
                    admin_key: ref __self_1_4,
                    submit_key: ref __self_1_5,
                    auto_renew_period: ref __self_1_6,
                    auto_renew_account: ref __self_1_7,
                    ledger_id: ref __self_1_8,
                } => match *self {
                    ConsensusTopicInfo {
                        memo: ref __self_0_0,
                        running_hash: ref __self_0_1,
                        sequence_number: ref __self_0_2,
                        expiration_time: ref __self_0_3,
                        admin_key: ref __self_0_4,
                        submit_key: ref __self_0_5,
                        auto_renew_period: ref __self_0_6,
                        auto_renew_account: ref __self_0_7,
                        ledger_id: ref __self_0_8,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ConsensusTopicInfo) -> bool {
            match *other {
                ConsensusTopicInfo {
                    memo: ref __self_1_0,
                    running_hash: ref __self_1_1,
                    sequence_number: ref __self_1_2,
                    expiration_time: ref __self_1_3,
                    admin_key: ref __self_1_4,
                    submit_key: ref __self_1_5,
                    auto_renew_period: ref __self_1_6,
                    auto_renew_account: ref __self_1_7,
                    ledger_id: ref __self_1_8,
                } => match *self {
                    ConsensusTopicInfo {
                        memo: ref __self_0_0,
                        running_hash: ref __self_0_1,
                        sequence_number: ref __self_0_2,
                        expiration_time: ref __self_0_3,
                        admin_key: ref __self_0_4,
                        submit_key: ref __self_0_5,
                        auto_renew_period: ref __self_0_6,
                        auto_renew_account: ref __self_0_7,
                        ledger_id: ref __self_0_8,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ConsensusTopicInfo {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.memo != "" {
                ::prost::encoding::string::encode(1u32, &self.memo, buf);
            }
            if self.running_hash != b"" as &[u8] {
                ::prost::encoding::bytes::encode(2u32, &self.running_hash, buf);
            }
            if self.sequence_number != 0u64 {
                ::prost::encoding::uint64::encode(3u32, &self.sequence_number, buf);
            }
            if let Some(ref msg) = self.expiration_time {
                ::prost::encoding::message::encode(4u32, msg, buf);
            }
            if let Some(ref msg) = self.admin_key {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
            if let Some(ref msg) = self.submit_key {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_period {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_account {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
            if self.ledger_id != b"" as &[u8] {
                ::prost::encoding::bytes::encode(9u32, &self.ledger_id, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ConsensusTopicInfo";
            match tag {
                1u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.running_hash;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "running_hash");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.sequence_number;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "sequence_number");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.expiration_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiration_time");
                        error
                    })
                }
                5u32 => {
                    let mut value = &mut self.admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "admin_key");
                        error
                    })
                }
                6u32 => {
                    let mut value = &mut self.submit_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "submit_key");
                        error
                    })
                }
                7u32 => {
                    let mut value = &mut self.auto_renew_period;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_period");
                        error
                    })
                }
                8u32 => {
                    let mut value = &mut self.auto_renew_account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_account");
                        error
                    })
                }
                9u32 => {
                    let mut value = &mut self.ledger_id;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "ledger_id");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.memo != "" {
                ::prost::encoding::string::encoded_len(1u32, &self.memo)
            } else {
                0
            } + if self.running_hash != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(2u32, &self.running_hash)
            } else {
                0
            } + if self.sequence_number != 0u64 {
                ::prost::encoding::uint64::encoded_len(3u32, &self.sequence_number)
            } else {
                0
            } + self
                .expiration_time
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                + self
                    .admin_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
                + self
                    .submit_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                + self
                    .auto_renew_period
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                + self
                    .auto_renew_account
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(8u32, msg))
                + if self.ledger_id != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(9u32, &self.ledger_id)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.memo.clear();
            self.running_hash.clear();
            self.sequence_number = 0u64;
            self.expiration_time = ::core::option::Option::None;
            self.admin_key = ::core::option::Option::None;
            self.submit_key = ::core::option::Option::None;
            self.auto_renew_period = ::core::option::Option::None;
            self.auto_renew_account = ::core::option::Option::None;
            self.ledger_id.clear();
        }
    }
    impl ::core::default::Default for ConsensusTopicInfo {
        fn default() -> Self {
            ConsensusTopicInfo {
                memo: ::prost::alloc::string::String::new(),
                running_hash: ::core::default::Default::default(),
                sequence_number: 0u64,
                expiration_time: ::core::default::Default::default(),
                admin_key: ::core::default::Default::default(),
                submit_key: ::core::default::Default::default(),
                auto_renew_period: ::core::default::Default::default(),
                auto_renew_account: ::core::default::Default::default(),
                ledger_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ConsensusTopicInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ConsensusTopicInfo");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.running_hash)
                };
                builder.field("running_hash", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.sequence_number)
                };
                builder.field("sequence_number", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiration_time;
                builder.field("expiration_time", &wrapper)
            };
            let builder = {
                let wrapper = &self.admin_key;
                builder.field("admin_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.submit_key;
                builder.field("submit_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_period;
                builder.field("auto_renew_period", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_account;
                builder.field("auto_renew_account", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.ledger_id)
                };
                builder.field("ledger_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// See \[ConsensusService.getTopicInfo()\](#proto.ConsensusService)
    pub struct ConsensusGetTopicInfoQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of response is requested
        /// (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The Topic for which information is being requested
        #[prost(message, optional, tag = "2")]
        pub topic_id: ::core::option::Option<TopicId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ConsensusGetTopicInfoQuery {
        #[inline]
        fn clone(&self) -> ConsensusGetTopicInfoQuery {
            match *self {
                ConsensusGetTopicInfoQuery {
                    header: ref __self_0_0,
                    topic_id: ref __self_0_1,
                } => ConsensusGetTopicInfoQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    topic_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ConsensusGetTopicInfoQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ConsensusGetTopicInfoQuery {
        #[inline]
        fn eq(&self, other: &ConsensusGetTopicInfoQuery) -> bool {
            match *other {
                ConsensusGetTopicInfoQuery {
                    header: ref __self_1_0,
                    topic_id: ref __self_1_1,
                } => match *self {
                    ConsensusGetTopicInfoQuery {
                        header: ref __self_0_0,
                        topic_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ConsensusGetTopicInfoQuery) -> bool {
            match *other {
                ConsensusGetTopicInfoQuery {
                    header: ref __self_1_0,
                    topic_id: ref __self_1_1,
                } => match *self {
                    ConsensusGetTopicInfoQuery {
                        header: ref __self_0_0,
                        topic_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ConsensusGetTopicInfoQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.topic_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ConsensusGetTopicInfoQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.topic_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "topic_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .topic_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.topic_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ConsensusGetTopicInfoQuery {
        fn default() -> Self {
            ConsensusGetTopicInfoQuery {
                header: ::core::default::Default::default(),
                topic_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ConsensusGetTopicInfoQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ConsensusGetTopicInfoQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.topic_id;
                builder.field("topic_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Retrieve the parameters of and state of a consensus topic.
    pub struct ConsensusGetTopicInfoResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof, or both, or neither.
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// Topic identifier.
        #[prost(message, optional, tag = "2")]
        pub topic_id: ::core::option::Option<TopicId>,
        /// Current state of the topic
        #[prost(message, optional, tag = "5")]
        pub topic_info: ::core::option::Option<ConsensusTopicInfo>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ConsensusGetTopicInfoResponse {
        #[inline]
        fn clone(&self) -> ConsensusGetTopicInfoResponse {
            match *self {
                ConsensusGetTopicInfoResponse {
                    header: ref __self_0_0,
                    topic_id: ref __self_0_1,
                    topic_info: ref __self_0_2,
                } => ConsensusGetTopicInfoResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    topic_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    topic_info: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ConsensusGetTopicInfoResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ConsensusGetTopicInfoResponse {
        #[inline]
        fn eq(&self, other: &ConsensusGetTopicInfoResponse) -> bool {
            match *other {
                ConsensusGetTopicInfoResponse {
                    header: ref __self_1_0,
                    topic_id: ref __self_1_1,
                    topic_info: ref __self_1_2,
                } => match *self {
                    ConsensusGetTopicInfoResponse {
                        header: ref __self_0_0,
                        topic_id: ref __self_0_1,
                        topic_info: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ConsensusGetTopicInfoResponse) -> bool {
            match *other {
                ConsensusGetTopicInfoResponse {
                    header: ref __self_1_0,
                    topic_id: ref __self_1_1,
                    topic_info: ref __self_1_2,
                } => match *self {
                    ConsensusGetTopicInfoResponse {
                        header: ref __self_0_0,
                        topic_id: ref __self_0_1,
                        topic_info: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ConsensusGetTopicInfoResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.topic_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.topic_info {
                ::prost::encoding::message::encode(5u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ConsensusGetTopicInfoResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.topic_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "topic_id");
                        error
                    })
                }
                5u32 => {
                    let mut value = &mut self.topic_info;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "topic_info");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .topic_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .topic_info
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(5u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.topic_id = ::core::option::Option::None;
            self.topic_info = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for ConsensusGetTopicInfoResponse {
        fn default() -> Self {
            ConsensusGetTopicInfoResponse {
                header: ::core::default::Default::default(),
                topic_id: ::core::default::Default::default(),
                topic_info: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ConsensusGetTopicInfoResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ConsensusGetTopicInfoResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.topic_id;
                builder.field("topic_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.topic_info;
                builder.field("topic_info", &wrapper)
            };
            builder.finish()
        }
    }
    /// Get the deployed versions of Hedera Services and the HAPI proto in semantic version format
    pub struct NetworkGetVersionInfoQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NetworkGetVersionInfoQuery {
        #[inline]
        fn clone(&self) -> NetworkGetVersionInfoQuery {
            match *self {
                NetworkGetVersionInfoQuery {
                    header: ref __self_0_0,
                } => NetworkGetVersionInfoQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for NetworkGetVersionInfoQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for NetworkGetVersionInfoQuery {
        #[inline]
        fn eq(&self, other: &NetworkGetVersionInfoQuery) -> bool {
            match *other {
                NetworkGetVersionInfoQuery {
                    header: ref __self_1_0,
                } => match *self {
                    NetworkGetVersionInfoQuery {
                        header: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NetworkGetVersionInfoQuery) -> bool {
            match *other {
                NetworkGetVersionInfoQuery {
                    header: ref __self_1_0,
                } => match *self {
                    NetworkGetVersionInfoQuery {
                        header: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for NetworkGetVersionInfoQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "NetworkGetVersionInfoQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for NetworkGetVersionInfoQuery {
        fn default() -> Self {
            NetworkGetVersionInfoQuery {
                header: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for NetworkGetVersionInfoQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NetworkGetVersionInfoQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node NetworkGetVersionInfoQuery
    pub struct NetworkGetVersionInfoResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The Hedera API (HAPI) protobuf version recognized by the responding node.
        #[prost(message, optional, tag = "2")]
        pub hapi_proto_version: ::core::option::Option<SemanticVersion>,
        /// The version of the Hedera Services software deployed on the responding node.
        #[prost(message, optional, tag = "3")]
        pub hedera_services_version: ::core::option::Option<SemanticVersion>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NetworkGetVersionInfoResponse {
        #[inline]
        fn clone(&self) -> NetworkGetVersionInfoResponse {
            match *self {
                NetworkGetVersionInfoResponse {
                    header: ref __self_0_0,
                    hapi_proto_version: ref __self_0_1,
                    hedera_services_version: ref __self_0_2,
                } => NetworkGetVersionInfoResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    hapi_proto_version: ::core::clone::Clone::clone(&(*__self_0_1)),
                    hedera_services_version: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for NetworkGetVersionInfoResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for NetworkGetVersionInfoResponse {
        #[inline]
        fn eq(&self, other: &NetworkGetVersionInfoResponse) -> bool {
            match *other {
                NetworkGetVersionInfoResponse {
                    header: ref __self_1_0,
                    hapi_proto_version: ref __self_1_1,
                    hedera_services_version: ref __self_1_2,
                } => match *self {
                    NetworkGetVersionInfoResponse {
                        header: ref __self_0_0,
                        hapi_proto_version: ref __self_0_1,
                        hedera_services_version: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NetworkGetVersionInfoResponse) -> bool {
            match *other {
                NetworkGetVersionInfoResponse {
                    header: ref __self_1_0,
                    hapi_proto_version: ref __self_1_1,
                    hedera_services_version: ref __self_1_2,
                } => match *self {
                    NetworkGetVersionInfoResponse {
                        header: ref __self_0_0,
                        hapi_proto_version: ref __self_0_1,
                        hedera_services_version: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for NetworkGetVersionInfoResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.hapi_proto_version {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.hedera_services_version {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "NetworkGetVersionInfoResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.hapi_proto_version;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "hapi_proto_version");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.hedera_services_version;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "hedera_services_version");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .hapi_proto_version
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .hedera_services_version
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.hapi_proto_version = ::core::option::Option::None;
            self.hedera_services_version = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for NetworkGetVersionInfoResponse {
        fn default() -> Self {
            NetworkGetVersionInfoResponse {
                header: ::core::default::Default::default(),
                hapi_proto_version: ::core::default::Default::default(),
                hedera_services_version: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for NetworkGetVersionInfoResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NetworkGetVersionInfoResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.hapi_proto_version;
                builder.field("hapi_proto_version", &wrapper)
            };
            let builder = {
                let wrapper = &self.hedera_services_version;
                builder.field("hedera_services_version", &wrapper)
            };
            builder.finish()
        }
    }
    /// Gets the time in nanoseconds spent in <tt>handleTransaction</tt> for one or more
    /// TransactionIDs (assuming they have reached consensus "recently", since only a limited
    /// number of execution times are kept in-memory, depending on the value of the node-local
    /// property <tt>stats.executionTimesToTrack</tt>).
    pub struct NetworkGetExecutionTimeQuery {
        /// standard info sent from client to node including the signed payment, and what kind of response
        /// is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The id(s) of the transactions to get the execution time(s) of
        #[prost(message, repeated, tag = "2")]
        pub transaction_ids: ::prost::alloc::vec::Vec<TransactionId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NetworkGetExecutionTimeQuery {
        #[inline]
        fn clone(&self) -> NetworkGetExecutionTimeQuery {
            match *self {
                NetworkGetExecutionTimeQuery {
                    header: ref __self_0_0,
                    transaction_ids: ref __self_0_1,
                } => NetworkGetExecutionTimeQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    transaction_ids: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for NetworkGetExecutionTimeQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for NetworkGetExecutionTimeQuery {
        #[inline]
        fn eq(&self, other: &NetworkGetExecutionTimeQuery) -> bool {
            match *other {
                NetworkGetExecutionTimeQuery {
                    header: ref __self_1_0,
                    transaction_ids: ref __self_1_1,
                } => match *self {
                    NetworkGetExecutionTimeQuery {
                        header: ref __self_0_0,
                        transaction_ids: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NetworkGetExecutionTimeQuery) -> bool {
            match *other {
                NetworkGetExecutionTimeQuery {
                    header: ref __self_1_0,
                    transaction_ids: ref __self_1_1,
                } => match *self {
                    NetworkGetExecutionTimeQuery {
                        header: ref __self_0_0,
                        transaction_ids: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for NetworkGetExecutionTimeQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.transaction_ids {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "NetworkGetExecutionTimeQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.transaction_ids;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "transaction_ids");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.transaction_ids)
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.transaction_ids.clear();
        }
    }
    impl ::core::default::Default for NetworkGetExecutionTimeQuery {
        fn default() -> Self {
            NetworkGetExecutionTimeQuery {
                header: ::core::default::Default::default(),
                transaction_ids: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for NetworkGetExecutionTimeQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NetworkGetExecutionTimeQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.transaction_ids;
                builder.field("transaction_ids", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node NetworkGetExecutionTimeQuery; returns
    /// INVALID_TRANSACTION_ID if any of the given TransactionIDs do not have available
    /// execution times in the answering node.
    pub struct NetworkGetExecutionTimeResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The execution time(s) of the requested TransactionIDs, if available
        #[prost(uint64, repeated, tag = "2")]
        pub execution_times: ::prost::alloc::vec::Vec<u64>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NetworkGetExecutionTimeResponse {
        #[inline]
        fn clone(&self) -> NetworkGetExecutionTimeResponse {
            match *self {
                NetworkGetExecutionTimeResponse {
                    header: ref __self_0_0,
                    execution_times: ref __self_0_1,
                } => NetworkGetExecutionTimeResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    execution_times: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for NetworkGetExecutionTimeResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for NetworkGetExecutionTimeResponse {
        #[inline]
        fn eq(&self, other: &NetworkGetExecutionTimeResponse) -> bool {
            match *other {
                NetworkGetExecutionTimeResponse {
                    header: ref __self_1_0,
                    execution_times: ref __self_1_1,
                } => match *self {
                    NetworkGetExecutionTimeResponse {
                        header: ref __self_0_0,
                        execution_times: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NetworkGetExecutionTimeResponse) -> bool {
            match *other {
                NetworkGetExecutionTimeResponse {
                    header: ref __self_1_0,
                    execution_times: ref __self_1_1,
                } => match *self {
                    NetworkGetExecutionTimeResponse {
                        header: ref __self_0_0,
                        execution_times: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for NetworkGetExecutionTimeResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            ::prost::encoding::uint64::encode_packed(2u32, &self.execution_times, buf);
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "NetworkGetExecutionTimeResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.execution_times;
                    ::prost::encoding::uint64::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "execution_times");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::uint64::encoded_len_packed(2u32, &self.execution_times)
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.execution_times.clear();
        }
    }
    impl ::core::default::Default for NetworkGetExecutionTimeResponse {
        fn default() -> Self {
            NetworkGetExecutionTimeResponse {
                header: ::core::default::Default::default(),
                execution_times: ::prost::alloc::vec::Vec::new(),
            }
        }
    }
    impl ::core::fmt::Debug for NetworkGetExecutionTimeResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NetworkGetExecutionTimeResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<u64>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                fn Inner<T>(v: T) -> T {
                                    v
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.execution_times)
                };
                builder.field("execution_times", &wrapper)
            };
            builder.finish()
        }
    }
    /// Gets information about Token instance
    pub struct TokenGetInfoQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither)
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The token for which information is requested. If invalid token is provided, INVALID_TOKEN_ID
        /// response is returned.
        #[prost(message, optional, tag = "2")]
        pub token: ::core::option::Option<TokenId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenGetInfoQuery {
        #[inline]
        fn clone(&self) -> TokenGetInfoQuery {
            match *self {
                TokenGetInfoQuery {
                    header: ref __self_0_0,
                    token: ref __self_0_1,
                } => TokenGetInfoQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    token: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenGetInfoQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenGetInfoQuery {
        #[inline]
        fn eq(&self, other: &TokenGetInfoQuery) -> bool {
            match *other {
                TokenGetInfoQuery {
                    header: ref __self_1_0,
                    token: ref __self_1_1,
                } => match *self {
                    TokenGetInfoQuery {
                        header: ref __self_0_0,
                        token: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenGetInfoQuery) -> bool {
            match *other {
                TokenGetInfoQuery {
                    header: ref __self_1_0,
                    token: ref __self_1_1,
                } => match *self {
                    TokenGetInfoQuery {
                        header: ref __self_0_0,
                        token: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenGetInfoQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.token {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenGetInfoQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.token;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .token
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.token = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenGetInfoQuery {
        fn default() -> Self {
            TokenGetInfoQuery {
                header: ::core::default::Default::default(),
                token: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenGetInfoQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenGetInfoQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.token;
                builder.field("token", &wrapper)
            };
            builder.finish()
        }
    }
    /// The metadata about a Token instance
    pub struct TokenInfo {
        /// ID of the token instance
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<TokenId>,
        /// The name of the token. It is a string of ASCII only characters
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        /// The symbol of the token. It is a UTF-8 capitalized alphabetical string
        #[prost(string, tag = "3")]
        pub symbol: ::prost::alloc::string::String,
        /// The number of decimal places a token is divisible by. Always 0 for tokens of type
        /// NON_FUNGIBLE_UNIQUE
        #[prost(uint32, tag = "4")]
        pub decimals: u32,
        /// For tokens of type FUNGIBLE_COMMON - the total supply of tokens that are currently in
        /// circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the number of NFTs created of this
        /// token instance
        #[prost(uint64, tag = "5")]
        pub total_supply: u64,
        /// The ID of the account which is set as Treasury
        #[prost(message, optional, tag = "6")]
        pub treasury: ::core::option::Option<AccountId>,
        /// The key which can perform update/delete operations on the token. If empty, the token can be
        /// perceived as immutable (not being able to be updated/deleted)
        #[prost(message, optional, tag = "7")]
        pub admin_key: ::core::option::Option<Key>,
        /// The key which can grant or revoke KYC of an account for the token's transactions. If empty,
        /// KYC is not required, and KYC grant or revoke operations are not possible.
        #[prost(message, optional, tag = "8")]
        pub kyc_key: ::core::option::Option<Key>,
        /// The key which can freeze or unfreeze an account for token transactions. If empty, freezing is
        /// not possible
        #[prost(message, optional, tag = "9")]
        pub freeze_key: ::core::option::Option<Key>,
        /// The key which can wipe token balance of an account. If empty, wipe is not possible
        #[prost(message, optional, tag = "10")]
        pub wipe_key: ::core::option::Option<Key>,
        /// The key which can change the supply of a token. The key is used to sign Token Mint/Burn
        /// operations
        #[prost(message, optional, tag = "11")]
        pub supply_key: ::core::option::Option<Key>,
        /// The default Freeze status (not applicable, frozen or unfrozen) of Hedera accounts relative to
        /// this token. FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned
        /// if Token Freeze Key is set and defaultFreeze is set to true. Unfrozen is returned if Token
        /// Freeze Key is set and defaultFreeze is set to false
        #[prost(enumeration = "TokenFreezeStatus", tag = "12")]
        pub default_freeze_status: i32,
        /// The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this
        /// token. KycNotApplicable is returned if KYC key is not set, otherwise Revoked
        #[prost(enumeration = "TokenKycStatus", tag = "13")]
        pub default_kyc_status: i32,
        /// Specifies whether the token was deleted or not
        #[prost(bool, tag = "14")]
        pub deleted: bool,
        /// An account which will be automatically charged to renew the token's expiration, at
        /// autoRenewPeriod interval
        #[prost(message, optional, tag = "15")]
        pub auto_renew_account: ::core::option::Option<AccountId>,
        /// The interval at which the auto-renew account will be charged to extend the token's expiry
        #[prost(message, optional, tag = "16")]
        pub auto_renew_period: ::core::option::Option<Duration>,
        /// The epoch second at which the token will expire
        #[prost(message, optional, tag = "17")]
        pub expiry: ::core::option::Option<Timestamp>,
        /// The memo associated with the token
        #[prost(string, tag = "18")]
        pub memo: ::prost::alloc::string::String,
        /// The token type
        #[prost(enumeration = "TokenType", tag = "19")]
        pub token_type: i32,
        /// The token supply type
        #[prost(enumeration = "TokenSupplyType", tag = "20")]
        pub supply_type: i32,
        /// For tokens of type FUNGIBLE_COMMON - The Maximum number of fungible tokens that can be in
        /// circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial
        /// numbers) that can be in circulation
        #[prost(int64, tag = "21")]
        pub max_supply: i64,
        /// The key which can change the custom fee schedule of the token; if not set, the fee schedule
        /// is immutable
        #[prost(message, optional, tag = "22")]
        pub fee_schedule_key: ::core::option::Option<Key>,
        /// The custom fees to be assessed during a CryptoTransfer that transfers units of this token
        #[prost(message, repeated, tag = "23")]
        pub custom_fees: ::prost::alloc::vec::Vec<CustomFee>,
        /// The Key which can pause and unpause the Token.
        #[prost(message, optional, tag = "24")]
        pub pause_key: ::core::option::Option<Key>,
        /// Specifies whether the token is paused or not. PauseNotApplicable is returned if pauseKey is not set.
        #[prost(enumeration = "TokenPauseStatus", tag = "25")]
        pub pause_status: i32,
        /// The ledger ID the response was returned from; please see <a href="<https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a>> for the network-specific IDs.
        #[prost(bytes = "vec", tag = "26")]
        pub ledger_id: ::prost::alloc::vec::Vec<u8>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenInfo {
        #[inline]
        fn clone(&self) -> TokenInfo {
            match *self {
                TokenInfo {
                    token_id: ref __self_0_0,
                    name: ref __self_0_1,
                    symbol: ref __self_0_2,
                    decimals: ref __self_0_3,
                    total_supply: ref __self_0_4,
                    treasury: ref __self_0_5,
                    admin_key: ref __self_0_6,
                    kyc_key: ref __self_0_7,
                    freeze_key: ref __self_0_8,
                    wipe_key: ref __self_0_9,
                    supply_key: ref __self_0_10,
                    default_freeze_status: ref __self_0_11,
                    default_kyc_status: ref __self_0_12,
                    deleted: ref __self_0_13,
                    auto_renew_account: ref __self_0_14,
                    auto_renew_period: ref __self_0_15,
                    expiry: ref __self_0_16,
                    memo: ref __self_0_17,
                    token_type: ref __self_0_18,
                    supply_type: ref __self_0_19,
                    max_supply: ref __self_0_20,
                    fee_schedule_key: ref __self_0_21,
                    custom_fees: ref __self_0_22,
                    pause_key: ref __self_0_23,
                    pause_status: ref __self_0_24,
                    ledger_id: ref __self_0_25,
                } => TokenInfo {
                    token_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    name: ::core::clone::Clone::clone(&(*__self_0_1)),
                    symbol: ::core::clone::Clone::clone(&(*__self_0_2)),
                    decimals: ::core::clone::Clone::clone(&(*__self_0_3)),
                    total_supply: ::core::clone::Clone::clone(&(*__self_0_4)),
                    treasury: ::core::clone::Clone::clone(&(*__self_0_5)),
                    admin_key: ::core::clone::Clone::clone(&(*__self_0_6)),
                    kyc_key: ::core::clone::Clone::clone(&(*__self_0_7)),
                    freeze_key: ::core::clone::Clone::clone(&(*__self_0_8)),
                    wipe_key: ::core::clone::Clone::clone(&(*__self_0_9)),
                    supply_key: ::core::clone::Clone::clone(&(*__self_0_10)),
                    default_freeze_status: ::core::clone::Clone::clone(&(*__self_0_11)),
                    default_kyc_status: ::core::clone::Clone::clone(&(*__self_0_12)),
                    deleted: ::core::clone::Clone::clone(&(*__self_0_13)),
                    auto_renew_account: ::core::clone::Clone::clone(&(*__self_0_14)),
                    auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_15)),
                    expiry: ::core::clone::Clone::clone(&(*__self_0_16)),
                    memo: ::core::clone::Clone::clone(&(*__self_0_17)),
                    token_type: ::core::clone::Clone::clone(&(*__self_0_18)),
                    supply_type: ::core::clone::Clone::clone(&(*__self_0_19)),
                    max_supply: ::core::clone::Clone::clone(&(*__self_0_20)),
                    fee_schedule_key: ::core::clone::Clone::clone(&(*__self_0_21)),
                    custom_fees: ::core::clone::Clone::clone(&(*__self_0_22)),
                    pause_key: ::core::clone::Clone::clone(&(*__self_0_23)),
                    pause_status: ::core::clone::Clone::clone(&(*__self_0_24)),
                    ledger_id: ::core::clone::Clone::clone(&(*__self_0_25)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenInfo {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenInfo {
        #[inline]
        fn eq(&self, other: &TokenInfo) -> bool {
            match *other {
                TokenInfo {
                    token_id: ref __self_1_0,
                    name: ref __self_1_1,
                    symbol: ref __self_1_2,
                    decimals: ref __self_1_3,
                    total_supply: ref __self_1_4,
                    treasury: ref __self_1_5,
                    admin_key: ref __self_1_6,
                    kyc_key: ref __self_1_7,
                    freeze_key: ref __self_1_8,
                    wipe_key: ref __self_1_9,
                    supply_key: ref __self_1_10,
                    default_freeze_status: ref __self_1_11,
                    default_kyc_status: ref __self_1_12,
                    deleted: ref __self_1_13,
                    auto_renew_account: ref __self_1_14,
                    auto_renew_period: ref __self_1_15,
                    expiry: ref __self_1_16,
                    memo: ref __self_1_17,
                    token_type: ref __self_1_18,
                    supply_type: ref __self_1_19,
                    max_supply: ref __self_1_20,
                    fee_schedule_key: ref __self_1_21,
                    custom_fees: ref __self_1_22,
                    pause_key: ref __self_1_23,
                    pause_status: ref __self_1_24,
                    ledger_id: ref __self_1_25,
                } => match *self {
                    TokenInfo {
                        token_id: ref __self_0_0,
                        name: ref __self_0_1,
                        symbol: ref __self_0_2,
                        decimals: ref __self_0_3,
                        total_supply: ref __self_0_4,
                        treasury: ref __self_0_5,
                        admin_key: ref __self_0_6,
                        kyc_key: ref __self_0_7,
                        freeze_key: ref __self_0_8,
                        wipe_key: ref __self_0_9,
                        supply_key: ref __self_0_10,
                        default_freeze_status: ref __self_0_11,
                        default_kyc_status: ref __self_0_12,
                        deleted: ref __self_0_13,
                        auto_renew_account: ref __self_0_14,
                        auto_renew_period: ref __self_0_15,
                        expiry: ref __self_0_16,
                        memo: ref __self_0_17,
                        token_type: ref __self_0_18,
                        supply_type: ref __self_0_19,
                        max_supply: ref __self_0_20,
                        fee_schedule_key: ref __self_0_21,
                        custom_fees: ref __self_0_22,
                        pause_key: ref __self_0_23,
                        pause_status: ref __self_0_24,
                        ledger_id: ref __self_0_25,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                            && (*__self_0_11) == (*__self_1_11)
                            && (*__self_0_12) == (*__self_1_12)
                            && (*__self_0_13) == (*__self_1_13)
                            && (*__self_0_14) == (*__self_1_14)
                            && (*__self_0_15) == (*__self_1_15)
                            && (*__self_0_16) == (*__self_1_16)
                            && (*__self_0_17) == (*__self_1_17)
                            && (*__self_0_18) == (*__self_1_18)
                            && (*__self_0_19) == (*__self_1_19)
                            && (*__self_0_20) == (*__self_1_20)
                            && (*__self_0_21) == (*__self_1_21)
                            && (*__self_0_22) == (*__self_1_22)
                            && (*__self_0_23) == (*__self_1_23)
                            && (*__self_0_24) == (*__self_1_24)
                            && (*__self_0_25) == (*__self_1_25)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenInfo) -> bool {
            match *other {
                TokenInfo {
                    token_id: ref __self_1_0,
                    name: ref __self_1_1,
                    symbol: ref __self_1_2,
                    decimals: ref __self_1_3,
                    total_supply: ref __self_1_4,
                    treasury: ref __self_1_5,
                    admin_key: ref __self_1_6,
                    kyc_key: ref __self_1_7,
                    freeze_key: ref __self_1_8,
                    wipe_key: ref __self_1_9,
                    supply_key: ref __self_1_10,
                    default_freeze_status: ref __self_1_11,
                    default_kyc_status: ref __self_1_12,
                    deleted: ref __self_1_13,
                    auto_renew_account: ref __self_1_14,
                    auto_renew_period: ref __self_1_15,
                    expiry: ref __self_1_16,
                    memo: ref __self_1_17,
                    token_type: ref __self_1_18,
                    supply_type: ref __self_1_19,
                    max_supply: ref __self_1_20,
                    fee_schedule_key: ref __self_1_21,
                    custom_fees: ref __self_1_22,
                    pause_key: ref __self_1_23,
                    pause_status: ref __self_1_24,
                    ledger_id: ref __self_1_25,
                } => match *self {
                    TokenInfo {
                        token_id: ref __self_0_0,
                        name: ref __self_0_1,
                        symbol: ref __self_0_2,
                        decimals: ref __self_0_3,
                        total_supply: ref __self_0_4,
                        treasury: ref __self_0_5,
                        admin_key: ref __self_0_6,
                        kyc_key: ref __self_0_7,
                        freeze_key: ref __self_0_8,
                        wipe_key: ref __self_0_9,
                        supply_key: ref __self_0_10,
                        default_freeze_status: ref __self_0_11,
                        default_kyc_status: ref __self_0_12,
                        deleted: ref __self_0_13,
                        auto_renew_account: ref __self_0_14,
                        auto_renew_period: ref __self_0_15,
                        expiry: ref __self_0_16,
                        memo: ref __self_0_17,
                        token_type: ref __self_0_18,
                        supply_type: ref __self_0_19,
                        max_supply: ref __self_0_20,
                        fee_schedule_key: ref __self_0_21,
                        custom_fees: ref __self_0_22,
                        pause_key: ref __self_0_23,
                        pause_status: ref __self_0_24,
                        ledger_id: ref __self_0_25,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                            || (*__self_0_11) != (*__self_1_11)
                            || (*__self_0_12) != (*__self_1_12)
                            || (*__self_0_13) != (*__self_1_13)
                            || (*__self_0_14) != (*__self_1_14)
                            || (*__self_0_15) != (*__self_1_15)
                            || (*__self_0_16) != (*__self_1_16)
                            || (*__self_0_17) != (*__self_1_17)
                            || (*__self_0_18) != (*__self_1_18)
                            || (*__self_0_19) != (*__self_1_19)
                            || (*__self_0_20) != (*__self_1_20)
                            || (*__self_0_21) != (*__self_1_21)
                            || (*__self_0_22) != (*__self_1_22)
                            || (*__self_0_23) != (*__self_1_23)
                            || (*__self_0_24) != (*__self_1_24)
                            || (*__self_0_25) != (*__self_1_25)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenInfo {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.name != "" {
                ::prost::encoding::string::encode(2u32, &self.name, buf);
            }
            if self.symbol != "" {
                ::prost::encoding::string::encode(3u32, &self.symbol, buf);
            }
            if self.decimals != 0u32 {
                ::prost::encoding::uint32::encode(4u32, &self.decimals, buf);
            }
            if self.total_supply != 0u64 {
                ::prost::encoding::uint64::encode(5u32, &self.total_supply, buf);
            }
            if let Some(ref msg) = self.treasury {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
            if let Some(ref msg) = self.admin_key {
                ::prost::encoding::message::encode(7u32, msg, buf);
            }
            if let Some(ref msg) = self.kyc_key {
                ::prost::encoding::message::encode(8u32, msg, buf);
            }
            if let Some(ref msg) = self.freeze_key {
                ::prost::encoding::message::encode(9u32, msg, buf);
            }
            if let Some(ref msg) = self.wipe_key {
                ::prost::encoding::message::encode(10u32, msg, buf);
            }
            if let Some(ref msg) = self.supply_key {
                ::prost::encoding::message::encode(11u32, msg, buf);
            }
            if self.default_freeze_status != TokenFreezeStatus::default() as i32 {
                ::prost::encoding::int32::encode(12u32, &self.default_freeze_status, buf);
            }
            if self.default_kyc_status != TokenKycStatus::default() as i32 {
                ::prost::encoding::int32::encode(13u32, &self.default_kyc_status, buf);
            }
            if self.deleted != false {
                ::prost::encoding::bool::encode(14u32, &self.deleted, buf);
            }
            if let Some(ref msg) = self.auto_renew_account {
                ::prost::encoding::message::encode(15u32, msg, buf);
            }
            if let Some(ref msg) = self.auto_renew_period {
                ::prost::encoding::message::encode(16u32, msg, buf);
            }
            if let Some(ref msg) = self.expiry {
                ::prost::encoding::message::encode(17u32, msg, buf);
            }
            if self.memo != "" {
                ::prost::encoding::string::encode(18u32, &self.memo, buf);
            }
            if self.token_type != TokenType::default() as i32 {
                ::prost::encoding::int32::encode(19u32, &self.token_type, buf);
            }
            if self.supply_type != TokenSupplyType::default() as i32 {
                ::prost::encoding::int32::encode(20u32, &self.supply_type, buf);
            }
            if self.max_supply != 0i64 {
                ::prost::encoding::int64::encode(21u32, &self.max_supply, buf);
            }
            if let Some(ref msg) = self.fee_schedule_key {
                ::prost::encoding::message::encode(22u32, msg, buf);
            }
            for msg in &self.custom_fees {
                ::prost::encoding::message::encode(23u32, msg, buf);
            }
            if let Some(ref msg) = self.pause_key {
                ::prost::encoding::message::encode(24u32, msg, buf);
            }
            if self.pause_status != TokenPauseStatus::default() as i32 {
                ::prost::encoding::int32::encode(25u32, &self.pause_status, buf);
            }
            if self.ledger_id != b"" as &[u8] {
                ::prost::encoding::bytes::encode(26u32, &self.ledger_id, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenInfo";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.name;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "name");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.symbol;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "symbol");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.decimals;
                    ::prost::encoding::uint32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "decimals");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.total_supply;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "total_supply");
                            error
                        },
                    )
                }
                6u32 => {
                    let mut value = &mut self.treasury;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "treasury");
                        error
                    })
                }
                7u32 => {
                    let mut value = &mut self.admin_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "admin_key");
                        error
                    })
                }
                8u32 => {
                    let mut value = &mut self.kyc_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "kyc_key");
                        error
                    })
                }
                9u32 => {
                    let mut value = &mut self.freeze_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "freeze_key");
                        error
                    })
                }
                10u32 => {
                    let mut value = &mut self.wipe_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "wipe_key");
                        error
                    })
                }
                11u32 => {
                    let mut value = &mut self.supply_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "supply_key");
                        error
                    })
                }
                12u32 => {
                    let mut value = &mut self.default_freeze_status;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "default_freeze_status");
                            error
                        },
                    )
                }
                13u32 => {
                    let mut value = &mut self.default_kyc_status;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "default_kyc_status");
                            error
                        },
                    )
                }
                14u32 => {
                    let mut value = &mut self.deleted;
                    ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "deleted");
                            error
                        },
                    )
                }
                15u32 => {
                    let mut value = &mut self.auto_renew_account;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_account");
                        error
                    })
                }
                16u32 => {
                    let mut value = &mut self.auto_renew_period;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "auto_renew_period");
                        error
                    })
                }
                17u32 => {
                    let mut value = &mut self.expiry;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "expiry");
                        error
                    })
                }
                18u32 => {
                    let mut value = &mut self.memo;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "memo");
                            error
                        },
                    )
                }
                19u32 => {
                    let mut value = &mut self.token_type;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "token_type");
                            error
                        },
                    )
                }
                20u32 => {
                    let mut value = &mut self.supply_type;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "supply_type");
                            error
                        },
                    )
                }
                21u32 => {
                    let mut value = &mut self.max_supply;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "max_supply");
                            error
                        },
                    )
                }
                22u32 => {
                    let mut value = &mut self.fee_schedule_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "fee_schedule_key");
                        error
                    })
                }
                23u32 => {
                    let mut value = &mut self.custom_fees;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "custom_fees");
                            error
                        },
                    )
                }
                24u32 => {
                    let mut value = &mut self.pause_key;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "pause_key");
                        error
                    })
                }
                25u32 => {
                    let mut value = &mut self.pause_status;
                    ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "pause_status");
                            error
                        },
                    )
                }
                26u32 => {
                    let mut value = &mut self.ledger_id;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "ledger_id");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.name != "" {
                    ::prost::encoding::string::encoded_len(2u32, &self.name)
                } else {
                    0
                }
                + if self.symbol != "" {
                    ::prost::encoding::string::encoded_len(3u32, &self.symbol)
                } else {
                    0
                }
                + if self.decimals != 0u32 {
                    ::prost::encoding::uint32::encoded_len(4u32, &self.decimals)
                } else {
                    0
                }
                + if self.total_supply != 0u64 {
                    ::prost::encoding::uint64::encoded_len(5u32, &self.total_supply)
                } else {
                    0
                }
                + self
                    .treasury
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                + self
                    .admin_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(7u32, msg))
                + self
                    .kyc_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(8u32, msg))
                + self
                    .freeze_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(9u32, msg))
                + self
                    .wipe_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(10u32, msg))
                + self
                    .supply_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(11u32, msg))
                + if self.default_freeze_status != TokenFreezeStatus::default() as i32 {
                    ::prost::encoding::int32::encoded_len(12u32, &self.default_freeze_status)
                } else {
                    0
                }
                + if self.default_kyc_status != TokenKycStatus::default() as i32 {
                    ::prost::encoding::int32::encoded_len(13u32, &self.default_kyc_status)
                } else {
                    0
                }
                + if self.deleted != false {
                    ::prost::encoding::bool::encoded_len(14u32, &self.deleted)
                } else {
                    0
                }
                + self
                    .auto_renew_account
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(15u32, msg))
                + self
                    .auto_renew_period
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(16u32, msg))
                + self
                    .expiry
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(17u32, msg))
                + if self.memo != "" {
                    ::prost::encoding::string::encoded_len(18u32, &self.memo)
                } else {
                    0
                }
                + if self.token_type != TokenType::default() as i32 {
                    ::prost::encoding::int32::encoded_len(19u32, &self.token_type)
                } else {
                    0
                }
                + if self.supply_type != TokenSupplyType::default() as i32 {
                    ::prost::encoding::int32::encoded_len(20u32, &self.supply_type)
                } else {
                    0
                }
                + if self.max_supply != 0i64 {
                    ::prost::encoding::int64::encoded_len(21u32, &self.max_supply)
                } else {
                    0
                }
                + self
                    .fee_schedule_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(22u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(23u32, &self.custom_fees)
                + self
                    .pause_key
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(24u32, msg))
                + if self.pause_status != TokenPauseStatus::default() as i32 {
                    ::prost::encoding::int32::encoded_len(25u32, &self.pause_status)
                } else {
                    0
                }
                + if self.ledger_id != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(26u32, &self.ledger_id)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.token_id = ::core::option::Option::None;
            self.name.clear();
            self.symbol.clear();
            self.decimals = 0u32;
            self.total_supply = 0u64;
            self.treasury = ::core::option::Option::None;
            self.admin_key = ::core::option::Option::None;
            self.kyc_key = ::core::option::Option::None;
            self.freeze_key = ::core::option::Option::None;
            self.wipe_key = ::core::option::Option::None;
            self.supply_key = ::core::option::Option::None;
            self.default_freeze_status = TokenFreezeStatus::default() as i32;
            self.default_kyc_status = TokenKycStatus::default() as i32;
            self.deleted = false;
            self.auto_renew_account = ::core::option::Option::None;
            self.auto_renew_period = ::core::option::Option::None;
            self.expiry = ::core::option::Option::None;
            self.memo.clear();
            self.token_type = TokenType::default() as i32;
            self.supply_type = TokenSupplyType::default() as i32;
            self.max_supply = 0i64;
            self.fee_schedule_key = ::core::option::Option::None;
            self.custom_fees.clear();
            self.pause_key = ::core::option::Option::None;
            self.pause_status = TokenPauseStatus::default() as i32;
            self.ledger_id.clear();
        }
    }
    impl ::core::default::Default for TokenInfo {
        fn default() -> Self {
            TokenInfo {
                token_id: ::core::default::Default::default(),
                name: ::prost::alloc::string::String::new(),
                symbol: ::prost::alloc::string::String::new(),
                decimals: 0u32,
                total_supply: 0u64,
                treasury: ::core::default::Default::default(),
                admin_key: ::core::default::Default::default(),
                kyc_key: ::core::default::Default::default(),
                freeze_key: ::core::default::Default::default(),
                wipe_key: ::core::default::Default::default(),
                supply_key: ::core::default::Default::default(),
                default_freeze_status: TokenFreezeStatus::default() as i32,
                default_kyc_status: TokenKycStatus::default() as i32,
                deleted: false,
                auto_renew_account: ::core::default::Default::default(),
                auto_renew_period: ::core::default::Default::default(),
                expiry: ::core::default::Default::default(),
                memo: ::prost::alloc::string::String::new(),
                token_type: TokenType::default() as i32,
                supply_type: TokenSupplyType::default() as i32,
                max_supply: 0i64,
                fee_schedule_key: ::core::default::Default::default(),
                custom_fees: ::core::default::Default::default(),
                pause_key: ::core::default::Default::default(),
                pause_status: TokenPauseStatus::default() as i32,
                ledger_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenInfo");
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.name)
                };
                builder.field("name", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.symbol)
                };
                builder.field("symbol", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.decimals)
                };
                builder.field("decimals", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.total_supply)
                };
                builder.field("total_supply", &wrapper)
            };
            let builder = {
                let wrapper = &self.treasury;
                builder.field("treasury", &wrapper)
            };
            let builder = {
                let wrapper = &self.admin_key;
                builder.field("admin_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.kyc_key;
                builder.field("kyc_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.freeze_key;
                builder.field("freeze_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.wipe_key;
                builder.field("wipe_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.supply_key;
                builder.field("supply_key", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match TokenFreezeStatus::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.default_freeze_status)
                };
                builder.field("default_freeze_status", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match TokenKycStatus::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.default_kyc_status)
                };
                builder.field("default_kyc_status", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.deleted)
                };
                builder.field("deleted", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_account;
                builder.field("auto_renew_account", &wrapper)
            };
            let builder = {
                let wrapper = &self.auto_renew_period;
                builder.field("auto_renew_period", &wrapper)
            };
            let builder = {
                let wrapper = &self.expiry;
                builder.field("expiry", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.memo)
                };
                builder.field("memo", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match TokenType::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.token_type)
                };
                builder.field("token_type", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match TokenSupplyType::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.supply_type)
                };
                builder.field("supply_type", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.max_supply)
                };
                builder.field("max_supply", &wrapper)
            };
            let builder = {
                let wrapper = &self.fee_schedule_key;
                builder.field("fee_schedule_key", &wrapper)
            };
            let builder = {
                let wrapper = &self.custom_fees;
                builder.field("custom_fees", &wrapper)
            };
            let builder = {
                let wrapper = &self.pause_key;
                builder.field("pause_key", &wrapper)
            };
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a i32);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            match TokenPauseStatus::from_i32(*self.0) {
                                None => ::core::fmt::Debug::fmt(&self.0, f),
                                Some(en) => ::core::fmt::Debug::fmt(&en, f),
                            }
                        }
                    }
                    ScalarWrapper(&self.pause_status)
                };
                builder.field("pause_status", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.ledger_id)
                };
                builder.field("ledger_id", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl TokenInfo {
        ///Returns the enum value of `default_freeze_status`, or the default if the field is set to an invalid enum value.
        pub fn default_freeze_status(&self) -> TokenFreezeStatus {
            TokenFreezeStatus::from_i32(self.default_freeze_status)
                .unwrap_or(TokenFreezeStatus::default())
        }
        ///Sets `default_freeze_status` to the provided enum value.
        pub fn set_default_freeze_status(&mut self, value: TokenFreezeStatus) {
            self.default_freeze_status = value as i32;
        }
        ///Returns the enum value of `default_kyc_status`, or the default if the field is set to an invalid enum value.
        pub fn default_kyc_status(&self) -> TokenKycStatus {
            TokenKycStatus::from_i32(self.default_kyc_status).unwrap_or(TokenKycStatus::default())
        }
        ///Sets `default_kyc_status` to the provided enum value.
        pub fn set_default_kyc_status(&mut self, value: TokenKycStatus) {
            self.default_kyc_status = value as i32;
        }
        ///Returns the enum value of `token_type`, or the default if the field is set to an invalid enum value.
        pub fn token_type(&self) -> TokenType {
            TokenType::from_i32(self.token_type).unwrap_or(TokenType::default())
        }
        ///Sets `token_type` to the provided enum value.
        pub fn set_token_type(&mut self, value: TokenType) {
            self.token_type = value as i32;
        }
        ///Returns the enum value of `supply_type`, or the default if the field is set to an invalid enum value.
        pub fn supply_type(&self) -> TokenSupplyType {
            TokenSupplyType::from_i32(self.supply_type).unwrap_or(TokenSupplyType::default())
        }
        ///Sets `supply_type` to the provided enum value.
        pub fn set_supply_type(&mut self, value: TokenSupplyType) {
            self.supply_type = value as i32;
        }
        ///Returns the enum value of `pause_status`, or the default if the field is set to an invalid enum value.
        pub fn pause_status(&self) -> TokenPauseStatus {
            TokenPauseStatus::from_i32(self.pause_status).unwrap_or(TokenPauseStatus::default())
        }
        ///Sets `pause_status` to the provided enum value.
        pub fn set_pause_status(&mut self, value: TokenPauseStatus) {
            self.pause_status = value as i32;
        }
    }
    /// Response when the client sends the node TokenGetInfoQuery
    pub struct TokenGetInfoResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The information requested about this token instance
        #[prost(message, optional, tag = "2")]
        pub token_info: ::core::option::Option<TokenInfo>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenGetInfoResponse {
        #[inline]
        fn clone(&self) -> TokenGetInfoResponse {
            match *self {
                TokenGetInfoResponse {
                    header: ref __self_0_0,
                    token_info: ref __self_0_1,
                } => TokenGetInfoResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    token_info: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenGetInfoResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenGetInfoResponse {
        #[inline]
        fn eq(&self, other: &TokenGetInfoResponse) -> bool {
            match *other {
                TokenGetInfoResponse {
                    header: ref __self_1_0,
                    token_info: ref __self_1_1,
                } => match *self {
                    TokenGetInfoResponse {
                        header: ref __self_0_0,
                        token_info: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenGetInfoResponse) -> bool {
            match *other {
                TokenGetInfoResponse {
                    header: ref __self_1_0,
                    token_info: ref __self_1_1,
                } => match *self {
                    TokenGetInfoResponse {
                        header: ref __self_0_0,
                        token_info: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenGetInfoResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.token_info {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenGetInfoResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.token_info;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_info");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .token_info
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.token_info = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenGetInfoResponse {
        fn default() -> Self {
            TokenGetInfoResponse {
                header: ::core::default::Default::default(),
                token_info: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenGetInfoResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenGetInfoResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.token_info;
                builder.field("token_info", &wrapper)
            };
            builder.finish()
        }
    }
    /// Represents an NFT on the Ledger
    pub struct NftId {
        /// The (non-fungible) token of which this NFT is an instance
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<TokenId>,
        /// The unique identifier of this instance
        #[prost(int64, tag = "2")]
        pub serial_number: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for NftId {
        #[inline]
        fn clone(&self) -> NftId {
            match *self {
                NftId {
                    token_id: ref __self_0_0,
                    serial_number: ref __self_0_1,
                } => NftId {
                    token_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    serial_number: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for NftId {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for NftId {
        #[inline]
        fn eq(&self, other: &NftId) -> bool {
            match *other {
                NftId {
                    token_id: ref __self_1_0,
                    serial_number: ref __self_1_1,
                } => match *self {
                    NftId {
                        token_id: ref __self_0_0,
                        serial_number: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NftId) -> bool {
            match *other {
                NftId {
                    token_id: ref __self_1_0,
                    serial_number: ref __self_1_1,
                } => match *self {
                    NftId {
                        token_id: ref __self_0_0,
                        serial_number: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for NftId {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.serial_number != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.serial_number, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "NftId";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.serial_number;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "serial_number");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.serial_number != 0i64 {
                    ::prost::encoding::int64::encoded_len(2u32, &self.serial_number)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.token_id = ::core::option::Option::None;
            self.serial_number = 0i64;
        }
    }
    impl ::core::default::Default for NftId {
        fn default() -> Self {
            NftId {
                token_id: ::core::default::Default::default(),
                serial_number: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for NftId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("NftId");
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.serial_number)
                };
                builder.field("serial_number", &wrapper)
            };
            builder.finish()
        }
    }
    /// Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on a NFT for a given TokenID (of
    /// type NON_FUNGIBLE_UNIQUE) and serial number
    pub struct TokenGetNftInfoQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The ID of the NFT
        #[prost(message, optional, tag = "2")]
        pub nft_id: ::core::option::Option<NftId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenGetNftInfoQuery {
        #[inline]
        fn clone(&self) -> TokenGetNftInfoQuery {
            match *self {
                TokenGetNftInfoQuery {
                    header: ref __self_0_0,
                    nft_id: ref __self_0_1,
                } => TokenGetNftInfoQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    nft_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenGetNftInfoQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenGetNftInfoQuery {
        #[inline]
        fn eq(&self, other: &TokenGetNftInfoQuery) -> bool {
            match *other {
                TokenGetNftInfoQuery {
                    header: ref __self_1_0,
                    nft_id: ref __self_1_1,
                } => match *self {
                    TokenGetNftInfoQuery {
                        header: ref __self_0_0,
                        nft_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenGetNftInfoQuery) -> bool {
            match *other {
                TokenGetNftInfoQuery {
                    header: ref __self_1_0,
                    nft_id: ref __self_1_1,
                } => match *self {
                    TokenGetNftInfoQuery {
                        header: ref __self_0_0,
                        nft_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenGetNftInfoQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.nft_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenGetNftInfoQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.nft_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "nft_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .nft_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.nft_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenGetNftInfoQuery {
        fn default() -> Self {
            TokenGetNftInfoQuery {
                header: ::core::default::Default::default(),
                nft_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenGetNftInfoQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenGetNftInfoQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.nft_id;
                builder.field("nft_id", &wrapper)
            };
            builder.finish()
        }
    }
    pub struct TokenNftInfo {
        /// The ID of the NFT
        #[prost(message, optional, tag = "1")]
        pub nft_id: ::core::option::Option<NftId>,
        /// The current owner of the NFT
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
        /// The effective consensus timestamp at which the NFT was minted
        #[prost(message, optional, tag = "3")]
        pub creation_time: ::core::option::Option<Timestamp>,
        /// Represents the unique metadata of the NFT
        #[prost(bytes = "vec", tag = "4")]
        pub metadata: ::prost::alloc::vec::Vec<u8>,
        /// The ledger ID the response was returned from; please see <a href="<https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a>> for the network-specific IDs.
        #[prost(bytes = "vec", tag = "5")]
        pub ledger_id: ::prost::alloc::vec::Vec<u8>,
        /// If an allowance is granted for the NFT, its corresponding spender account
        #[prost(message, optional, tag = "6")]
        pub spender_id: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenNftInfo {
        #[inline]
        fn clone(&self) -> TokenNftInfo {
            match *self {
                TokenNftInfo {
                    nft_id: ref __self_0_0,
                    account_id: ref __self_0_1,
                    creation_time: ref __self_0_2,
                    metadata: ref __self_0_3,
                    ledger_id: ref __self_0_4,
                    spender_id: ref __self_0_5,
                } => TokenNftInfo {
                    nft_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    creation_time: ::core::clone::Clone::clone(&(*__self_0_2)),
                    metadata: ::core::clone::Clone::clone(&(*__self_0_3)),
                    ledger_id: ::core::clone::Clone::clone(&(*__self_0_4)),
                    spender_id: ::core::clone::Clone::clone(&(*__self_0_5)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenNftInfo {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenNftInfo {
        #[inline]
        fn eq(&self, other: &TokenNftInfo) -> bool {
            match *other {
                TokenNftInfo {
                    nft_id: ref __self_1_0,
                    account_id: ref __self_1_1,
                    creation_time: ref __self_1_2,
                    metadata: ref __self_1_3,
                    ledger_id: ref __self_1_4,
                    spender_id: ref __self_1_5,
                } => match *self {
                    TokenNftInfo {
                        nft_id: ref __self_0_0,
                        account_id: ref __self_0_1,
                        creation_time: ref __self_0_2,
                        metadata: ref __self_0_3,
                        ledger_id: ref __self_0_4,
                        spender_id: ref __self_0_5,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenNftInfo) -> bool {
            match *other {
                TokenNftInfo {
                    nft_id: ref __self_1_0,
                    account_id: ref __self_1_1,
                    creation_time: ref __self_1_2,
                    metadata: ref __self_1_3,
                    ledger_id: ref __self_1_4,
                    spender_id: ref __self_1_5,
                } => match *self {
                    TokenNftInfo {
                        nft_id: ref __self_0_0,
                        account_id: ref __self_0_1,
                        creation_time: ref __self_0_2,
                        metadata: ref __self_0_3,
                        ledger_id: ref __self_0_4,
                        spender_id: ref __self_0_5,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenNftInfo {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.nft_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if let Some(ref msg) = self.creation_time {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
            if self.metadata != b"" as &[u8] {
                ::prost::encoding::bytes::encode(4u32, &self.metadata, buf);
            }
            if self.ledger_id != b"" as &[u8] {
                ::prost::encoding::bytes::encode(5u32, &self.ledger_id, buf);
            }
            if let Some(ref msg) = self.spender_id {
                ::prost::encoding::message::encode(6u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenNftInfo";
            match tag {
                1u32 => {
                    let mut value = &mut self.nft_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "nft_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.creation_time;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "creation_time");
                        error
                    })
                }
                4u32 => {
                    let mut value = &mut self.metadata;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "metadata");
                            error
                        },
                    )
                }
                5u32 => {
                    let mut value = &mut self.ledger_id;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "ledger_id");
                            error
                        },
                    )
                }
                6u32 => {
                    let mut value = &mut self.spender_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "spender_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .nft_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + self
                    .creation_time
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(3u32, msg))
                + if self.metadata != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(4u32, &self.metadata)
                } else {
                    0
                }
                + if self.ledger_id != b"" as &[u8] {
                    ::prost::encoding::bytes::encoded_len(5u32, &self.ledger_id)
                } else {
                    0
                }
                + self
                    .spender_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
        }
        fn clear(&mut self) {
            self.nft_id = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
            self.creation_time = ::core::option::Option::None;
            self.metadata.clear();
            self.ledger_id.clear();
            self.spender_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenNftInfo {
        fn default() -> Self {
            TokenNftInfo {
                nft_id: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
                creation_time: ::core::default::Default::default(),
                metadata: ::core::default::Default::default(),
                ledger_id: ::core::default::Default::default(),
                spender_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenNftInfo {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenNftInfo");
            let builder = {
                let wrapper = &self.nft_id;
                builder.field("nft_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.creation_time;
                builder.field("creation_time", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.metadata)
                };
                builder.field("metadata", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.ledger_id)
                };
                builder.field("ledger_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.spender_id;
                builder.field("spender_id", &wrapper)
            };
            builder.finish()
        }
    }
    pub struct TokenGetNftInfoResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The information about this NFT
        #[prost(message, optional, tag = "2")]
        pub nft: ::core::option::Option<TokenNftInfo>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenGetNftInfoResponse {
        #[inline]
        fn clone(&self) -> TokenGetNftInfoResponse {
            match *self {
                TokenGetNftInfoResponse {
                    header: ref __self_0_0,
                    nft: ref __self_0_1,
                } => TokenGetNftInfoResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    nft: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenGetNftInfoResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenGetNftInfoResponse {
        #[inline]
        fn eq(&self, other: &TokenGetNftInfoResponse) -> bool {
            match *other {
                TokenGetNftInfoResponse {
                    header: ref __self_1_0,
                    nft: ref __self_1_1,
                } => match *self {
                    TokenGetNftInfoResponse {
                        header: ref __self_0_0,
                        nft: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenGetNftInfoResponse) -> bool {
            match *other {
                TokenGetNftInfoResponse {
                    header: ref __self_1_0,
                    nft: ref __self_1_1,
                } => match *self {
                    TokenGetNftInfoResponse {
                        header: ref __self_0_0,
                        nft: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenGetNftInfoResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.nft {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenGetNftInfoResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.nft;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "nft");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .nft
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.nft = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for TokenGetNftInfoResponse {
        fn default() -> Self {
            TokenGetNftInfoResponse {
                header: ::core::default::Default::default(),
                nft: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenGetNftInfoResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenGetNftInfoResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.nft;
                builder.field("nft", &wrapper)
            };
            builder.finish()
        }
    }
    /// Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on NFTs N through M owned by the
    /// specified accountId.
    /// Example: If Account A owns 5 NFTs (might be of different Token Entity), having start=0 and end=5
    /// will return all of the NFTs
    ///
    /// INVALID_QUERY_RANGE response code will be returned if:
    /// 1) Start > End
    /// 2) Start and End indices are non-positive
    /// 3) Start and End indices are out of boundaries for the retrieved nft list
    /// 4) The range between Start and End is bigger than the global dynamic property for maximum query
    ///    range
    ///
    /// NOT_SUPPORTED response code will be returned if the queried token is of type FUNGIBLE_COMMON
    ///
    /// INVALID_ACCOUNT_ID response code will be returned if the queried account does not exist
    ///
    /// ACCOUNT_DELETED response code will be returned if the queried account has been deleted
    pub struct TokenGetAccountNftInfosQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The Account for which information is requested
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
        /// Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
        /// range [0; ownedNFTs-1]
        #[prost(int64, tag = "3")]
        pub start: i64,
        /// Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
        /// range (start; ownedNFTs]
        #[prost(int64, tag = "4")]
        pub end: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenGetAccountNftInfosQuery {
        #[inline]
        fn clone(&self) -> TokenGetAccountNftInfosQuery {
            match *self {
                TokenGetAccountNftInfosQuery {
                    header: ref __self_0_0,
                    account_id: ref __self_0_1,
                    start: ref __self_0_2,
                    end: ref __self_0_3,
                } => TokenGetAccountNftInfosQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    start: ::core::clone::Clone::clone(&(*__self_0_2)),
                    end: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenGetAccountNftInfosQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenGetAccountNftInfosQuery {
        #[inline]
        fn eq(&self, other: &TokenGetAccountNftInfosQuery) -> bool {
            match *other {
                TokenGetAccountNftInfosQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                    start: ref __self_1_2,
                    end: ref __self_1_3,
                } => match *self {
                    TokenGetAccountNftInfosQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                        start: ref __self_0_2,
                        end: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenGetAccountNftInfosQuery) -> bool {
            match *other {
                TokenGetAccountNftInfosQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                    start: ref __self_1_2,
                    end: ref __self_1_3,
                } => match *self {
                    TokenGetAccountNftInfosQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                        start: ref __self_0_2,
                        end: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenGetAccountNftInfosQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.start != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.start, buf);
            }
            if self.end != 0i64 {
                ::prost::encoding::int64::encode(4u32, &self.end, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenGetAccountNftInfosQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.start;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "start");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.end;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "end");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.start != 0i64 {
                    ::prost::encoding::int64::encoded_len(3u32, &self.start)
                } else {
                    0
                }
                + if self.end != 0i64 {
                    ::prost::encoding::int64::encoded_len(4u32, &self.end)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
            self.start = 0i64;
            self.end = 0i64;
        }
    }
    impl ::core::default::Default for TokenGetAccountNftInfosQuery {
        fn default() -> Self {
            TokenGetAccountNftInfosQuery {
                header: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
                start: 0i64,
                end: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for TokenGetAccountNftInfosQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenGetAccountNftInfosQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.start)
                };
                builder.field("start", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.end)
                };
                builder.field("end", &wrapper)
            };
            builder.finish()
        }
    }
    pub struct TokenGetAccountNftInfosResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// List of NFTs associated to the account
        #[prost(message, repeated, tag = "2")]
        pub nfts: ::prost::alloc::vec::Vec<TokenNftInfo>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenGetAccountNftInfosResponse {
        #[inline]
        fn clone(&self) -> TokenGetAccountNftInfosResponse {
            match *self {
                TokenGetAccountNftInfosResponse {
                    header: ref __self_0_0,
                    nfts: ref __self_0_1,
                } => TokenGetAccountNftInfosResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    nfts: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenGetAccountNftInfosResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenGetAccountNftInfosResponse {
        #[inline]
        fn eq(&self, other: &TokenGetAccountNftInfosResponse) -> bool {
            match *other {
                TokenGetAccountNftInfosResponse {
                    header: ref __self_1_0,
                    nfts: ref __self_1_1,
                } => match *self {
                    TokenGetAccountNftInfosResponse {
                        header: ref __self_0_0,
                        nfts: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenGetAccountNftInfosResponse) -> bool {
            match *other {
                TokenGetAccountNftInfosResponse {
                    header: ref __self_1_0,
                    nfts: ref __self_1_1,
                } => match *self {
                    TokenGetAccountNftInfosResponse {
                        header: ref __self_0_0,
                        nfts: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for TokenGetAccountNftInfosResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            for msg in &self.nfts {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenGetAccountNftInfosResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.nfts;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "nfts");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(2u32, &self.nfts)
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.nfts.clear();
        }
    }
    impl ::core::default::Default for TokenGetAccountNftInfosResponse {
        fn default() -> Self {
            TokenGetAccountNftInfosResponse {
                header: ::core::default::Default::default(),
                nfts: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenGetAccountNftInfosResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenGetAccountNftInfosResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.nfts;
                builder.field("nfts", &wrapper)
            };
            builder.finish()
        }
    }
    /// Applicable only to tokens of type NON_FUNGIBLE_UNIQUE. Gets info on NFTs N through M on the list
    /// of NFTs associated with a given NON_FUNGIBLE_UNIQUE Token.
    /// Example: If there are 10 NFTs issued, having start=0 and end=5 will query for the first 5 NFTs.
    /// Querying +all 10 NFTs will require start=0 and end=10
    ///
    /// INVALID_QUERY_RANGE response code will be returned if:
    /// 1) Start > End
    /// 2) Start and End indices are non-positive
    /// 3) Start and End indices are out of boundaries for the retrieved nft list
    /// 4) The range between Start and End is bigger than the global dynamic property for maximum query
    /// range
    ///
    /// NOT_SUPPORTED response code will be returned if the queried token is of type FUNGIBLE_COMMON
    ///
    /// INVALID_TOKEN_ID response code will be returned if the queried token does not exist
    pub struct TokenGetNftInfosQuery {
        /// Standard info sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The ID of the token for which information is requested
        #[prost(message, optional, tag = "2")]
        pub token_id: ::core::option::Option<TokenId>,
        /// Specifies the start index (inclusive) of the range of NFTs to query for. Value must be in the
        /// range [0; ownedNFTs-1]
        #[prost(int64, tag = "3")]
        pub start: i64,
        /// Specifies the end index (exclusive) of the range of NFTs to query for. Value must be in the
        /// range (start; ownedNFTs]
        #[prost(int64, tag = "4")]
        pub end: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenGetNftInfosQuery {
        #[inline]
        fn clone(&self) -> TokenGetNftInfosQuery {
            match *self {
                TokenGetNftInfosQuery {
                    header: ref __self_0_0,
                    token_id: ref __self_0_1,
                    start: ref __self_0_2,
                    end: ref __self_0_3,
                } => TokenGetNftInfosQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    token_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    start: ::core::clone::Clone::clone(&(*__self_0_2)),
                    end: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenGetNftInfosQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenGetNftInfosQuery {
        #[inline]
        fn eq(&self, other: &TokenGetNftInfosQuery) -> bool {
            match *other {
                TokenGetNftInfosQuery {
                    header: ref __self_1_0,
                    token_id: ref __self_1_1,
                    start: ref __self_1_2,
                    end: ref __self_1_3,
                } => match *self {
                    TokenGetNftInfosQuery {
                        header: ref __self_0_0,
                        token_id: ref __self_0_1,
                        start: ref __self_0_2,
                        end: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenGetNftInfosQuery) -> bool {
            match *other {
                TokenGetNftInfosQuery {
                    header: ref __self_1_0,
                    token_id: ref __self_1_1,
                    start: ref __self_1_2,
                    end: ref __self_1_3,
                } => match *self {
                    TokenGetNftInfosQuery {
                        header: ref __self_0_0,
                        token_id: ref __self_0_1,
                        start: ref __self_0_2,
                        end: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenGetNftInfosQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.start != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.start, buf);
            }
            if self.end != 0i64 {
                ::prost::encoding::int64::encode(4u32, &self.end, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenGetNftInfosQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.start;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "start");
                            error
                        },
                    )
                }
                4u32 => {
                    let mut value = &mut self.end;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "end");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .token_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.start != 0i64 {
                    ::prost::encoding::int64::encoded_len(3u32, &self.start)
                } else {
                    0
                }
                + if self.end != 0i64 {
                    ::prost::encoding::int64::encoded_len(4u32, &self.end)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.token_id = ::core::option::Option::None;
            self.start = 0i64;
            self.end = 0i64;
        }
    }
    impl ::core::default::Default for TokenGetNftInfosQuery {
        fn default() -> Self {
            TokenGetNftInfosQuery {
                header: ::core::default::Default::default(),
                token_id: ::core::default::Default::default(),
                start: 0i64,
                end: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for TokenGetNftInfosQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenGetNftInfosQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.start)
                };
                builder.field("start", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.end)
                };
                builder.field("end", &wrapper)
            };
            builder.finish()
        }
    }
    pub struct TokenGetNftInfosResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// The Token with type NON_FUNGIBLE that this record is for
        #[prost(message, optional, tag = "2")]
        pub token_id: ::core::option::Option<TokenId>,
        /// List of NFTs associated to the specified token
        #[prost(message, repeated, tag = "3")]
        pub nfts: ::prost::alloc::vec::Vec<TokenNftInfo>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenGetNftInfosResponse {
        #[inline]
        fn clone(&self) -> TokenGetNftInfosResponse {
            match *self {
                TokenGetNftInfosResponse {
                    header: ref __self_0_0,
                    token_id: ref __self_0_1,
                    nfts: ref __self_0_2,
                } => TokenGetNftInfosResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    token_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    nfts: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenGetNftInfosResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenGetNftInfosResponse {
        #[inline]
        fn eq(&self, other: &TokenGetNftInfosResponse) -> bool {
            match *other {
                TokenGetNftInfosResponse {
                    header: ref __self_1_0,
                    token_id: ref __self_1_1,
                    nfts: ref __self_1_2,
                } => match *self {
                    TokenGetNftInfosResponse {
                        header: ref __self_0_0,
                        token_id: ref __self_0_1,
                        nfts: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenGetNftInfosResponse) -> bool {
            match *other {
                TokenGetNftInfosResponse {
                    header: ref __self_1_0,
                    token_id: ref __self_1_1,
                    nfts: ref __self_1_2,
                } => match *self {
                    TokenGetNftInfosResponse {
                        header: ref __self_0_0,
                        token_id: ref __self_0_1,
                        nfts: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for TokenGetNftInfosResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            for msg in &self.nfts {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "TokenGetNftInfosResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.nfts;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "nfts");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .token_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + ::prost::encoding::message::encoded_len_repeated(3u32, &self.nfts)
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.token_id = ::core::option::Option::None;
            self.nfts.clear();
        }
    }
    impl ::core::default::Default for TokenGetNftInfosResponse {
        fn default() -> Self {
            TokenGetNftInfosResponse {
                header: ::core::default::Default::default(),
                token_id: ::core::default::Default::default(),
                nfts: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for TokenGetNftInfosResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("TokenGetNftInfosResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.nfts;
                builder.field("nfts", &wrapper)
            };
            builder.finish()
        }
    }
    /// Gets all the information about an account, including balance and allowances. This does not get the list of
    /// account records.
    pub struct GetAccountDetailsQuery {
        /// Account details sent from client to node, including the signed payment, and what kind of
        /// response is requested (cost, state proof, both, or neither).
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<QueryHeader>,
        /// The account ID for which information is requested
        #[prost(message, optional, tag = "2")]
        pub account_id: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for GetAccountDetailsQuery {
        #[inline]
        fn clone(&self) -> GetAccountDetailsQuery {
            match *self {
                GetAccountDetailsQuery {
                    header: ref __self_0_0,
                    account_id: ref __self_0_1,
                } => GetAccountDetailsQuery {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for GetAccountDetailsQuery {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for GetAccountDetailsQuery {
        #[inline]
        fn eq(&self, other: &GetAccountDetailsQuery) -> bool {
            match *other {
                GetAccountDetailsQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                } => match *self {
                    GetAccountDetailsQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GetAccountDetailsQuery) -> bool {
            match *other {
                GetAccountDetailsQuery {
                    header: ref __self_1_0,
                    account_id: ref __self_1_1,
                } => match *self {
                    GetAccountDetailsQuery {
                        header: ref __self_0_0,
                        account_id: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for GetAccountDetailsQuery {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_id {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "GetAccountDetailsQuery";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_id");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.account_id = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for GetAccountDetailsQuery {
        fn default() -> Self {
            GetAccountDetailsQuery {
                header: ::core::default::Default::default(),
                account_id: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for GetAccountDetailsQuery {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("GetAccountDetailsQuery");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_id;
                builder.field("account_id", &wrapper)
            };
            builder.finish()
        }
    }
    /// Response when the client sends the node GetAccountDetailsQuery
    pub struct GetAccountDetailsResponse {
        /// Standard response from node to client, including the requested fields: cost, or state proof,
        /// or both, or neither
        #[prost(message, optional, tag = "1")]
        pub header: ::core::option::Option<ResponseHeader>,
        /// Details of the account (a state proof can be generated for this)
        #[prost(message, optional, tag = "2")]
        pub account_details: ::core::option::Option<get_account_details_response::AccountDetails>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for GetAccountDetailsResponse {
        #[inline]
        fn clone(&self) -> GetAccountDetailsResponse {
            match *self {
                GetAccountDetailsResponse {
                    header: ref __self_0_0,
                    account_details: ref __self_0_1,
                } => GetAccountDetailsResponse {
                    header: ::core::clone::Clone::clone(&(*__self_0_0)),
                    account_details: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for GetAccountDetailsResponse {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for GetAccountDetailsResponse {
        #[inline]
        fn eq(&self, other: &GetAccountDetailsResponse) -> bool {
            match *other {
                GetAccountDetailsResponse {
                    header: ref __self_1_0,
                    account_details: ref __self_1_1,
                } => match *self {
                    GetAccountDetailsResponse {
                        header: ref __self_0_0,
                        account_details: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GetAccountDetailsResponse) -> bool {
            match *other {
                GetAccountDetailsResponse {
                    header: ref __self_1_0,
                    account_details: ref __self_1_1,
                } => match *self {
                    GetAccountDetailsResponse {
                        header: ref __self_0_0,
                        account_details: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for GetAccountDetailsResponse {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.header {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.account_details {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "GetAccountDetailsResponse";
            match tag {
                1u32 => {
                    let mut value = &mut self.header;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "header");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.account_details;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "account_details");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .header
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .account_details
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.header = ::core::option::Option::None;
            self.account_details = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for GetAccountDetailsResponse {
        fn default() -> Self {
            GetAccountDetailsResponse {
                header: ::core::default::Default::default(),
                account_details: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for GetAccountDetailsResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("GetAccountDetailsResponse");
            let builder = {
                let wrapper = &self.header;
                builder.field("header", &wrapper)
            };
            let builder = {
                let wrapper = &self.account_details;
                builder.field("account_details", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `GetAccountDetailsResponse`.
    pub mod get_account_details_response {
        pub struct AccountDetails {
            /// The account ID for which this information applies
            #[prost(message, optional, tag = "1")]
            pub account_id: ::core::option::Option<super::AccountId>,
            /// The Contract Account ID comprising of both the contract instance and the cryptocurrency
            /// account owned by the contract instance, in the format used by Solidity
            #[prost(string, tag = "2")]
            pub contract_account_id: ::prost::alloc::string::String,
            /// If true, then this account has been deleted, it will disappear when it expires, and all
            /// transactions for it will fail except the transaction to extend its expiration date
            #[prost(bool, tag = "3")]
            pub deleted: bool,
            /// \[Deprecated\] The Account ID of the account to which this is proxy staked. If proxyAccountID is null,
            /// or is an invalid account, or is an account that isn't a node, then this account is
            /// automatically proxy staked to a node chosen by the network, but without earning payments.
            /// If the proxyAccountID account refuses to accept proxy staking , or if it is not currently
            /// running a node, then it will behave as if proxyAccountID was null.
            #[deprecated]
            #[prost(message, optional, tag = "4")]
            pub proxy_account_id: ::core::option::Option<super::AccountId>,
            /// The total number of tinybars proxy staked to this account
            #[prost(int64, tag = "5")]
            pub proxy_received: i64,
            /// The key for the account, which must sign in order to transfer out, or to modify the
            /// account in any way other than extending its expiration date.
            #[prost(message, optional, tag = "6")]
            pub key: ::core::option::Option<super::Key>,
            /// The current balance of account in tinybars
            #[prost(uint64, tag = "7")]
            pub balance: u64,
            /// If true, no transaction can transfer to this account unless signed by this account's key
            #[prost(bool, tag = "8")]
            pub receiver_sig_required: bool,
            /// The TimeStamp time at which this account is set to expire
            #[prost(message, optional, tag = "9")]
            pub expiration_time: ::core::option::Option<super::Timestamp>,
            /// The duration for expiration time will extend every this many seconds. If there are
            /// insufficient funds, then it extends as long as possible. If it is empty when it expires,
            /// then it is deleted.
            #[prost(message, optional, tag = "10")]
            pub auto_renew_period: ::core::option::Option<super::Duration>,
            /// All tokens related to this account
            #[prost(message, repeated, tag = "11")]
            pub token_relationships: ::prost::alloc::vec::Vec<super::TokenRelationship>,
            /// The memo associated with the account
            #[prost(string, tag = "12")]
            pub memo: ::prost::alloc::string::String,
            /// The number of NFTs owned by this account
            #[prost(int64, tag = "13")]
            pub owned_nfts: i64,
            /// The maximum number of tokens that an Account can be implicitly associated with.
            #[prost(int32, tag = "14")]
            pub max_automatic_token_associations: i32,
            /// The alias of this account
            #[prost(bytes = "vec", tag = "15")]
            pub alias: ::prost::alloc::vec::Vec<u8>,
            /// The ledger ID the response was returned from; please see <a href="<https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a>> for the network-specific IDs.
            #[prost(bytes = "vec", tag = "16")]
            pub ledger_id: ::prost::alloc::vec::Vec<u8>,
            /// All of the hbar allowances approved by the account owner.
            #[prost(message, repeated, tag = "17")]
            pub granted_crypto_allowances: ::prost::alloc::vec::Vec<super::GrantedCryptoAllowance>,
            /// All of the non-fungible token allowances approved by the account owner.
            #[prost(message, repeated, tag = "18")]
            pub granted_nft_allowances: ::prost::alloc::vec::Vec<super::GrantedNftAllowance>,
            /// All of the fungible token allowances approved by the account owner.
            #[prost(message, repeated, tag = "19")]
            pub granted_token_allowances: ::prost::alloc::vec::Vec<super::GrantedTokenAllowance>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for AccountDetails {
            #[inline]
            fn clone(&self) -> AccountDetails {
                match *self {
                    AccountDetails {
                        account_id: ref __self_0_0,
                        contract_account_id: ref __self_0_1,
                        deleted: ref __self_0_2,
                        proxy_account_id: ref __self_0_3,
                        proxy_received: ref __self_0_4,
                        key: ref __self_0_5,
                        balance: ref __self_0_6,
                        receiver_sig_required: ref __self_0_7,
                        expiration_time: ref __self_0_8,
                        auto_renew_period: ref __self_0_9,
                        token_relationships: ref __self_0_10,
                        memo: ref __self_0_11,
                        owned_nfts: ref __self_0_12,
                        max_automatic_token_associations: ref __self_0_13,
                        alias: ref __self_0_14,
                        ledger_id: ref __self_0_15,
                        granted_crypto_allowances: ref __self_0_16,
                        granted_nft_allowances: ref __self_0_17,
                        granted_token_allowances: ref __self_0_18,
                    } => AccountDetails {
                        account_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                        contract_account_id: ::core::clone::Clone::clone(&(*__self_0_1)),
                        deleted: ::core::clone::Clone::clone(&(*__self_0_2)),
                        proxy_account_id: ::core::clone::Clone::clone(&(*__self_0_3)),
                        proxy_received: ::core::clone::Clone::clone(&(*__self_0_4)),
                        key: ::core::clone::Clone::clone(&(*__self_0_5)),
                        balance: ::core::clone::Clone::clone(&(*__self_0_6)),
                        receiver_sig_required: ::core::clone::Clone::clone(&(*__self_0_7)),
                        expiration_time: ::core::clone::Clone::clone(&(*__self_0_8)),
                        auto_renew_period: ::core::clone::Clone::clone(&(*__self_0_9)),
                        token_relationships: ::core::clone::Clone::clone(&(*__self_0_10)),
                        memo: ::core::clone::Clone::clone(&(*__self_0_11)),
                        owned_nfts: ::core::clone::Clone::clone(&(*__self_0_12)),
                        max_automatic_token_associations: ::core::clone::Clone::clone(
                            &(*__self_0_13),
                        ),
                        alias: ::core::clone::Clone::clone(&(*__self_0_14)),
                        ledger_id: ::core::clone::Clone::clone(&(*__self_0_15)),
                        granted_crypto_allowances: ::core::clone::Clone::clone(&(*__self_0_16)),
                        granted_nft_allowances: ::core::clone::Clone::clone(&(*__self_0_17)),
                        granted_token_allowances: ::core::clone::Clone::clone(&(*__self_0_18)),
                    },
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for AccountDetails {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for AccountDetails {
            #[inline]
            fn eq(&self, other: &AccountDetails) -> bool {
                match *other {
                    AccountDetails {
                        account_id: ref __self_1_0,
                        contract_account_id: ref __self_1_1,
                        deleted: ref __self_1_2,
                        proxy_account_id: ref __self_1_3,
                        proxy_received: ref __self_1_4,
                        key: ref __self_1_5,
                        balance: ref __self_1_6,
                        receiver_sig_required: ref __self_1_7,
                        expiration_time: ref __self_1_8,
                        auto_renew_period: ref __self_1_9,
                        token_relationships: ref __self_1_10,
                        memo: ref __self_1_11,
                        owned_nfts: ref __self_1_12,
                        max_automatic_token_associations: ref __self_1_13,
                        alias: ref __self_1_14,
                        ledger_id: ref __self_1_15,
                        granted_crypto_allowances: ref __self_1_16,
                        granted_nft_allowances: ref __self_1_17,
                        granted_token_allowances: ref __self_1_18,
                    } => match *self {
                        AccountDetails {
                            account_id: ref __self_0_0,
                            contract_account_id: ref __self_0_1,
                            deleted: ref __self_0_2,
                            proxy_account_id: ref __self_0_3,
                            proxy_received: ref __self_0_4,
                            key: ref __self_0_5,
                            balance: ref __self_0_6,
                            receiver_sig_required: ref __self_0_7,
                            expiration_time: ref __self_0_8,
                            auto_renew_period: ref __self_0_9,
                            token_relationships: ref __self_0_10,
                            memo: ref __self_0_11,
                            owned_nfts: ref __self_0_12,
                            max_automatic_token_associations: ref __self_0_13,
                            alias: ref __self_0_14,
                            ledger_id: ref __self_0_15,
                            granted_crypto_allowances: ref __self_0_16,
                            granted_nft_allowances: ref __self_0_17,
                            granted_token_allowances: ref __self_0_18,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                                && (*__self_0_4) == (*__self_1_4)
                                && (*__self_0_5) == (*__self_1_5)
                                && (*__self_0_6) == (*__self_1_6)
                                && (*__self_0_7) == (*__self_1_7)
                                && (*__self_0_8) == (*__self_1_8)
                                && (*__self_0_9) == (*__self_1_9)
                                && (*__self_0_10) == (*__self_1_10)
                                && (*__self_0_11) == (*__self_1_11)
                                && (*__self_0_12) == (*__self_1_12)
                                && (*__self_0_13) == (*__self_1_13)
                                && (*__self_0_14) == (*__self_1_14)
                                && (*__self_0_15) == (*__self_1_15)
                                && (*__self_0_16) == (*__self_1_16)
                                && (*__self_0_17) == (*__self_1_17)
                                && (*__self_0_18) == (*__self_1_18)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &AccountDetails) -> bool {
                match *other {
                    AccountDetails {
                        account_id: ref __self_1_0,
                        contract_account_id: ref __self_1_1,
                        deleted: ref __self_1_2,
                        proxy_account_id: ref __self_1_3,
                        proxy_received: ref __self_1_4,
                        key: ref __self_1_5,
                        balance: ref __self_1_6,
                        receiver_sig_required: ref __self_1_7,
                        expiration_time: ref __self_1_8,
                        auto_renew_period: ref __self_1_9,
                        token_relationships: ref __self_1_10,
                        memo: ref __self_1_11,
                        owned_nfts: ref __self_1_12,
                        max_automatic_token_associations: ref __self_1_13,
                        alias: ref __self_1_14,
                        ledger_id: ref __self_1_15,
                        granted_crypto_allowances: ref __self_1_16,
                        granted_nft_allowances: ref __self_1_17,
                        granted_token_allowances: ref __self_1_18,
                    } => match *self {
                        AccountDetails {
                            account_id: ref __self_0_0,
                            contract_account_id: ref __self_0_1,
                            deleted: ref __self_0_2,
                            proxy_account_id: ref __self_0_3,
                            proxy_received: ref __self_0_4,
                            key: ref __self_0_5,
                            balance: ref __self_0_6,
                            receiver_sig_required: ref __self_0_7,
                            expiration_time: ref __self_0_8,
                            auto_renew_period: ref __self_0_9,
                            token_relationships: ref __self_0_10,
                            memo: ref __self_0_11,
                            owned_nfts: ref __self_0_12,
                            max_automatic_token_associations: ref __self_0_13,
                            alias: ref __self_0_14,
                            ledger_id: ref __self_0_15,
                            granted_crypto_allowances: ref __self_0_16,
                            granted_nft_allowances: ref __self_0_17,
                            granted_token_allowances: ref __self_0_18,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                                || (*__self_0_4) != (*__self_1_4)
                                || (*__self_0_5) != (*__self_1_5)
                                || (*__self_0_6) != (*__self_1_6)
                                || (*__self_0_7) != (*__self_1_7)
                                || (*__self_0_8) != (*__self_1_8)
                                || (*__self_0_9) != (*__self_1_9)
                                || (*__self_0_10) != (*__self_1_10)
                                || (*__self_0_11) != (*__self_1_11)
                                || (*__self_0_12) != (*__self_1_12)
                                || (*__self_0_13) != (*__self_1_13)
                                || (*__self_0_14) != (*__self_1_14)
                                || (*__self_0_15) != (*__self_1_15)
                                || (*__self_0_16) != (*__self_1_16)
                                || (*__self_0_17) != (*__self_1_17)
                                || (*__self_0_18) != (*__self_1_18)
                        }
                    },
                }
            }
        }
        impl ::prost::Message for AccountDetails {
            #[allow(unused_variables)]
            fn encode_raw<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                if let Some(ref msg) = self.account_id {
                    ::prost::encoding::message::encode(1u32, msg, buf);
                }
                if self.contract_account_id != "" {
                    ::prost::encoding::string::encode(2u32, &self.contract_account_id, buf);
                }
                if self.deleted != false {
                    ::prost::encoding::bool::encode(3u32, &self.deleted, buf);
                }
                if let Some(ref msg) = self.proxy_account_id {
                    ::prost::encoding::message::encode(4u32, msg, buf);
                }
                if self.proxy_received != 0i64 {
                    ::prost::encoding::int64::encode(5u32, &self.proxy_received, buf);
                }
                if let Some(ref msg) = self.key {
                    ::prost::encoding::message::encode(6u32, msg, buf);
                }
                if self.balance != 0u64 {
                    ::prost::encoding::uint64::encode(7u32, &self.balance, buf);
                }
                if self.receiver_sig_required != false {
                    ::prost::encoding::bool::encode(8u32, &self.receiver_sig_required, buf);
                }
                if let Some(ref msg) = self.expiration_time {
                    ::prost::encoding::message::encode(9u32, msg, buf);
                }
                if let Some(ref msg) = self.auto_renew_period {
                    ::prost::encoding::message::encode(10u32, msg, buf);
                }
                for msg in &self.token_relationships {
                    ::prost::encoding::message::encode(11u32, msg, buf);
                }
                if self.memo != "" {
                    ::prost::encoding::string::encode(12u32, &self.memo, buf);
                }
                if self.owned_nfts != 0i64 {
                    ::prost::encoding::int64::encode(13u32, &self.owned_nfts, buf);
                }
                if self.max_automatic_token_associations != 0i32 {
                    ::prost::encoding::int32::encode(
                        14u32,
                        &self.max_automatic_token_associations,
                        buf,
                    );
                }
                if self.alias != b"" as &[u8] {
                    ::prost::encoding::bytes::encode(15u32, &self.alias, buf);
                }
                if self.ledger_id != b"" as &[u8] {
                    ::prost::encoding::bytes::encode(16u32, &self.ledger_id, buf);
                }
                for msg in &self.granted_crypto_allowances {
                    ::prost::encoding::message::encode(17u32, msg, buf);
                }
                for msg in &self.granted_nft_allowances {
                    ::prost::encoding::message::encode(18u32, msg, buf);
                }
                for msg in &self.granted_token_allowances {
                    ::prost::encoding::message::encode(19u32, msg, buf);
                }
            }
            #[allow(unused_variables)]
            fn merge_field<B>(
                &mut self,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                const STRUCT_NAME: &'static str = "AccountDetails";
                match tag {
                    1u32 => {
                        let mut value = &mut self.account_id;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "account_id");
                            error
                        })
                    }
                    2u32 => {
                        let mut value = &mut self.contract_account_id;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "contract_account_id");
                                error
                            },
                        )
                    }
                    3u32 => {
                        let mut value = &mut self.deleted;
                        ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "deleted");
                                error
                            },
                        )
                    }
                    4u32 => {
                        let mut value = &mut self.proxy_account_id;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "proxy_account_id");
                            error
                        })
                    }
                    5u32 => {
                        let mut value = &mut self.proxy_received;
                        ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "proxy_received");
                                error
                            },
                        )
                    }
                    6u32 => {
                        let mut value = &mut self.key;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "key");
                            error
                        })
                    }
                    7u32 => {
                        let mut value = &mut self.balance;
                        ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "balance");
                                error
                            },
                        )
                    }
                    8u32 => {
                        let mut value = &mut self.receiver_sig_required;
                        ::prost::encoding::bool::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "receiver_sig_required");
                                error
                            },
                        )
                    }
                    9u32 => {
                        let mut value = &mut self.expiration_time;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "expiration_time");
                            error
                        })
                    }
                    10u32 => {
                        let mut value = &mut self.auto_renew_period;
                        ::prost::encoding::message::merge(
                            wire_type,
                            value.get_or_insert_with(::core::default::Default::default),
                            buf,
                            ctx,
                        )
                        .map_err(|mut error| {
                            error.push(STRUCT_NAME, "auto_renew_period");
                            error
                        })
                    }
                    11u32 => {
                        let mut value = &mut self.token_relationships;
                        ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "token_relationships");
                                error
                            })
                    }
                    12u32 => {
                        let mut value = &mut self.memo;
                        ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "memo");
                                error
                            },
                        )
                    }
                    13u32 => {
                        let mut value = &mut self.owned_nfts;
                        ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "owned_nfts");
                                error
                            },
                        )
                    }
                    14u32 => {
                        let mut value = &mut self.max_automatic_token_associations;
                        ::prost::encoding::int32::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "max_automatic_token_associations");
                                error
                            },
                        )
                    }
                    15u32 => {
                        let mut value = &mut self.alias;
                        ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "alias");
                                error
                            },
                        )
                    }
                    16u32 => {
                        let mut value = &mut self.ledger_id;
                        ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                            |mut error| {
                                error.push(STRUCT_NAME, "ledger_id");
                                error
                            },
                        )
                    }
                    17u32 => {
                        let mut value = &mut self.granted_crypto_allowances;
                        ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "granted_crypto_allowances");
                                error
                            })
                    }
                    18u32 => {
                        let mut value = &mut self.granted_nft_allowances;
                        ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "granted_nft_allowances");
                                error
                            })
                    }
                    19u32 => {
                        let mut value = &mut self.granted_token_allowances;
                        ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx)
                            .map_err(|mut error| {
                                error.push(STRUCT_NAME, "granted_token_allowances");
                                error
                            })
                    }
                    _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
                }
            }
            #[inline]
            fn encoded_len(&self) -> usize {
                0 + self
                    .account_id
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                    + if self.contract_account_id != "" {
                        ::prost::encoding::string::encoded_len(2u32, &self.contract_account_id)
                    } else {
                        0
                    }
                    + if self.deleted != false {
                        ::prost::encoding::bool::encoded_len(3u32, &self.deleted)
                    } else {
                        0
                    }
                    + self
                        .proxy_account_id
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(4u32, msg))
                    + if self.proxy_received != 0i64 {
                        ::prost::encoding::int64::encoded_len(5u32, &self.proxy_received)
                    } else {
                        0
                    }
                    + self
                        .key
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(6u32, msg))
                    + if self.balance != 0u64 {
                        ::prost::encoding::uint64::encoded_len(7u32, &self.balance)
                    } else {
                        0
                    }
                    + if self.receiver_sig_required != false {
                        ::prost::encoding::bool::encoded_len(8u32, &self.receiver_sig_required)
                    } else {
                        0
                    }
                    + self
                        .expiration_time
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(9u32, msg))
                    + self
                        .auto_renew_period
                        .as_ref()
                        .map_or(0, |msg| ::prost::encoding::message::encoded_len(10u32, msg))
                    + ::prost::encoding::message::encoded_len_repeated(
                        11u32,
                        &self.token_relationships,
                    )
                    + if self.memo != "" {
                        ::prost::encoding::string::encoded_len(12u32, &self.memo)
                    } else {
                        0
                    }
                    + if self.owned_nfts != 0i64 {
                        ::prost::encoding::int64::encoded_len(13u32, &self.owned_nfts)
                    } else {
                        0
                    }
                    + if self.max_automatic_token_associations != 0i32 {
                        ::prost::encoding::int32::encoded_len(
                            14u32,
                            &self.max_automatic_token_associations,
                        )
                    } else {
                        0
                    }
                    + if self.alias != b"" as &[u8] {
                        ::prost::encoding::bytes::encoded_len(15u32, &self.alias)
                    } else {
                        0
                    }
                    + if self.ledger_id != b"" as &[u8] {
                        ::prost::encoding::bytes::encoded_len(16u32, &self.ledger_id)
                    } else {
                        0
                    }
                    + ::prost::encoding::message::encoded_len_repeated(
                        17u32,
                        &self.granted_crypto_allowances,
                    )
                    + ::prost::encoding::message::encoded_len_repeated(
                        18u32,
                        &self.granted_nft_allowances,
                    )
                    + ::prost::encoding::message::encoded_len_repeated(
                        19u32,
                        &self.granted_token_allowances,
                    )
            }
            fn clear(&mut self) {
                self.account_id = ::core::option::Option::None;
                self.contract_account_id.clear();
                self.deleted = false;
                self.proxy_account_id = ::core::option::Option::None;
                self.proxy_received = 0i64;
                self.key = ::core::option::Option::None;
                self.balance = 0u64;
                self.receiver_sig_required = false;
                self.expiration_time = ::core::option::Option::None;
                self.auto_renew_period = ::core::option::Option::None;
                self.token_relationships.clear();
                self.memo.clear();
                self.owned_nfts = 0i64;
                self.max_automatic_token_associations = 0i32;
                self.alias.clear();
                self.ledger_id.clear();
                self.granted_crypto_allowances.clear();
                self.granted_nft_allowances.clear();
                self.granted_token_allowances.clear();
            }
        }
        impl ::core::default::Default for AccountDetails {
            fn default() -> Self {
                AccountDetails {
                    account_id: ::core::default::Default::default(),
                    contract_account_id: ::prost::alloc::string::String::new(),
                    deleted: false,
                    proxy_account_id: ::core::default::Default::default(),
                    proxy_received: 0i64,
                    key: ::core::default::Default::default(),
                    balance: 0u64,
                    receiver_sig_required: false,
                    expiration_time: ::core::default::Default::default(),
                    auto_renew_period: ::core::default::Default::default(),
                    token_relationships: ::core::default::Default::default(),
                    memo: ::prost::alloc::string::String::new(),
                    owned_nfts: 0i64,
                    max_automatic_token_associations: 0i32,
                    alias: ::core::default::Default::default(),
                    ledger_id: ::core::default::Default::default(),
                    granted_crypto_allowances: ::core::default::Default::default(),
                    granted_nft_allowances: ::core::default::Default::default(),
                    granted_token_allowances: ::core::default::Default::default(),
                }
            }
        }
        impl ::core::fmt::Debug for AccountDetails {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let mut builder = f.debug_struct("AccountDetails");
                let builder = {
                    let wrapper = &self.account_id;
                    builder.field("account_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.contract_account_id)
                    };
                    builder.field("contract_account_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.deleted)
                    };
                    builder.field("deleted", &wrapper)
                };
                let builder = {
                    let wrapper = &self.proxy_account_id;
                    builder.field("proxy_account_id", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.proxy_received)
                    };
                    builder.field("proxy_received", &wrapper)
                };
                let builder = {
                    let wrapper = &self.key;
                    builder.field("key", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.balance)
                    };
                    builder.field("balance", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.receiver_sig_required)
                    };
                    builder.field("receiver_sig_required", &wrapper)
                };
                let builder = {
                    let wrapper = &self.expiration_time;
                    builder.field("expiration_time", &wrapper)
                };
                let builder = {
                    let wrapper = &self.auto_renew_period;
                    builder.field("auto_renew_period", &wrapper)
                };
                let builder = {
                    let wrapper = &self.token_relationships;
                    builder.field("token_relationships", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.memo)
                    };
                    builder.field("memo", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.owned_nfts)
                    };
                    builder.field("owned_nfts", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.max_automatic_token_associations)
                    };
                    builder.field("max_automatic_token_associations", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.alias)
                    };
                    builder.field("alias", &wrapper)
                };
                let builder = {
                    let wrapper = {
                        fn ScalarWrapper<T>(v: T) -> T {
                            v
                        }
                        ScalarWrapper(&self.ledger_id)
                    };
                    builder.field("ledger_id", &wrapper)
                };
                let builder = {
                    let wrapper = &self.granted_crypto_allowances;
                    builder.field("granted_crypto_allowances", &wrapper)
                };
                let builder = {
                    let wrapper = &self.granted_nft_allowances;
                    builder.field("granted_nft_allowances", &wrapper)
                };
                let builder = {
                    let wrapper = &self.granted_token_allowances;
                    builder.field("granted_token_allowances", &wrapper)
                };
                builder.finish()
            }
        }
    }
    /// A granted allowance of hbar transfers for a spender relative to the owner account.
    pub struct GrantedCryptoAllowance {
        /// The account ID of the spender of the hbar allowance.
        #[prost(message, optional, tag = "1")]
        pub spender: ::core::option::Option<AccountId>,
        /// The amount of the spender's allowance in tinybars.
        #[prost(int64, tag = "2")]
        pub amount: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for GrantedCryptoAllowance {
        #[inline]
        fn clone(&self) -> GrantedCryptoAllowance {
            match *self {
                GrantedCryptoAllowance {
                    spender: ref __self_0_0,
                    amount: ref __self_0_1,
                } => GrantedCryptoAllowance {
                    spender: ::core::clone::Clone::clone(&(*__self_0_0)),
                    amount: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for GrantedCryptoAllowance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for GrantedCryptoAllowance {
        #[inline]
        fn eq(&self, other: &GrantedCryptoAllowance) -> bool {
            match *other {
                GrantedCryptoAllowance {
                    spender: ref __self_1_0,
                    amount: ref __self_1_1,
                } => match *self {
                    GrantedCryptoAllowance {
                        spender: ref __self_0_0,
                        amount: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GrantedCryptoAllowance) -> bool {
            match *other {
                GrantedCryptoAllowance {
                    spender: ref __self_1_0,
                    amount: ref __self_1_1,
                } => match *self {
                    GrantedCryptoAllowance {
                        spender: ref __self_0_0,
                        amount: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for GrantedCryptoAllowance {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.spender {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if self.amount != 0i64 {
                ::prost::encoding::int64::encode(2u32, &self.amount, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "GrantedCryptoAllowance";
            match tag {
                1u32 => {
                    let mut value = &mut self.spender;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "spender");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .spender
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + if self.amount != 0i64 {
                    ::prost::encoding::int64::encoded_len(2u32, &self.amount)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.spender = ::core::option::Option::None;
            self.amount = 0i64;
        }
    }
    impl ::core::default::Default for GrantedCryptoAllowance {
        fn default() -> Self {
            GrantedCryptoAllowance {
                spender: ::core::default::Default::default(),
                amount: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for GrantedCryptoAllowance {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("GrantedCryptoAllowance");
            let builder = {
                let wrapper = &self.spender;
                builder.field("spender", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for GrantedCryptoAllowance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for GrantedCryptoAllowance {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<AccountId>>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for GrantedCryptoAllowance {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                GrantedCryptoAllowance {
                    spender: ref __self_0_0,
                    amount: ref __self_0_1,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state)
                }
            }
        }
    }
    /// A granted allowance for all the NFTs of a token for a spender relative to the owner account.
    pub struct GrantedNftAllowance {
        /// The token that the allowance pertains to.
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<TokenId>,
        /// The account ID of the spender that has been granted access to all NFTs of the owner
        #[prost(message, optional, tag = "2")]
        pub spender: ::core::option::Option<AccountId>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for GrantedNftAllowance {
        #[inline]
        fn clone(&self) -> GrantedNftAllowance {
            match *self {
                GrantedNftAllowance {
                    token_id: ref __self_0_0,
                    spender: ref __self_0_1,
                } => GrantedNftAllowance {
                    token_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    spender: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for GrantedNftAllowance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for GrantedNftAllowance {
        #[inline]
        fn eq(&self, other: &GrantedNftAllowance) -> bool {
            match *other {
                GrantedNftAllowance {
                    token_id: ref __self_1_0,
                    spender: ref __self_1_1,
                } => match *self {
                    GrantedNftAllowance {
                        token_id: ref __self_0_0,
                        spender: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GrantedNftAllowance) -> bool {
            match *other {
                GrantedNftAllowance {
                    token_id: ref __self_1_0,
                    spender: ref __self_1_1,
                } => match *self {
                    GrantedNftAllowance {
                        token_id: ref __self_0_0,
                        spender: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for GrantedNftAllowance {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.spender {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "GrantedNftAllowance";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.spender;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "spender");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .spender
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.token_id = ::core::option::Option::None;
            self.spender = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for GrantedNftAllowance {
        fn default() -> Self {
            GrantedNftAllowance {
                token_id: ::core::default::Default::default(),
                spender: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for GrantedNftAllowance {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("GrantedNftAllowance");
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.spender;
                builder.field("spender", &wrapper)
            };
            builder.finish()
        }
    }
    /// A granted allowance of fungible token transfers for a spender relative to the owner account.
    pub struct GrantedTokenAllowance {
        /// The token that the allowance pertains to.
        #[prost(message, optional, tag = "1")]
        pub token_id: ::core::option::Option<TokenId>,
        /// The account ID of the token allowance spender.
        #[prost(message, optional, tag = "2")]
        pub spender: ::core::option::Option<AccountId>,
        /// The amount of the spender's token allowance.
        #[prost(int64, tag = "3")]
        pub amount: i64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for GrantedTokenAllowance {
        #[inline]
        fn clone(&self) -> GrantedTokenAllowance {
            match *self {
                GrantedTokenAllowance {
                    token_id: ref __self_0_0,
                    spender: ref __self_0_1,
                    amount: ref __self_0_2,
                } => GrantedTokenAllowance {
                    token_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    spender: ::core::clone::Clone::clone(&(*__self_0_1)),
                    amount: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for GrantedTokenAllowance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for GrantedTokenAllowance {
        #[inline]
        fn eq(&self, other: &GrantedTokenAllowance) -> bool {
            match *other {
                GrantedTokenAllowance {
                    token_id: ref __self_1_0,
                    spender: ref __self_1_1,
                    amount: ref __self_1_2,
                } => match *self {
                    GrantedTokenAllowance {
                        token_id: ref __self_0_0,
                        spender: ref __self_0_1,
                        amount: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GrantedTokenAllowance) -> bool {
            match *other {
                GrantedTokenAllowance {
                    token_id: ref __self_1_0,
                    spender: ref __self_1_1,
                    amount: ref __self_1_2,
                } => match *self {
                    GrantedTokenAllowance {
                        token_id: ref __self_0_0,
                        spender: ref __self_0_1,
                        amount: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for GrantedTokenAllowance {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref msg) = self.token_id {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
            if let Some(ref msg) = self.spender {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
            if self.amount != 0i64 {
                ::prost::encoding::int64::encode(3u32, &self.amount, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "GrantedTokenAllowance";
            match tag {
                1u32 => {
                    let mut value = &mut self.token_id;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "token_id");
                        error
                    })
                }
                2u32 => {
                    let mut value = &mut self.spender;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "spender");
                        error
                    })
                }
                3u32 => {
                    let mut value = &mut self.amount;
                    ::prost::encoding::int64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "amount");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .token_id
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(1u32, msg))
                + self
                    .spender
                    .as_ref()
                    .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
                + if self.amount != 0i64 {
                    ::prost::encoding::int64::encoded_len(3u32, &self.amount)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.token_id = ::core::option::Option::None;
            self.spender = ::core::option::Option::None;
            self.amount = 0i64;
        }
    }
    impl ::core::default::Default for GrantedTokenAllowance {
        fn default() -> Self {
            GrantedTokenAllowance {
                token_id: ::core::default::Default::default(),
                spender: ::core::default::Default::default(),
                amount: 0i64,
            }
        }
    }
    impl ::core::fmt::Debug for GrantedTokenAllowance {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("GrantedTokenAllowance");
            let builder = {
                let wrapper = &self.token_id;
                builder.field("token_id", &wrapper)
            };
            let builder = {
                let wrapper = &self.spender;
                builder.field("spender", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.amount)
                };
                builder.field("amount", &wrapper)
            };
            builder.finish()
        }
    }
    impl ::core::marker::StructuralEq for GrantedTokenAllowance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for GrantedTokenAllowance {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<TokenId>>;
                let _: ::core::cmp::AssertParamIsEq<::core::option::Option<AccountId>>;
                let _: ::core::cmp::AssertParamIsEq<i64>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for GrantedTokenAllowance {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                GrantedTokenAllowance {
                    token_id: ref __self_0_0,
                    spender: ref __self_0_1,
                    amount: ref __self_0_2,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state)
                }
            }
        }
    }
    /// A single query, which is sent from the client to a node. This includes all possible queries. Each
    /// Query should not have more than 50 levels.
    pub struct Query {
        #[prost(
            oneof = "query::Query",
            tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 50, 51, 52, 53, 54, 55, 56, 57, 58"
        )]
        pub query: ::core::option::Option<query::Query>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Query {
        #[inline]
        fn clone(&self) -> Query {
            match *self {
                Query {
                    query: ref __self_0_0,
                } => Query {
                    query: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Query {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Query {
        #[inline]
        fn eq(&self, other: &Query) -> bool {
            match *other {
                Query {
                    query: ref __self_1_0,
                } => match *self {
                    Query {
                        query: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Query) -> bool {
            match *other {
                Query {
                    query: ref __self_1_0,
                } => match *self {
                    Query {
                        query: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for Query {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.query {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Query";
            match tag {
                1u32 | 2u32 | 3u32 | 4u32 | 5u32 | 6u32 | 7u32 | 8u32 | 9u32 | 10u32 | 11u32
                | 12u32 | 13u32 | 14u32 | 15u32 | 16u32 | 50u32 | 51u32 | 52u32 | 53u32 | 54u32
                | 55u32 | 56u32 | 57u32 | 58u32 => {
                    let mut value = &mut self.query;
                    query::Query::merge(value, tag, wire_type, buf, ctx).map_err(|mut error| {
                        error.push(STRUCT_NAME, "query");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self.query.as_ref().map_or(0, query::Query::encoded_len)
        }
        fn clear(&mut self) {
            self.query = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for Query {
        fn default() -> Self {
            Query {
                query: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for Query {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Query");
            let builder = {
                let wrapper = &self.query;
                builder.field("query", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `Query`.
    pub mod query {
        pub enum Query {
            /// Get all entities associated with a given key
            #[prost(message, tag = "1")]
            GetByKey(super::GetByKeyQuery),
            /// Get the IDs in the format used in transactions, given the format used in Solidity
            #[prost(message, tag = "2")]
            GetBySolidityId(super::GetBySolidityIdQuery),
            /// Call a function of a smart contract instance
            #[prost(message, tag = "3")]
            ContractCallLocal(super::ContractCallLocalQuery),
            /// Get information about a smart contract instance
            #[prost(message, tag = "4")]
            ContractGetInfo(super::ContractGetInfoQuery),
            /// Get runtime code used by a smart contract instance
            #[prost(message, tag = "5")]
            ContractGetBytecode(super::ContractGetBytecodeQuery),
            /// Get Records of the contract instance
            #[prost(message, tag = "6")]
            ContractGetRecords(super::ContractGetRecordsQuery),
            /// Get the current balance in a cryptocurrency account
            #[prost(message, tag = "7")]
            CryptogetAccountBalance(super::CryptoGetAccountBalanceQuery),
            /// Get all the records that currently exist for transactions involving an account
            #[prost(message, tag = "8")]
            CryptoGetAccountRecords(super::CryptoGetAccountRecordsQuery),
            /// Get all information about an account
            #[prost(message, tag = "9")]
            CryptoGetInfo(super::CryptoGetInfoQuery),
            /// Get a single livehash from a single account, if present
            #[prost(message, tag = "10")]
            CryptoGetLiveHash(super::CryptoGetLiveHashQuery),
            /// Get all the accounts that proxy stake to a given account, and how much they proxy stake
            /// (not yet implemented in the current API)
            #[prost(message, tag = "11")]
            CryptoGetProxyStakers(super::CryptoGetStakersQuery),
            /// Get the contents of a file (the bytes stored in it)
            #[prost(message, tag = "12")]
            FileGetContents(super::FileGetContentsQuery),
            /// Get information about a file, such as its expiration date
            #[prost(message, tag = "13")]
            FileGetInfo(super::FileGetInfoQuery),
            /// Get a receipt for a transaction (lasts 180 seconds)
            #[prost(message, tag = "14")]
            TransactionGetReceipt(super::TransactionGetReceiptQuery),
            /// Get a record for a transaction
            #[prost(message, tag = "15")]
            TransactionGetRecord(super::TransactionGetRecordQuery),
            /// Get a record for a transaction (lasts 180 seconds)
            #[prost(message, tag = "16")]
            TransactionGetFastRecord(super::TransactionGetFastRecordQuery),
            /// Get the parameters of and state of a consensus topic.
            #[prost(message, tag = "50")]
            ConsensusGetTopicInfo(super::ConsensusGetTopicInfoQuery),
            /// Get the versions of the HAPI protobuf and Hedera Services software deployed on the
            /// responding node.
            #[prost(message, tag = "51")]
            NetworkGetVersionInfo(super::NetworkGetVersionInfoQuery),
            /// Get all information about a token
            #[prost(message, tag = "52")]
            TokenGetInfo(super::TokenGetInfoQuery),
            /// Get all information about a scheduled entity
            #[prost(message, tag = "53")]
            ScheduleGetInfo(super::ScheduleGetInfoQuery),
            /// Get a list of NFTs associated with the account
            #[prost(message, tag = "54")]
            TokenGetAccountNftInfos(super::TokenGetAccountNftInfosQuery),
            /// Get all information about a NFT
            #[prost(message, tag = "55")]
            TokenGetNftInfo(super::TokenGetNftInfoQuery),
            /// Get a list of NFTs for the token
            #[prost(message, tag = "56")]
            TokenGetNftInfos(super::TokenGetNftInfosQuery),
            /// Gets <tt>handleTransaction</tt> times for one or more "sufficiently recent" TransactionIDs
            #[prost(message, tag = "57")]
            NetworkGetExecutionTime(super::NetworkGetExecutionTimeQuery),
            /// Gets all information about an account including allowances granted by the account
            #[prost(message, tag = "58")]
            AccountDetails(super::GetAccountDetailsQuery),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Query {
            #[inline]
            fn clone(&self) -> Query {
                match (&*self,) {
                    (&Query::GetByKey(ref __self_0),) => {
                        Query::GetByKey(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::GetBySolidityId(ref __self_0),) => {
                        Query::GetBySolidityId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::ContractCallLocal(ref __self_0),) => {
                        Query::ContractCallLocal(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::ContractGetInfo(ref __self_0),) => {
                        Query::ContractGetInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::ContractGetBytecode(ref __self_0),) => {
                        Query::ContractGetBytecode(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::ContractGetRecords(ref __self_0),) => {
                        Query::ContractGetRecords(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::CryptogetAccountBalance(ref __self_0),) => {
                        Query::CryptogetAccountBalance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::CryptoGetAccountRecords(ref __self_0),) => {
                        Query::CryptoGetAccountRecords(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::CryptoGetInfo(ref __self_0),) => {
                        Query::CryptoGetInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::CryptoGetLiveHash(ref __self_0),) => {
                        Query::CryptoGetLiveHash(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::CryptoGetProxyStakers(ref __self_0),) => {
                        Query::CryptoGetProxyStakers(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::FileGetContents(ref __self_0),) => {
                        Query::FileGetContents(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::FileGetInfo(ref __self_0),) => {
                        Query::FileGetInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::TransactionGetReceipt(ref __self_0),) => {
                        Query::TransactionGetReceipt(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::TransactionGetRecord(ref __self_0),) => {
                        Query::TransactionGetRecord(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::TransactionGetFastRecord(ref __self_0),) => {
                        Query::TransactionGetFastRecord(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::ConsensusGetTopicInfo(ref __self_0),) => {
                        Query::ConsensusGetTopicInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::NetworkGetVersionInfo(ref __self_0),) => {
                        Query::NetworkGetVersionInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::TokenGetInfo(ref __self_0),) => {
                        Query::TokenGetInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::ScheduleGetInfo(ref __self_0),) => {
                        Query::ScheduleGetInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::TokenGetAccountNftInfos(ref __self_0),) => {
                        Query::TokenGetAccountNftInfos(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::TokenGetNftInfo(ref __self_0),) => {
                        Query::TokenGetNftInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::TokenGetNftInfos(ref __self_0),) => {
                        Query::TokenGetNftInfos(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::NetworkGetExecutionTime(ref __self_0),) => {
                        Query::NetworkGetExecutionTime(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Query::AccountDetails(ref __self_0),) => {
                        Query::AccountDetails(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Query {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Query {
            #[inline]
            fn eq(&self, other: &Query) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Query::GetByKey(ref __self_0), &Query::GetByKey(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Query::GetBySolidityId(ref __self_0),
                                &Query::GetBySolidityId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::ContractCallLocal(ref __self_0),
                                &Query::ContractCallLocal(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::ContractGetInfo(ref __self_0),
                                &Query::ContractGetInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::ContractGetBytecode(ref __self_0),
                                &Query::ContractGetBytecode(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::ContractGetRecords(ref __self_0),
                                &Query::ContractGetRecords(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::CryptogetAccountBalance(ref __self_0),
                                &Query::CryptogetAccountBalance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::CryptoGetAccountRecords(ref __self_0),
                                &Query::CryptoGetAccountRecords(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::CryptoGetInfo(ref __self_0),
                                &Query::CryptoGetInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::CryptoGetLiveHash(ref __self_0),
                                &Query::CryptoGetLiveHash(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::CryptoGetProxyStakers(ref __self_0),
                                &Query::CryptoGetProxyStakers(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::FileGetContents(ref __self_0),
                                &Query::FileGetContents(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::FileGetInfo(ref __self_0),
                                &Query::FileGetInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::TransactionGetReceipt(ref __self_0),
                                &Query::TransactionGetReceipt(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::TransactionGetRecord(ref __self_0),
                                &Query::TransactionGetRecord(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::TransactionGetFastRecord(ref __self_0),
                                &Query::TransactionGetFastRecord(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::ConsensusGetTopicInfo(ref __self_0),
                                &Query::ConsensusGetTopicInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::NetworkGetVersionInfo(ref __self_0),
                                &Query::NetworkGetVersionInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::TokenGetInfo(ref __self_0),
                                &Query::TokenGetInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::ScheduleGetInfo(ref __self_0),
                                &Query::ScheduleGetInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::TokenGetAccountNftInfos(ref __self_0),
                                &Query::TokenGetAccountNftInfos(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::TokenGetNftInfo(ref __self_0),
                                &Query::TokenGetNftInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::TokenGetNftInfos(ref __self_0),
                                &Query::TokenGetNftInfos(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::NetworkGetExecutionTime(ref __self_0),
                                &Query::NetworkGetExecutionTime(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Query::AccountDetails(ref __self_0),
                                &Query::AccountDetails(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Query) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Query::GetByKey(ref __self_0), &Query::GetByKey(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Query::GetBySolidityId(ref __self_0),
                                &Query::GetBySolidityId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::ContractCallLocal(ref __self_0),
                                &Query::ContractCallLocal(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::ContractGetInfo(ref __self_0),
                                &Query::ContractGetInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::ContractGetBytecode(ref __self_0),
                                &Query::ContractGetBytecode(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::ContractGetRecords(ref __self_0),
                                &Query::ContractGetRecords(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::CryptogetAccountBalance(ref __self_0),
                                &Query::CryptogetAccountBalance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::CryptoGetAccountRecords(ref __self_0),
                                &Query::CryptoGetAccountRecords(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::CryptoGetInfo(ref __self_0),
                                &Query::CryptoGetInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::CryptoGetLiveHash(ref __self_0),
                                &Query::CryptoGetLiveHash(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::CryptoGetProxyStakers(ref __self_0),
                                &Query::CryptoGetProxyStakers(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::FileGetContents(ref __self_0),
                                &Query::FileGetContents(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::FileGetInfo(ref __self_0),
                                &Query::FileGetInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::TransactionGetReceipt(ref __self_0),
                                &Query::TransactionGetReceipt(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::TransactionGetRecord(ref __self_0),
                                &Query::TransactionGetRecord(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::TransactionGetFastRecord(ref __self_0),
                                &Query::TransactionGetFastRecord(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::ConsensusGetTopicInfo(ref __self_0),
                                &Query::ConsensusGetTopicInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::NetworkGetVersionInfo(ref __self_0),
                                &Query::NetworkGetVersionInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::TokenGetInfo(ref __self_0),
                                &Query::TokenGetInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::ScheduleGetInfo(ref __self_0),
                                &Query::ScheduleGetInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::TokenGetAccountNftInfos(ref __self_0),
                                &Query::TokenGetAccountNftInfos(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::TokenGetNftInfo(ref __self_0),
                                &Query::TokenGetNftInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::TokenGetNftInfos(ref __self_0),
                                &Query::TokenGetNftInfos(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::NetworkGetExecutionTime(ref __self_0),
                                &Query::NetworkGetExecutionTime(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Query::AccountDetails(ref __self_0),
                                &Query::AccountDetails(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Query {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Query::GetByKey(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                    Query::GetBySolidityId(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    Query::ContractCallLocal(ref value) => {
                        ::prost::encoding::message::encode(3u32, &*value, buf);
                    }
                    Query::ContractGetInfo(ref value) => {
                        ::prost::encoding::message::encode(4u32, &*value, buf);
                    }
                    Query::ContractGetBytecode(ref value) => {
                        ::prost::encoding::message::encode(5u32, &*value, buf);
                    }
                    Query::ContractGetRecords(ref value) => {
                        ::prost::encoding::message::encode(6u32, &*value, buf);
                    }
                    Query::CryptogetAccountBalance(ref value) => {
                        ::prost::encoding::message::encode(7u32, &*value, buf);
                    }
                    Query::CryptoGetAccountRecords(ref value) => {
                        ::prost::encoding::message::encode(8u32, &*value, buf);
                    }
                    Query::CryptoGetInfo(ref value) => {
                        ::prost::encoding::message::encode(9u32, &*value, buf);
                    }
                    Query::CryptoGetLiveHash(ref value) => {
                        ::prost::encoding::message::encode(10u32, &*value, buf);
                    }
                    Query::CryptoGetProxyStakers(ref value) => {
                        ::prost::encoding::message::encode(11u32, &*value, buf);
                    }
                    Query::FileGetContents(ref value) => {
                        ::prost::encoding::message::encode(12u32, &*value, buf);
                    }
                    Query::FileGetInfo(ref value) => {
                        ::prost::encoding::message::encode(13u32, &*value, buf);
                    }
                    Query::TransactionGetReceipt(ref value) => {
                        ::prost::encoding::message::encode(14u32, &*value, buf);
                    }
                    Query::TransactionGetRecord(ref value) => {
                        ::prost::encoding::message::encode(15u32, &*value, buf);
                    }
                    Query::TransactionGetFastRecord(ref value) => {
                        ::prost::encoding::message::encode(16u32, &*value, buf);
                    }
                    Query::ConsensusGetTopicInfo(ref value) => {
                        ::prost::encoding::message::encode(50u32, &*value, buf);
                    }
                    Query::NetworkGetVersionInfo(ref value) => {
                        ::prost::encoding::message::encode(51u32, &*value, buf);
                    }
                    Query::TokenGetInfo(ref value) => {
                        ::prost::encoding::message::encode(52u32, &*value, buf);
                    }
                    Query::ScheduleGetInfo(ref value) => {
                        ::prost::encoding::message::encode(53u32, &*value, buf);
                    }
                    Query::TokenGetAccountNftInfos(ref value) => {
                        ::prost::encoding::message::encode(54u32, &*value, buf);
                    }
                    Query::TokenGetNftInfo(ref value) => {
                        ::prost::encoding::message::encode(55u32, &*value, buf);
                    }
                    Query::TokenGetNftInfos(ref value) => {
                        ::prost::encoding::message::encode(56u32, &*value, buf);
                    }
                    Query::NetworkGetExecutionTime(ref value) => {
                        ::prost::encoding::message::encode(57u32, &*value, buf);
                    }
                    Query::AccountDetails(ref value) => {
                        ::prost::encoding::message::encode(58u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Query>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => match field {
                        ::core::option::Option::Some(Query::GetByKey(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field =
                                        ::core::option::Option::Some(Query::GetByKey(owned_value))
                                },
                            )
                        }
                    },
                    2u32 => match field {
                        ::core::option::Option::Some(Query::GetBySolidityId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::GetBySolidityId(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    3u32 => match field {
                        ::core::option::Option::Some(Query::ContractCallLocal(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::ContractCallLocal(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    4u32 => match field {
                        ::core::option::Option::Some(Query::ContractGetInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::ContractGetInfo(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    5u32 => match field {
                        ::core::option::Option::Some(Query::ContractGetBytecode(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::ContractGetBytecode(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    6u32 => match field {
                        ::core::option::Option::Some(Query::ContractGetRecords(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::ContractGetRecords(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    7u32 => match field {
                        ::core::option::Option::Some(Query::CryptogetAccountBalance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::CryptogetAccountBalance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    8u32 => match field {
                        ::core::option::Option::Some(Query::CryptoGetAccountRecords(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::CryptoGetAccountRecords(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    9u32 => match field {
                        ::core::option::Option::Some(Query::CryptoGetInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::CryptoGetInfo(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    10u32 => match field {
                        ::core::option::Option::Some(Query::CryptoGetLiveHash(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::CryptoGetLiveHash(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    11u32 => match field {
                        ::core::option::Option::Some(Query::CryptoGetProxyStakers(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::CryptoGetProxyStakers(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    12u32 => match field {
                        ::core::option::Option::Some(Query::FileGetContents(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::FileGetContents(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    13u32 => match field {
                        ::core::option::Option::Some(Query::FileGetInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::FileGetInfo(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    14u32 => match field {
                        ::core::option::Option::Some(Query::TransactionGetReceipt(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::TransactionGetReceipt(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    15u32 => match field {
                        ::core::option::Option::Some(Query::TransactionGetRecord(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::TransactionGetRecord(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    16u32 => match field {
                        ::core::option::Option::Some(Query::TransactionGetFastRecord(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::TransactionGetFastRecord(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    50u32 => match field {
                        ::core::option::Option::Some(Query::ConsensusGetTopicInfo(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::ConsensusGetTopicInfo(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    51u32 => match field {
                        ::core::option::Option::Some(Query::NetworkGetVersionInfo(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::NetworkGetVersionInfo(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    52u32 => match field {
                        ::core::option::Option::Some(Query::TokenGetInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::TokenGetInfo(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    53u32 => match field {
                        ::core::option::Option::Some(Query::ScheduleGetInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::ScheduleGetInfo(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    54u32 => match field {
                        ::core::option::Option::Some(Query::TokenGetAccountNftInfos(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::TokenGetAccountNftInfos(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    55u32 => match field {
                        ::core::option::Option::Some(Query::TokenGetNftInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::TokenGetNftInfo(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    56u32 => match field {
                        ::core::option::Option::Some(Query::TokenGetNftInfos(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::TokenGetNftInfos(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    57u32 => match field {
                        ::core::option::Option::Some(Query::NetworkGetExecutionTime(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Query::NetworkGetExecutionTime(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    58u32 => match field {
                        ::core::option::Option::Some(Query::AccountDetails(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Query::AccountDetails(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Query tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Query::GetByKey(ref value) => {
                        ::prost::encoding::message::encoded_len(1u32, &*value)
                    }
                    Query::GetBySolidityId(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                    Query::ContractCallLocal(ref value) => {
                        ::prost::encoding::message::encoded_len(3u32, &*value)
                    }
                    Query::ContractGetInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(4u32, &*value)
                    }
                    Query::ContractGetBytecode(ref value) => {
                        ::prost::encoding::message::encoded_len(5u32, &*value)
                    }
                    Query::ContractGetRecords(ref value) => {
                        ::prost::encoding::message::encoded_len(6u32, &*value)
                    }
                    Query::CryptogetAccountBalance(ref value) => {
                        ::prost::encoding::message::encoded_len(7u32, &*value)
                    }
                    Query::CryptoGetAccountRecords(ref value) => {
                        ::prost::encoding::message::encoded_len(8u32, &*value)
                    }
                    Query::CryptoGetInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(9u32, &*value)
                    }
                    Query::CryptoGetLiveHash(ref value) => {
                        ::prost::encoding::message::encoded_len(10u32, &*value)
                    }
                    Query::CryptoGetProxyStakers(ref value) => {
                        ::prost::encoding::message::encoded_len(11u32, &*value)
                    }
                    Query::FileGetContents(ref value) => {
                        ::prost::encoding::message::encoded_len(12u32, &*value)
                    }
                    Query::FileGetInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(13u32, &*value)
                    }
                    Query::TransactionGetReceipt(ref value) => {
                        ::prost::encoding::message::encoded_len(14u32, &*value)
                    }
                    Query::TransactionGetRecord(ref value) => {
                        ::prost::encoding::message::encoded_len(15u32, &*value)
                    }
                    Query::TransactionGetFastRecord(ref value) => {
                        ::prost::encoding::message::encoded_len(16u32, &*value)
                    }
                    Query::ConsensusGetTopicInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(50u32, &*value)
                    }
                    Query::NetworkGetVersionInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(51u32, &*value)
                    }
                    Query::TokenGetInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(52u32, &*value)
                    }
                    Query::ScheduleGetInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(53u32, &*value)
                    }
                    Query::TokenGetAccountNftInfos(ref value) => {
                        ::prost::encoding::message::encoded_len(54u32, &*value)
                    }
                    Query::TokenGetNftInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(55u32, &*value)
                    }
                    Query::TokenGetNftInfos(ref value) => {
                        ::prost::encoding::message::encoded_len(56u32, &*value)
                    }
                    Query::NetworkGetExecutionTime(ref value) => {
                        ::prost::encoding::message::encoded_len(57u32, &*value)
                    }
                    Query::AccountDetails(ref value) => {
                        ::prost::encoding::message::encoded_len(58u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Query {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Query::GetByKey(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("GetByKey").field(&wrapper).finish()
                    }
                    Query::GetBySolidityId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("GetBySolidityId").field(&wrapper).finish()
                    }
                    Query::ContractCallLocal(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractCallLocal").field(&wrapper).finish()
                    }
                    Query::ContractGetInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractGetInfo").field(&wrapper).finish()
                    }
                    Query::ContractGetBytecode(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractGetBytecode")
                            .field(&wrapper)
                            .finish()
                    }
                    Query::ContractGetRecords(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractGetRecords").field(&wrapper).finish()
                    }
                    Query::CryptogetAccountBalance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptogetAccountBalance")
                            .field(&wrapper)
                            .finish()
                    }
                    Query::CryptoGetAccountRecords(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoGetAccountRecords")
                            .field(&wrapper)
                            .finish()
                    }
                    Query::CryptoGetInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoGetInfo").field(&wrapper).finish()
                    }
                    Query::CryptoGetLiveHash(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoGetLiveHash").field(&wrapper).finish()
                    }
                    Query::CryptoGetProxyStakers(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoGetProxyStakers")
                            .field(&wrapper)
                            .finish()
                    }
                    Query::FileGetContents(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileGetContents").field(&wrapper).finish()
                    }
                    Query::FileGetInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileGetInfo").field(&wrapper).finish()
                    }
                    Query::TransactionGetReceipt(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TransactionGetReceipt")
                            .field(&wrapper)
                            .finish()
                    }
                    Query::TransactionGetRecord(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TransactionGetRecord")
                            .field(&wrapper)
                            .finish()
                    }
                    Query::TransactionGetFastRecord(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TransactionGetFastRecord")
                            .field(&wrapper)
                            .finish()
                    }
                    Query::ConsensusGetTopicInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ConsensusGetTopicInfo")
                            .field(&wrapper)
                            .finish()
                    }
                    Query::NetworkGetVersionInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("NetworkGetVersionInfo")
                            .field(&wrapper)
                            .finish()
                    }
                    Query::TokenGetInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenGetInfo").field(&wrapper).finish()
                    }
                    Query::ScheduleGetInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ScheduleGetInfo").field(&wrapper).finish()
                    }
                    Query::TokenGetAccountNftInfos(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenGetAccountNftInfos")
                            .field(&wrapper)
                            .finish()
                    }
                    Query::TokenGetNftInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenGetNftInfo").field(&wrapper).finish()
                    }
                    Query::TokenGetNftInfos(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenGetNftInfos").field(&wrapper).finish()
                    }
                    Query::NetworkGetExecutionTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("NetworkGetExecutionTime")
                            .field(&wrapper)
                            .finish()
                    }
                    Query::AccountDetails(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("AccountDetails").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// A single response, which is returned from the node to the client, after the client sent the node
    /// a query. This includes all responses.
    pub struct Response {
        #[prost(
            oneof = "response::Response",
            tags = "1, 2, 3, 5, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 150, 151, 152, 153, 154, 155, 156, 157, 158"
        )]
        pub response: ::core::option::Option<response::Response>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Response {
        #[inline]
        fn clone(&self) -> Response {
            match *self {
                Response {
                    response: ref __self_0_0,
                } => Response {
                    response: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Response {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Response {
        #[inline]
        fn eq(&self, other: &Response) -> bool {
            match *other {
                Response {
                    response: ref __self_1_0,
                } => match *self {
                    Response {
                        response: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Response) -> bool {
            match *other {
                Response {
                    response: ref __self_1_0,
                } => match *self {
                    Response {
                        response: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for Response {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if let Some(ref oneof) = self.response {
                oneof.encode(buf)
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "Response";
            match tag {
                1u32 | 2u32 | 3u32 | 5u32 | 4u32 | 6u32 | 7u32 | 8u32 | 9u32 | 10u32 | 11u32
                | 12u32 | 13u32 | 14u32 | 15u32 | 16u32 | 150u32 | 151u32 | 152u32 | 153u32
                | 154u32 | 155u32 | 156u32 | 157u32 | 158u32 => {
                    let mut value = &mut self.response;
                    response::Response::merge(value, tag, wire_type, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "response");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + self
                .response
                .as_ref()
                .map_or(0, response::Response::encoded_len)
        }
        fn clear(&mut self) {
            self.response = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for Response {
        fn default() -> Self {
            Response {
                response: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for Response {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("Response");
            let builder = {
                let wrapper = &self.response;
                builder.field("response", &wrapper)
            };
            builder.finish()
        }
    }
    /// Nested message and enum types in `Response`.
    pub mod response {
        pub enum Response {
            /// Get all entities associated with a given key
            #[prost(message, tag = "1")]
            GetByKey(super::GetByKeyResponse),
            /// Get the IDs in the format used in transactions, given the format used in Solidity
            #[prost(message, tag = "2")]
            GetBySolidityId(super::GetBySolidityIdResponse),
            /// Response to call a function of a smart contract instance
            #[prost(message, tag = "3")]
            ContractCallLocal(super::ContractCallLocalResponse),
            /// Get the runtime code for a smart contract instance
            #[prost(message, tag = "5")]
            ContractGetBytecodeResponse(super::ContractGetBytecodeResponse),
            /// Get information about a smart contract instance
            #[prost(message, tag = "4")]
            ContractGetInfo(super::ContractGetInfoResponse),
            /// Get all existing records for a smart contract instance
            #[prost(message, tag = "6")]
            ContractGetRecordsResponse(super::ContractGetRecordsResponse),
            /// Get the current balance in a cryptocurrency account
            #[prost(message, tag = "7")]
            CryptogetAccountBalance(super::CryptoGetAccountBalanceResponse),
            /// Get all the records that currently exist for transactions involving an account
            #[prost(message, tag = "8")]
            CryptoGetAccountRecords(super::CryptoGetAccountRecordsResponse),
            /// Get all information about an account
            #[prost(message, tag = "9")]
            CryptoGetInfo(super::CryptoGetInfoResponse),
            /// Contains a livehash associated to an account
            #[prost(message, tag = "10")]
            CryptoGetLiveHash(super::CryptoGetLiveHashResponse),
            /// Get all the accounts that proxy stake to a given account, and how much they proxy stake
            #[prost(message, tag = "11")]
            CryptoGetProxyStakers(super::CryptoGetStakersResponse),
            /// Get the contents of a file (the bytes stored in it)
            #[prost(message, tag = "12")]
            FileGetContents(super::FileGetContentsResponse),
            /// Get information about a file, such as its expiration date
            #[prost(message, tag = "13")]
            FileGetInfo(super::FileGetInfoResponse),
            /// Get a receipt for a transaction
            #[prost(message, tag = "14")]
            TransactionGetReceipt(super::TransactionGetReceiptResponse),
            /// Get a record for a transaction
            #[prost(message, tag = "15")]
            TransactionGetRecord(super::TransactionGetRecordResponse),
            /// Get a record for a transaction (lasts 180 seconds)
            #[prost(message, tag = "16")]
            TransactionGetFastRecord(super::TransactionGetFastRecordResponse),
            /// Parameters of and state of a consensus topic..
            #[prost(message, tag = "150")]
            ConsensusGetTopicInfo(super::ConsensusGetTopicInfoResponse),
            /// Semantic versions of Hedera Services and HAPI proto
            #[prost(message, tag = "151")]
            NetworkGetVersionInfo(super::NetworkGetVersionInfoResponse),
            /// Get all information about a token
            #[prost(message, tag = "152")]
            TokenGetInfo(super::TokenGetInfoResponse),
            /// Get all information about a schedule entity
            #[prost(message, tag = "153")]
            ScheduleGetInfo(super::ScheduleGetInfoResponse),
            /// A list of the NFTs associated with the account
            #[prost(message, tag = "154")]
            TokenGetAccountNftInfos(super::TokenGetAccountNftInfosResponse),
            /// All information about an NFT
            #[prost(message, tag = "155")]
            TokenGetNftInfo(super::TokenGetNftInfoResponse),
            /// A list of the NFTs for the token
            #[prost(message, tag = "156")]
            TokenGetNftInfos(super::TokenGetNftInfosResponse),
            /// Execution times of "sufficiently recent" transactions
            #[prost(message, tag = "157")]
            NetworkGetExecutionTime(super::NetworkGetExecutionTimeResponse),
            /// Gets all information about an account including allowances granted by the account
            #[prost(message, tag = "158")]
            AccountDetails(super::GetAccountDetailsResponse),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Response {
            #[inline]
            fn clone(&self) -> Response {
                match (&*self,) {
                    (&Response::GetByKey(ref __self_0),) => {
                        Response::GetByKey(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::GetBySolidityId(ref __self_0),) => {
                        Response::GetBySolidityId(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::ContractCallLocal(ref __self_0),) => {
                        Response::ContractCallLocal(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::ContractGetBytecodeResponse(ref __self_0),) => {
                        Response::ContractGetBytecodeResponse(::core::clone::Clone::clone(
                            &(*__self_0),
                        ))
                    }
                    (&Response::ContractGetInfo(ref __self_0),) => {
                        Response::ContractGetInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::ContractGetRecordsResponse(ref __self_0),) => {
                        Response::ContractGetRecordsResponse(::core::clone::Clone::clone(
                            &(*__self_0),
                        ))
                    }
                    (&Response::CryptogetAccountBalance(ref __self_0),) => {
                        Response::CryptogetAccountBalance(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::CryptoGetAccountRecords(ref __self_0),) => {
                        Response::CryptoGetAccountRecords(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::CryptoGetInfo(ref __self_0),) => {
                        Response::CryptoGetInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::CryptoGetLiveHash(ref __self_0),) => {
                        Response::CryptoGetLiveHash(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::CryptoGetProxyStakers(ref __self_0),) => {
                        Response::CryptoGetProxyStakers(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::FileGetContents(ref __self_0),) => {
                        Response::FileGetContents(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::FileGetInfo(ref __self_0),) => {
                        Response::FileGetInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::TransactionGetReceipt(ref __self_0),) => {
                        Response::TransactionGetReceipt(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::TransactionGetRecord(ref __self_0),) => {
                        Response::TransactionGetRecord(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::TransactionGetFastRecord(ref __self_0),) => {
                        Response::TransactionGetFastRecord(::core::clone::Clone::clone(
                            &(*__self_0),
                        ))
                    }
                    (&Response::ConsensusGetTopicInfo(ref __self_0),) => {
                        Response::ConsensusGetTopicInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::NetworkGetVersionInfo(ref __self_0),) => {
                        Response::NetworkGetVersionInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::TokenGetInfo(ref __self_0),) => {
                        Response::TokenGetInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::ScheduleGetInfo(ref __self_0),) => {
                        Response::ScheduleGetInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::TokenGetAccountNftInfos(ref __self_0),) => {
                        Response::TokenGetAccountNftInfos(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::TokenGetNftInfo(ref __self_0),) => {
                        Response::TokenGetNftInfo(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::TokenGetNftInfos(ref __self_0),) => {
                        Response::TokenGetNftInfos(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::NetworkGetExecutionTime(ref __self_0),) => {
                        Response::NetworkGetExecutionTime(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Response::AccountDetails(ref __self_0),) => {
                        Response::AccountDetails(::core::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Response {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Response {
            #[inline]
            fn eq(&self, other: &Response) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Response::GetByKey(ref __self_0),
                                &Response::GetByKey(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::GetBySolidityId(ref __self_0),
                                &Response::GetBySolidityId(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::ContractCallLocal(ref __self_0),
                                &Response::ContractCallLocal(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::ContractGetBytecodeResponse(ref __self_0),
                                &Response::ContractGetBytecodeResponse(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::ContractGetInfo(ref __self_0),
                                &Response::ContractGetInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::ContractGetRecordsResponse(ref __self_0),
                                &Response::ContractGetRecordsResponse(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::CryptogetAccountBalance(ref __self_0),
                                &Response::CryptogetAccountBalance(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::CryptoGetAccountRecords(ref __self_0),
                                &Response::CryptoGetAccountRecords(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::CryptoGetInfo(ref __self_0),
                                &Response::CryptoGetInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::CryptoGetLiveHash(ref __self_0),
                                &Response::CryptoGetLiveHash(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::CryptoGetProxyStakers(ref __self_0),
                                &Response::CryptoGetProxyStakers(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::FileGetContents(ref __self_0),
                                &Response::FileGetContents(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::FileGetInfo(ref __self_0),
                                &Response::FileGetInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::TransactionGetReceipt(ref __self_0),
                                &Response::TransactionGetReceipt(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::TransactionGetRecord(ref __self_0),
                                &Response::TransactionGetRecord(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::TransactionGetFastRecord(ref __self_0),
                                &Response::TransactionGetFastRecord(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::ConsensusGetTopicInfo(ref __self_0),
                                &Response::ConsensusGetTopicInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::NetworkGetVersionInfo(ref __self_0),
                                &Response::NetworkGetVersionInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::TokenGetInfo(ref __self_0),
                                &Response::TokenGetInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::ScheduleGetInfo(ref __self_0),
                                &Response::ScheduleGetInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::TokenGetAccountNftInfos(ref __self_0),
                                &Response::TokenGetAccountNftInfos(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::TokenGetNftInfo(ref __self_0),
                                &Response::TokenGetNftInfo(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::TokenGetNftInfos(ref __self_0),
                                &Response::TokenGetNftInfos(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::NetworkGetExecutionTime(ref __self_0),
                                &Response::NetworkGetExecutionTime(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &Response::AccountDetails(ref __self_0),
                                &Response::AccountDetails(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Response) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Response::GetByKey(ref __self_0),
                                &Response::GetByKey(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::GetBySolidityId(ref __self_0),
                                &Response::GetBySolidityId(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::ContractCallLocal(ref __self_0),
                                &Response::ContractCallLocal(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::ContractGetBytecodeResponse(ref __self_0),
                                &Response::ContractGetBytecodeResponse(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::ContractGetInfo(ref __self_0),
                                &Response::ContractGetInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::ContractGetRecordsResponse(ref __self_0),
                                &Response::ContractGetRecordsResponse(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::CryptogetAccountBalance(ref __self_0),
                                &Response::CryptogetAccountBalance(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::CryptoGetAccountRecords(ref __self_0),
                                &Response::CryptoGetAccountRecords(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::CryptoGetInfo(ref __self_0),
                                &Response::CryptoGetInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::CryptoGetLiveHash(ref __self_0),
                                &Response::CryptoGetLiveHash(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::CryptoGetProxyStakers(ref __self_0),
                                &Response::CryptoGetProxyStakers(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::FileGetContents(ref __self_0),
                                &Response::FileGetContents(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::FileGetInfo(ref __self_0),
                                &Response::FileGetInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::TransactionGetReceipt(ref __self_0),
                                &Response::TransactionGetReceipt(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::TransactionGetRecord(ref __self_0),
                                &Response::TransactionGetRecord(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::TransactionGetFastRecord(ref __self_0),
                                &Response::TransactionGetFastRecord(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::ConsensusGetTopicInfo(ref __self_0),
                                &Response::ConsensusGetTopicInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::NetworkGetVersionInfo(ref __self_0),
                                &Response::NetworkGetVersionInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::TokenGetInfo(ref __self_0),
                                &Response::TokenGetInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::ScheduleGetInfo(ref __self_0),
                                &Response::ScheduleGetInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::TokenGetAccountNftInfos(ref __self_0),
                                &Response::TokenGetAccountNftInfos(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::TokenGetNftInfo(ref __self_0),
                                &Response::TokenGetNftInfo(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::TokenGetNftInfos(ref __self_0),
                                &Response::TokenGetNftInfos(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::NetworkGetExecutionTime(ref __self_0),
                                &Response::NetworkGetExecutionTime(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &Response::AccountDetails(ref __self_0),
                                &Response::AccountDetails(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Response {
            pub fn encode<B>(&self, buf: &mut B)
            where
                B: ::prost::bytes::BufMut,
            {
                match *self {
                    Response::GetByKey(ref value) => {
                        ::prost::encoding::message::encode(1u32, &*value, buf);
                    }
                    Response::GetBySolidityId(ref value) => {
                        ::prost::encoding::message::encode(2u32, &*value, buf);
                    }
                    Response::ContractCallLocal(ref value) => {
                        ::prost::encoding::message::encode(3u32, &*value, buf);
                    }
                    Response::ContractGetBytecodeResponse(ref value) => {
                        ::prost::encoding::message::encode(5u32, &*value, buf);
                    }
                    Response::ContractGetInfo(ref value) => {
                        ::prost::encoding::message::encode(4u32, &*value, buf);
                    }
                    Response::ContractGetRecordsResponse(ref value) => {
                        ::prost::encoding::message::encode(6u32, &*value, buf);
                    }
                    Response::CryptogetAccountBalance(ref value) => {
                        ::prost::encoding::message::encode(7u32, &*value, buf);
                    }
                    Response::CryptoGetAccountRecords(ref value) => {
                        ::prost::encoding::message::encode(8u32, &*value, buf);
                    }
                    Response::CryptoGetInfo(ref value) => {
                        ::prost::encoding::message::encode(9u32, &*value, buf);
                    }
                    Response::CryptoGetLiveHash(ref value) => {
                        ::prost::encoding::message::encode(10u32, &*value, buf);
                    }
                    Response::CryptoGetProxyStakers(ref value) => {
                        ::prost::encoding::message::encode(11u32, &*value, buf);
                    }
                    Response::FileGetContents(ref value) => {
                        ::prost::encoding::message::encode(12u32, &*value, buf);
                    }
                    Response::FileGetInfo(ref value) => {
                        ::prost::encoding::message::encode(13u32, &*value, buf);
                    }
                    Response::TransactionGetReceipt(ref value) => {
                        ::prost::encoding::message::encode(14u32, &*value, buf);
                    }
                    Response::TransactionGetRecord(ref value) => {
                        ::prost::encoding::message::encode(15u32, &*value, buf);
                    }
                    Response::TransactionGetFastRecord(ref value) => {
                        ::prost::encoding::message::encode(16u32, &*value, buf);
                    }
                    Response::ConsensusGetTopicInfo(ref value) => {
                        ::prost::encoding::message::encode(150u32, &*value, buf);
                    }
                    Response::NetworkGetVersionInfo(ref value) => {
                        ::prost::encoding::message::encode(151u32, &*value, buf);
                    }
                    Response::TokenGetInfo(ref value) => {
                        ::prost::encoding::message::encode(152u32, &*value, buf);
                    }
                    Response::ScheduleGetInfo(ref value) => {
                        ::prost::encoding::message::encode(153u32, &*value, buf);
                    }
                    Response::TokenGetAccountNftInfos(ref value) => {
                        ::prost::encoding::message::encode(154u32, &*value, buf);
                    }
                    Response::TokenGetNftInfo(ref value) => {
                        ::prost::encoding::message::encode(155u32, &*value, buf);
                    }
                    Response::TokenGetNftInfos(ref value) => {
                        ::prost::encoding::message::encode(156u32, &*value, buf);
                    }
                    Response::NetworkGetExecutionTime(ref value) => {
                        ::prost::encoding::message::encode(157u32, &*value, buf);
                    }
                    Response::AccountDetails(ref value) => {
                        ::prost::encoding::message::encode(158u32, &*value, buf);
                    }
                }
            }
            pub fn merge<B>(
                field: &mut ::core::option::Option<Response>,
                tag: u32,
                wire_type: ::prost::encoding::WireType,
                buf: &mut B,
                ctx: ::prost::encoding::DecodeContext,
            ) -> ::core::result::Result<(), ::prost::DecodeError>
            where
                B: ::prost::bytes::Buf,
            {
                match tag {
                    1u32 => match field {
                        ::core::option::Option::Some(Response::GetByKey(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Response::GetByKey(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    2u32 => match field {
                        ::core::option::Option::Some(Response::GetBySolidityId(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::GetBySolidityId(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    3u32 => match field {
                        ::core::option::Option::Some(Response::ContractCallLocal(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::ContractCallLocal(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    5u32 => match field {
                        ::core::option::Option::Some(Response::ContractGetBytecodeResponse(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::ContractGetBytecodeResponse(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    4u32 => match field {
                        ::core::option::Option::Some(Response::ContractGetInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::ContractGetInfo(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    6u32 => match field {
                        ::core::option::Option::Some(Response::ContractGetRecordsResponse(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::ContractGetRecordsResponse(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    7u32 => match field {
                        ::core::option::Option::Some(Response::CryptogetAccountBalance(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::CryptogetAccountBalance(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    8u32 => match field {
                        ::core::option::Option::Some(Response::CryptoGetAccountRecords(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::CryptoGetAccountRecords(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    9u32 => match field {
                        ::core::option::Option::Some(Response::CryptoGetInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Response::CryptoGetInfo(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    10u32 => match field {
                        ::core::option::Option::Some(Response::CryptoGetLiveHash(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::CryptoGetLiveHash(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    11u32 => match field {
                        ::core::option::Option::Some(Response::CryptoGetProxyStakers(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::CryptoGetProxyStakers(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    12u32 => match field {
                        ::core::option::Option::Some(Response::FileGetContents(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::FileGetContents(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    13u32 => match field {
                        ::core::option::Option::Some(Response::FileGetInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Response::FileGetInfo(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    14u32 => match field {
                        ::core::option::Option::Some(Response::TransactionGetReceipt(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::TransactionGetReceipt(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    15u32 => match field {
                        ::core::option::Option::Some(Response::TransactionGetRecord(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::TransactionGetRecord(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    16u32 => match field {
                        ::core::option::Option::Some(Response::TransactionGetFastRecord(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::TransactionGetFastRecord(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    150u32 => match field {
                        ::core::option::Option::Some(Response::ConsensusGetTopicInfo(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::ConsensusGetTopicInfo(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    151u32 => match field {
                        ::core::option::Option::Some(Response::NetworkGetVersionInfo(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::NetworkGetVersionInfo(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    152u32 => match field {
                        ::core::option::Option::Some(Response::TokenGetInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Response::TokenGetInfo(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    153u32 => match field {
                        ::core::option::Option::Some(Response::ScheduleGetInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::ScheduleGetInfo(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    154u32 => match field {
                        ::core::option::Option::Some(Response::TokenGetAccountNftInfos(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::TokenGetAccountNftInfos(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    155u32 => match field {
                        ::core::option::Option::Some(Response::TokenGetNftInfo(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::TokenGetNftInfo(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    156u32 => match field {
                        ::core::option::Option::Some(Response::TokenGetNftInfos(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::TokenGetNftInfos(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    157u32 => match field {
                        ::core::option::Option::Some(Response::NetworkGetExecutionTime(
                            ref mut value,
                        )) => ::prost::encoding::message::merge(wire_type, value, buf, ctx),
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(
                                        Response::NetworkGetExecutionTime(owned_value),
                                    )
                                },
                            )
                        }
                    },
                    158u32 => match field {
                        ::core::option::Option::Some(Response::AccountDetails(ref mut value)) => {
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx)
                        }
                        _ => {
                            let mut owned_value = ::core::default::Default::default();
                            let value = &mut owned_value;
                            ::prost::encoding::message::merge(wire_type, value, buf, ctx).map(
                                |_| {
                                    *field = ::core::option::Option::Some(Response::AccountDetails(
                                        owned_value,
                                    ))
                                },
                            )
                        }
                    },
                    _ => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: invalid Response tag: "],
                        &[::core::fmt::ArgumentV1::new_display(&tag)],
                    )),
                }
            }
            #[inline]
            pub fn encoded_len(&self) -> usize {
                match *self {
                    Response::GetByKey(ref value) => {
                        ::prost::encoding::message::encoded_len(1u32, &*value)
                    }
                    Response::GetBySolidityId(ref value) => {
                        ::prost::encoding::message::encoded_len(2u32, &*value)
                    }
                    Response::ContractCallLocal(ref value) => {
                        ::prost::encoding::message::encoded_len(3u32, &*value)
                    }
                    Response::ContractGetBytecodeResponse(ref value) => {
                        ::prost::encoding::message::encoded_len(5u32, &*value)
                    }
                    Response::ContractGetInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(4u32, &*value)
                    }
                    Response::ContractGetRecordsResponse(ref value) => {
                        ::prost::encoding::message::encoded_len(6u32, &*value)
                    }
                    Response::CryptogetAccountBalance(ref value) => {
                        ::prost::encoding::message::encoded_len(7u32, &*value)
                    }
                    Response::CryptoGetAccountRecords(ref value) => {
                        ::prost::encoding::message::encoded_len(8u32, &*value)
                    }
                    Response::CryptoGetInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(9u32, &*value)
                    }
                    Response::CryptoGetLiveHash(ref value) => {
                        ::prost::encoding::message::encoded_len(10u32, &*value)
                    }
                    Response::CryptoGetProxyStakers(ref value) => {
                        ::prost::encoding::message::encoded_len(11u32, &*value)
                    }
                    Response::FileGetContents(ref value) => {
                        ::prost::encoding::message::encoded_len(12u32, &*value)
                    }
                    Response::FileGetInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(13u32, &*value)
                    }
                    Response::TransactionGetReceipt(ref value) => {
                        ::prost::encoding::message::encoded_len(14u32, &*value)
                    }
                    Response::TransactionGetRecord(ref value) => {
                        ::prost::encoding::message::encoded_len(15u32, &*value)
                    }
                    Response::TransactionGetFastRecord(ref value) => {
                        ::prost::encoding::message::encoded_len(16u32, &*value)
                    }
                    Response::ConsensusGetTopicInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(150u32, &*value)
                    }
                    Response::NetworkGetVersionInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(151u32, &*value)
                    }
                    Response::TokenGetInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(152u32, &*value)
                    }
                    Response::ScheduleGetInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(153u32, &*value)
                    }
                    Response::TokenGetAccountNftInfos(ref value) => {
                        ::prost::encoding::message::encoded_len(154u32, &*value)
                    }
                    Response::TokenGetNftInfo(ref value) => {
                        ::prost::encoding::message::encoded_len(155u32, &*value)
                    }
                    Response::TokenGetNftInfos(ref value) => {
                        ::prost::encoding::message::encoded_len(156u32, &*value)
                    }
                    Response::NetworkGetExecutionTime(ref value) => {
                        ::prost::encoding::message::encoded_len(157u32, &*value)
                    }
                    Response::AccountDetails(ref value) => {
                        ::prost::encoding::message::encoded_len(158u32, &*value)
                    }
                }
            }
        }
        impl ::core::fmt::Debug for Response {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Response::GetByKey(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("GetByKey").field(&wrapper).finish()
                    }
                    Response::GetBySolidityId(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("GetBySolidityId").field(&wrapper).finish()
                    }
                    Response::ContractCallLocal(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractCallLocal").field(&wrapper).finish()
                    }
                    Response::ContractGetBytecodeResponse(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractGetBytecodeResponse")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::ContractGetInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractGetInfo").field(&wrapper).finish()
                    }
                    Response::ContractGetRecordsResponse(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ContractGetRecordsResponse")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::CryptogetAccountBalance(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptogetAccountBalance")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::CryptoGetAccountRecords(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoGetAccountRecords")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::CryptoGetInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoGetInfo").field(&wrapper).finish()
                    }
                    Response::CryptoGetLiveHash(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoGetLiveHash").field(&wrapper).finish()
                    }
                    Response::CryptoGetProxyStakers(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("CryptoGetProxyStakers")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::FileGetContents(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileGetContents").field(&wrapper).finish()
                    }
                    Response::FileGetInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("FileGetInfo").field(&wrapper).finish()
                    }
                    Response::TransactionGetReceipt(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TransactionGetReceipt")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::TransactionGetRecord(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TransactionGetRecord")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::TransactionGetFastRecord(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TransactionGetFastRecord")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::ConsensusGetTopicInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ConsensusGetTopicInfo")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::NetworkGetVersionInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("NetworkGetVersionInfo")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::TokenGetInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenGetInfo").field(&wrapper).finish()
                    }
                    Response::ScheduleGetInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("ScheduleGetInfo").field(&wrapper).finish()
                    }
                    Response::TokenGetAccountNftInfos(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenGetAccountNftInfos")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::TokenGetNftInfo(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenGetNftInfo").field(&wrapper).finish()
                    }
                    Response::TokenGetNftInfos(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("TokenGetNftInfos").field(&wrapper).finish()
                    }
                    Response::NetworkGetExecutionTime(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("NetworkGetExecutionTime")
                            .field(&wrapper)
                            .finish()
                    }
                    Response::AccountDetails(ref value) => {
                        let wrapper = &*value;
                        f.debug_tuple("AccountDetails").field(&wrapper).finish()
                    }
                }
            }
        }
    }
    /// Generated client implementations.
    pub mod consensus_service_client {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
        use tonic::codegen::*;
        /// The Consensus Service provides the ability for Hedera Hashgraph to provide aBFT consensus as to
        /// the order and validity of messages submitted to a *topic*, as well as a *consensus timestamp* for
        /// those messages.
        ///
        /// Automatic renewal can be configured via an autoRenewAccount.
        /// Any time an autoRenewAccount is added to a topic, that createTopic/updateTopic transaction must
        /// be signed by the autoRenewAccount.
        ///
        /// The autoRenewPeriod on an account must currently be set a value in createTopic between
        /// MIN_AUTORENEW_PERIOD (6999999 seconds) and MAX_AUTORENEW_PERIOD (8000001 seconds). During
        /// creation this sets the initial expirationTime of the topic (see more below).
        ///
        /// If no adminKey is on a topic, there may not be an autoRenewAccount on the topic, deleteTopic is
        /// not allowed, and the only change allowed via an updateTopic is to extend the expirationTime.
        ///
        /// If an adminKey is on a topic, every updateTopic and deleteTopic transaction must be signed by the
        /// adminKey, except for updateTopics which only extend the topic's expirationTime (no adminKey
        /// authorization required).
        ///
        /// If an updateTopic modifies the adminKey of a topic, the transaction signatures on the updateTopic
        /// must fulfill both the pre-update and post-update adminKey signature requirements.
        ///
        /// Mirrornet ConsensusService may be used to subscribe to changes on the topic, including changes to
        /// the topic definition and the consensus ordering and timestamp of submitted messages.
        ///
        /// Until autoRenew functionality is supported by HAPI, the topic will not expire, the
        /// autoRenewAccount will not be charged, and the topic will not automatically be deleted.
        ///
        /// Once autoRenew functionality is supported by HAPI:
        ///
        /// 1. Once the expirationTime is encountered, if an autoRenewAccount is configured on the topic, the
        /// account will be charged automatically at the expirationTime, to extend the expirationTime of the
        /// topic up to the topic's autoRenewPeriod (or as much extension as the account's balance will
        /// supply).
        ///
        /// 2. If the topic expires and is not automatically renewed, the topic will enter the EXPIRED state.
        /// All transactions on the topic will fail with TOPIC_EXPIRED, except an updateTopic() call that
        /// modifies only the expirationTime.  getTopicInfo() will succeed. This state will be available for
        /// a AUTORENEW_GRACE_PERIOD grace period (7 days).
        ///
        /// 3. After the grace period, if the topic's expirationTime is not extended, the topic will be
        /// automatically deleted and no transactions or queries on the topic will succeed after that point.
        pub struct ConsensusServiceClient<T> {
            inner: tonic::client::Grpc<T>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for ConsensusServiceClient<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ConsensusServiceClient {
                        inner: ref __self_0_0,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "ConsensusServiceClient");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "inner",
                            &&(*__self_0_0),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for ConsensusServiceClient<T> {
            #[inline]
            fn clone(&self) -> ConsensusServiceClient<T> {
                match *self {
                    ConsensusServiceClient {
                        inner: ref __self_0_0,
                    } => ConsensusServiceClient {
                        inner: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        impl ConsensusServiceClient<tonic::transport::Channel> {
            /// Attempt to create a new client by connecting to a given endpoint.
            pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
            where
                D: std::convert::TryInto<tonic::transport::Endpoint>,
                D::Error: Into<StdError>,
            {
                let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
                Ok(Self::new(conn))
            }
        }
        impl<T> ConsensusServiceClient<T>
        where
            T: tonic::client::GrpcService<tonic::body::BoxBody>,
            T::Error: Into<StdError>,
            T::ResponseBody: Body<Data = Bytes> + Send + 'static,
            <T::ResponseBody as Body>::Error: Into<StdError> + Send,
        {
            pub fn new(inner: T) -> Self {
                let inner = tonic::client::Grpc::new(inner);
                Self { inner }
            }
            pub fn with_interceptor<F>(
                inner: T,
                interceptor: F,
            ) -> ConsensusServiceClient<InterceptedService<T, F>>
            where
                F: tonic::service::Interceptor,
                T::ResponseBody: Default,
                T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
                <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                    Into<StdError> + Send + Sync,
            {
                ConsensusServiceClient::new(InterceptedService::new(inner, interceptor))
            }
            /// Compress requests with `gzip`.
            ///
            /// This requires the server to support it otherwise it might respond with an
            /// error.
            #[must_use]
            pub fn send_gzip(mut self) -> Self {
                self.inner = self.inner.send_gzip();
                self
            }
            /// Enable decompressing responses with `gzip`.
            #[must_use]
            pub fn accept_gzip(mut self) -> Self {
                self.inner = self.inner.accept_gzip();
                self
            }
            /// Create a topic to be used for consensus.
            /// If an autoRenewAccount is specified, that account must also sign this transaction.
            /// If an adminKey is specified, the adminKey must sign the transaction.
            /// On success, the resulting TransactionReceipt contains the newly created TopicId.
            /// Request is [ConsensusCreateTopicTransactionBody](#proto.ConsensusCreateTopicTransactionBody)
            pub async fn create_topic(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.ConsensusService/createTopic");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Update a topic.
            /// If there is no adminKey, the only authorized update (available to anyone) is to extend the expirationTime.
            /// Otherwise transaction must be signed by the adminKey.
            /// If an adminKey is updated, the transaction must be signed by the pre-update adminKey and post-update adminKey.
            /// If a new autoRenewAccount is specified (not just being removed), that account must also sign the transaction.
            /// Request is [ConsensusUpdateTopicTransactionBody](#proto.ConsensusUpdateTopicTransactionBody)
            pub async fn update_topic(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.ConsensusService/updateTopic");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Delete a topic. No more transactions or queries on the topic (via HAPI) will succeed.
            /// If an adminKey is set, this transaction must be signed by that key.
            /// If there is no adminKey, this transaction will fail UNAUTHORIZED.
            /// Request is [ConsensusDeleteTopicTransactionBody](#proto.ConsensusDeleteTopicTransactionBody)
            pub async fn delete_topic(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.ConsensusService/deleteTopic");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieve the latest state of a topic. This method is unrestricted and allowed on any topic by any payer account.
            /// Deleted accounts will not be returned.
            /// Request is [ConsensusGetTopicInfoQuery](#proto.ConsensusGetTopicInfoQuery)
            /// Response is [ConsensusGetTopicInfoResponse](#proto.ConsensusGetTopicInfoResponse)
            pub async fn get_topic_info(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.ConsensusService/getTopicInfo");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Submit a message for consensus.
            /// Valid and authorized messages on valid topics will be ordered by the consensus service, gossipped to the
            /// mirror net, and published (in order) to all subscribers (from the mirror net) on this topic.
            /// The submitKey (if any) must sign this transaction.
            /// On success, the resulting TransactionReceipt contains the topic's updated topicSequenceNumber and
            /// topicRunningHash.
            /// Request is [ConsensusSubmitMessageTransactionBody](#proto.ConsensusSubmitMessageTransactionBody)
            pub async fn submit_message(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.ConsensusService/submitMessage");
                self.inner.unary(request.into_request(), path, codec).await
            }
        }
    }
    /// Generated client implementations.
    pub mod smart_contract_service_client {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
        use tonic::codegen::*;
        /// Transactions and queries for the file service.
        pub struct SmartContractServiceClient<T> {
            inner: tonic::client::Grpc<T>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for SmartContractServiceClient<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    SmartContractServiceClient {
                        inner: ref __self_0_0,
                    } => {
                        let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(
                            f,
                            "SmartContractServiceClient",
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "inner",
                            &&(*__self_0_0),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for SmartContractServiceClient<T> {
            #[inline]
            fn clone(&self) -> SmartContractServiceClient<T> {
                match *self {
                    SmartContractServiceClient {
                        inner: ref __self_0_0,
                    } => SmartContractServiceClient {
                        inner: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        impl SmartContractServiceClient<tonic::transport::Channel> {
            /// Attempt to create a new client by connecting to a given endpoint.
            pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
            where
                D: std::convert::TryInto<tonic::transport::Endpoint>,
                D::Error: Into<StdError>,
            {
                let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
                Ok(Self::new(conn))
            }
        }
        impl<T> SmartContractServiceClient<T>
        where
            T: tonic::client::GrpcService<tonic::body::BoxBody>,
            T::Error: Into<StdError>,
            T::ResponseBody: Body<Data = Bytes> + Send + 'static,
            <T::ResponseBody as Body>::Error: Into<StdError> + Send,
        {
            pub fn new(inner: T) -> Self {
                let inner = tonic::client::Grpc::new(inner);
                Self { inner }
            }
            pub fn with_interceptor<F>(
                inner: T,
                interceptor: F,
            ) -> SmartContractServiceClient<InterceptedService<T, F>>
            where
                F: tonic::service::Interceptor,
                T::ResponseBody: Default,
                T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
                <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                    Into<StdError> + Send + Sync,
            {
                SmartContractServiceClient::new(InterceptedService::new(inner, interceptor))
            }
            /// Compress requests with `gzip`.
            ///
            /// This requires the server to support it otherwise it might respond with an
            /// error.
            #[must_use]
            pub fn send_gzip(mut self) -> Self {
                self.inner = self.inner.send_gzip();
                self
            }
            /// Enable decompressing responses with `gzip`.
            #[must_use]
            pub fn accept_gzip(mut self) -> Self {
                self.inner = self.inner.accept_gzip();
                self
            }
            /// Creates a contract
            pub async fn create_contract(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/createContract",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Updates a contract with the content
            pub async fn update_contract(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/updateContract",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Calls a contract
            pub async fn contract_call_method(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/contractCallMethod",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the contract information
            pub async fn get_contract_info(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/getContractInfo",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Calls a smart contract to be run on a single node
            pub async fn contract_call_local_method(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/contractCallLocalMethod",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the runtime code of a contract
            pub async fn contract_get_bytecode(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/ContractGetBytecode",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves a contract by its Solidity address
            pub async fn get_by_solidity_id(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/getBySolidityID",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Always returns an empty record list, as contract accounts are never effective payers for
            /// transactions
            pub async fn get_tx_record_by_contract_id(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/getTxRecordByContractID",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Deletes a contract instance and transfers any remaining hbars to a specified receiver
            pub async fn delete_contract(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/deleteContract",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Deletes a contract if the submitting account has network admin privileges
            pub async fn system_delete(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/systemDelete",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Undeletes a contract if the submitting account has network admin privileges
            pub async fn system_undelete(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/systemUndelete",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Ethereum transaction
            pub async fn call_ethereum(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.SmartContractService/callEthereum",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
        }
    }
    /// Generated client implementations.
    pub mod schedule_service_client {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
        use tonic::codegen::*;
        /// Transactions and queries for the Schedule Service
        ///
        /// The Schedule Service allows transactions to be submitted without all the required signatures and
        /// allows anyone to provide the required signatures independently after a transaction has already
        /// been created. The transactions can be executed immediately when all required signatures are received
        /// or at a future date if Long Term Scheduled Transactions are enabled.
        ///
        /// Execution:
        ///
        /// Scheduled Transactions are executed in two different modes.
        ///
        /// 1. If Long Term Scheduled Transactions are enabled and <tt>wait_for_expiry</tt> was set to <tt>true</tt> on the
        ///    <tt>ScheduleCreate</tt>, then the transaction will be executed at the <tt>expiration_time</tt> specified on the
        ///    <tt>ScheduleCreate</tt>.
        ///
        /// 2. Otherwise Scheduled Transactions are executed once all required signatures are collected and witnessed.
        ///    Every time new signature is provided, a check is performed on the "readiness" of the execution.
        ///    The Scheduled Transaction will be executed immediately after the transaction that triggered it.
        ///
        /// NOTICE:
        /// A Scheduled Transaction being ready to execute, or even not ready to execute, at the time a <tt>ScheduleCreate</tt> or
        /// <tt>ScheduleSign</tt> comes in does not guarantee it will stay that way. Any number of things can happen over time that
        /// impact the transaction.
        ///
        /// For example, account keys can change, accounts can be deleted, and account balances can change.
        ///
        /// A particularly noteworthy case is if Long Term Scheduled Transactions are enabled and signature requirements for a Scheduled
        /// Transaction change such that existing signatures become sufficient to allow the transaction to go through. In this case the transaction
        /// will execute at expiration_time unless a ScheduleSign comes in to push it through.
        ///
        /// Transaction Record:
        ///
        /// If a Scheduled Transaction is executed immediately following the transaction that provided all required signatures,
        /// the timestamp of the Scheduled Transaction will be equal to consensusTimestamp + 1 nano, where
        /// consensusTimestamp is the timestamp of the transaction that triggered the execution.
        ///
        /// The Transaction ID of the Scheduled Transaction will have the scheduled property set to true and
        /// inherit the <tt>transactionValidStart</tt> and <tt>accountID</tt> from the <tt>ScheduleCreate</tt> transaction.
        ///
        /// The <tt>scheduleRef</tt> property of the transaction record will be populated with the <tt>ScheduleID</tt> of the
        /// Scheduled Transaction.
        ///
        /// Post execution:
        ///
        /// After execution, a Scheduled Transaction will remain in state and can be queried using <tt>GetScheduleInfo</tt> until expiration.
        ///
        /// Expiry:
        ///
        /// The expiration time of a schedule is controlled by it's <tt>expiration_time</tt>. If Long Term Scheduled Transactions are disabled,
        /// the <tt>expiration_time</tt> is always 30 minutes in the future.
        ///
        /// Once a given Scheduled Transaction expires, it will be removed from the ledger and any upcoming
        /// operation referring the ScheduleID will resolve to INVALID_SCHEDULE_ID.
        ///
        pub struct ScheduleServiceClient<T> {
            inner: tonic::client::Grpc<T>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for ScheduleServiceClient<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ScheduleServiceClient {
                        inner: ref __self_0_0,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "ScheduleServiceClient");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "inner",
                            &&(*__self_0_0),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for ScheduleServiceClient<T> {
            #[inline]
            fn clone(&self) -> ScheduleServiceClient<T> {
                match *self {
                    ScheduleServiceClient {
                        inner: ref __self_0_0,
                    } => ScheduleServiceClient {
                        inner: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        impl ScheduleServiceClient<tonic::transport::Channel> {
            /// Attempt to create a new client by connecting to a given endpoint.
            pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
            where
                D: std::convert::TryInto<tonic::transport::Endpoint>,
                D::Error: Into<StdError>,
            {
                let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
                Ok(Self::new(conn))
            }
        }
        impl<T> ScheduleServiceClient<T>
        where
            T: tonic::client::GrpcService<tonic::body::BoxBody>,
            T::Error: Into<StdError>,
            T::ResponseBody: Body<Data = Bytes> + Send + 'static,
            <T::ResponseBody as Body>::Error: Into<StdError> + Send,
        {
            pub fn new(inner: T) -> Self {
                let inner = tonic::client::Grpc::new(inner);
                Self { inner }
            }
            pub fn with_interceptor<F>(
                inner: T,
                interceptor: F,
            ) -> ScheduleServiceClient<InterceptedService<T, F>>
            where
                F: tonic::service::Interceptor,
                T::ResponseBody: Default,
                T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
                <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                    Into<StdError> + Send + Sync,
            {
                ScheduleServiceClient::new(InterceptedService::new(inner, interceptor))
            }
            /// Compress requests with `gzip`.
            ///
            /// This requires the server to support it otherwise it might respond with an
            /// error.
            #[must_use]
            pub fn send_gzip(mut self) -> Self {
                self.inner = self.inner.send_gzip();
                self
            }
            /// Enable decompressing responses with `gzip`.
            #[must_use]
            pub fn accept_gzip(mut self) -> Self {
                self.inner = self.inner.accept_gzip();
                self
            }
            /// Creates a new Schedule by submitting the transaction
            pub async fn create_schedule(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.ScheduleService/createSchedule");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Signs a new Schedule by submitting the transaction
            pub async fn sign_schedule(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.ScheduleService/signSchedule");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Deletes a new Schedule by submitting the transaction
            pub async fn delete_schedule(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.ScheduleService/deleteSchedule");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the metadata of a schedule entity
            pub async fn get_schedule_info(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.ScheduleService/getScheduleInfo");
                self.inner.unary(request.into_request(), path, codec).await
            }
        }
    }
    /// A set of operations which should be collectively throttled at a given milli-ops-per-second limit.
    pub struct ThrottleGroup {
        /// The operations to be throttled
        #[prost(enumeration = "HederaFunctionality", repeated, tag = "1")]
        pub operations: ::prost::alloc::vec::Vec<i32>,
        /// The number of total operations per second across the entire network, multiplied by 1000. So, to
        /// choose 3 operations per second (which on a network of 30 nodes is a tenth of an operation per
        /// second for each node), set milliOpsPerSec = 3000. And to choose 3.6 ops per second, use
        /// milliOpsPerSec = 3600. Minimum allowed value is 1, and maximum allowed value is 9223372.
        #[prost(uint64, tag = "2")]
        pub milli_ops_per_sec: u64,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ThrottleGroup {
        #[inline]
        fn clone(&self) -> ThrottleGroup {
            match *self {
                ThrottleGroup {
                    operations: ref __self_0_0,
                    milli_ops_per_sec: ref __self_0_1,
                } => ThrottleGroup {
                    operations: ::core::clone::Clone::clone(&(*__self_0_0)),
                    milli_ops_per_sec: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ThrottleGroup {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ThrottleGroup {
        #[inline]
        fn eq(&self, other: &ThrottleGroup) -> bool {
            match *other {
                ThrottleGroup {
                    operations: ref __self_1_0,
                    milli_ops_per_sec: ref __self_1_1,
                } => match *self {
                    ThrottleGroup {
                        operations: ref __self_0_0,
                        milli_ops_per_sec: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ThrottleGroup) -> bool {
            match *other {
                ThrottleGroup {
                    operations: ref __self_1_0,
                    milli_ops_per_sec: ref __self_1_1,
                } => match *self {
                    ThrottleGroup {
                        operations: ref __self_0_0,
                        milli_ops_per_sec: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for ThrottleGroup {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            ::prost::encoding::int32::encode_packed(1u32, &self.operations, buf);
            if self.milli_ops_per_sec != 0u64 {
                ::prost::encoding::uint64::encode(2u32, &self.milli_ops_per_sec, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ThrottleGroup";
            match tag {
                1u32 => {
                    let mut value = &mut self.operations;
                    ::prost::encoding::int32::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "operations");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.milli_ops_per_sec;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "milli_ops_per_sec");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::int32::encoded_len_packed(1u32, &self.operations)
                + if self.milli_ops_per_sec != 0u64 {
                    ::prost::encoding::uint64::encoded_len(2u32, &self.milli_ops_per_sec)
                } else {
                    0
                }
        }
        fn clear(&mut self) {
            self.operations.clear();
            self.milli_ops_per_sec = 0u64;
        }
    }
    impl ::core::default::Default for ThrottleGroup {
        fn default() -> Self {
            ThrottleGroup {
                operations: ::prost::alloc::vec::Vec::new(),
                milli_ops_per_sec: 0u64,
            }
        }
    }
    impl ::core::fmt::Debug for ThrottleGroup {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ThrottleGroup");
            let builder = {
                let wrapper = {
                    struct ScalarWrapper<'a>(&'a ::prost::alloc::vec::Vec<i32>);
                    impl<'a> ::core::fmt::Debug for ScalarWrapper<'a> {
                        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                            let mut vec_builder = f.debug_list();
                            for v in self.0 {
                                struct Inner<'a>(&'a i32);
                                impl<'a> ::core::fmt::Debug for Inner<'a> {
                                    fn fmt(
                                        &self,
                                        f: &mut ::core::fmt::Formatter,
                                    ) -> ::core::fmt::Result {
                                        match HederaFunctionality::from_i32(*self.0) {
                                            None => ::core::fmt::Debug::fmt(&self.0, f),
                                            Some(en) => ::core::fmt::Debug::fmt(&en, f),
                                        }
                                    }
                                }
                                vec_builder.entry(&Inner(v));
                            }
                            vec_builder.finish()
                        }
                    }
                    ScalarWrapper(&self.operations)
                };
                builder.field("operations", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.milli_ops_per_sec)
                };
                builder.field("milli_ops_per_sec", &wrapper)
            };
            builder.finish()
        }
    }
    #[allow(dead_code)]
    impl ThrottleGroup {
        ///Returns an iterator which yields the valid enum values contained in `operations`.
        pub fn operations(
            &self,
        ) -> ::core::iter::FilterMap<
            ::core::iter::Cloned<::core::slice::Iter<i32>>,
            fn(i32) -> ::core::option::Option<HederaFunctionality>,
        > {
            self.operations
                .iter()
                .cloned()
                .filter_map(HederaFunctionality::from_i32)
        }
        ///Appends the provided enum value to `operations`.
        pub fn push_operations(&mut self, value: HederaFunctionality) {
            self.operations.push(value as i32);
        }
    }
    /// A list of throttle groups that should all compete for the same internal bucket.
    pub struct ThrottleBucket {
        /// A name for this bucket (primarily for use in logs)
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The number of milliseconds required for this bucket to drain completely when full. The product
        /// of this number and the least common multiple of the milliOpsPerSec values in this bucket must
        /// not exceed 9223372036.
        #[prost(uint64, tag = "2")]
        pub burst_period_ms: u64,
        /// The throttle groups competing for this bucket
        #[prost(message, repeated, tag = "3")]
        pub throttle_groups: ::prost::alloc::vec::Vec<ThrottleGroup>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ThrottleBucket {
        #[inline]
        fn clone(&self) -> ThrottleBucket {
            match *self {
                ThrottleBucket {
                    name: ref __self_0_0,
                    burst_period_ms: ref __self_0_1,
                    throttle_groups: ref __self_0_2,
                } => ThrottleBucket {
                    name: ::core::clone::Clone::clone(&(*__self_0_0)),
                    burst_period_ms: ::core::clone::Clone::clone(&(*__self_0_1)),
                    throttle_groups: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ThrottleBucket {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ThrottleBucket {
        #[inline]
        fn eq(&self, other: &ThrottleBucket) -> bool {
            match *other {
                ThrottleBucket {
                    name: ref __self_1_0,
                    burst_period_ms: ref __self_1_1,
                    throttle_groups: ref __self_1_2,
                } => match *self {
                    ThrottleBucket {
                        name: ref __self_0_0,
                        burst_period_ms: ref __self_0_1,
                        throttle_groups: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ThrottleBucket) -> bool {
            match *other {
                ThrottleBucket {
                    name: ref __self_1_0,
                    burst_period_ms: ref __self_1_1,
                    throttle_groups: ref __self_1_2,
                } => match *self {
                    ThrottleBucket {
                        name: ref __self_0_0,
                        burst_period_ms: ref __self_0_1,
                        throttle_groups: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::prost::Message for ThrottleBucket {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.name != "" {
                ::prost::encoding::string::encode(1u32, &self.name, buf);
            }
            if self.burst_period_ms != 0u64 {
                ::prost::encoding::uint64::encode(2u32, &self.burst_period_ms, buf);
            }
            for msg in &self.throttle_groups {
                ::prost::encoding::message::encode(3u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ThrottleBucket";
            match tag {
                1u32 => {
                    let mut value = &mut self.name;
                    ::prost::encoding::string::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "name");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.burst_period_ms;
                    ::prost::encoding::uint64::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "burst_period_ms");
                            error
                        },
                    )
                }
                3u32 => {
                    let mut value = &mut self.throttle_groups;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "throttle_groups");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.name != "" {
                ::prost::encoding::string::encoded_len(1u32, &self.name)
            } else {
                0
            } + if self.burst_period_ms != 0u64 {
                ::prost::encoding::uint64::encoded_len(2u32, &self.burst_period_ms)
            } else {
                0
            } + ::prost::encoding::message::encoded_len_repeated(3u32, &self.throttle_groups)
        }
        fn clear(&mut self) {
            self.name.clear();
            self.burst_period_ms = 0u64;
            self.throttle_groups.clear();
        }
    }
    impl ::core::default::Default for ThrottleBucket {
        fn default() -> Self {
            ThrottleBucket {
                name: ::prost::alloc::string::String::new(),
                burst_period_ms: 0u64,
                throttle_groups: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ThrottleBucket {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ThrottleBucket");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.name)
                };
                builder.field("name", &wrapper)
            };
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.burst_period_ms)
                };
                builder.field("burst_period_ms", &wrapper)
            };
            let builder = {
                let wrapper = &self.throttle_groups;
                builder.field("throttle_groups", &wrapper)
            };
            builder.finish()
        }
    }
    /// A list of throttle buckets which, simultaneously enforced, define the system's throttling policy.
    /// <ol>
    /// <li> When an operation appears in more than one throttling bucket, all its buckets must have room
    /// or it will be throttled.</li>
    /// <li>An operation assigned to no buckets is always throttled.</li>
    /// </ol>
    pub struct ThrottleDefinitions {
        #[prost(message, repeated, tag = "1")]
        pub throttle_buckets: ::prost::alloc::vec::Vec<ThrottleBucket>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ThrottleDefinitions {
        #[inline]
        fn clone(&self) -> ThrottleDefinitions {
            match *self {
                ThrottleDefinitions {
                    throttle_buckets: ref __self_0_0,
                } => ThrottleDefinitions {
                    throttle_buckets: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ThrottleDefinitions {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ThrottleDefinitions {
        #[inline]
        fn eq(&self, other: &ThrottleDefinitions) -> bool {
            match *other {
                ThrottleDefinitions {
                    throttle_buckets: ref __self_1_0,
                } => match *self {
                    ThrottleDefinitions {
                        throttle_buckets: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ThrottleDefinitions) -> bool {
            match *other {
                ThrottleDefinitions {
                    throttle_buckets: ref __self_1_0,
                } => match *self {
                    ThrottleDefinitions {
                        throttle_buckets: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::prost::Message for ThrottleDefinitions {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            for msg in &self.throttle_buckets {
                ::prost::encoding::message::encode(1u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "ThrottleDefinitions";
            match tag {
                1u32 => {
                    let mut value = &mut self.throttle_buckets;
                    ::prost::encoding::message::merge_repeated(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "throttle_buckets");
                            error
                        },
                    )
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + ::prost::encoding::message::encoded_len_repeated(1u32, &self.throttle_buckets)
        }
        fn clear(&mut self) {
            self.throttle_buckets.clear();
        }
    }
    impl ::core::default::Default for ThrottleDefinitions {
        fn default() -> Self {
            ThrottleDefinitions {
                throttle_buckets: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for ThrottleDefinitions {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("ThrottleDefinitions");
            let builder = {
                let wrapper = &self.throttle_buckets;
                builder.field("throttle_buckets", &wrapper)
            };
            builder.finish()
        }
    }
    /// Generated client implementations.
    pub mod network_service_client {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
        use tonic::codegen::*;
        /// The requests and responses for different network services.
        pub struct NetworkServiceClient<T> {
            inner: tonic::client::Grpc<T>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for NetworkServiceClient<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    NetworkServiceClient {
                        inner: ref __self_0_0,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "NetworkServiceClient");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "inner",
                            &&(*__self_0_0),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for NetworkServiceClient<T> {
            #[inline]
            fn clone(&self) -> NetworkServiceClient<T> {
                match *self {
                    NetworkServiceClient {
                        inner: ref __self_0_0,
                    } => NetworkServiceClient {
                        inner: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        impl NetworkServiceClient<tonic::transport::Channel> {
            /// Attempt to create a new client by connecting to a given endpoint.
            pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
            where
                D: std::convert::TryInto<tonic::transport::Endpoint>,
                D::Error: Into<StdError>,
            {
                let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
                Ok(Self::new(conn))
            }
        }
        impl<T> NetworkServiceClient<T>
        where
            T: tonic::client::GrpcService<tonic::body::BoxBody>,
            T::Error: Into<StdError>,
            T::ResponseBody: Body<Data = Bytes> + Send + 'static,
            <T::ResponseBody as Body>::Error: Into<StdError> + Send,
        {
            pub fn new(inner: T) -> Self {
                let inner = tonic::client::Grpc::new(inner);
                Self { inner }
            }
            pub fn with_interceptor<F>(
                inner: T,
                interceptor: F,
            ) -> NetworkServiceClient<InterceptedService<T, F>>
            where
                F: tonic::service::Interceptor,
                T::ResponseBody: Default,
                T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
                <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                    Into<StdError> + Send + Sync,
            {
                NetworkServiceClient::new(InterceptedService::new(inner, interceptor))
            }
            /// Compress requests with `gzip`.
            ///
            /// This requires the server to support it otherwise it might respond with an
            /// error.
            #[must_use]
            pub fn send_gzip(mut self) -> Self {
                self.inner = self.inner.send_gzip();
                self
            }
            /// Enable decompressing responses with `gzip`.
            #[must_use]
            pub fn accept_gzip(mut self) -> Self {
                self.inner = self.inner.accept_gzip();
                self
            }
            /// Retrieves the active versions of Hedera Services and HAPI proto
            pub async fn get_version_info(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.NetworkService/getVersionInfo");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the time in nanoseconds spent in <tt>handleTransaction</tt> for one or more
            /// TransactionIDs (assuming they have reached consensus "recently", since only a limited
            /// number of execution times are kept in-memory, depending on the value of the node-local
            /// property <tt>stats.executionTimesToTrack</tt>).
            pub async fn get_execution_time(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.NetworkService/getExecutionTime");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Submits a "wrapped" transaction to the network, skipping its standard prechecks. (Note that
            /// the "wrapper" <tt>UncheckedSubmit</tt> transaction is still subject to normal prechecks,
            /// including an authorization requirement that its payer be either the treasury or system admin
            /// account.)
            pub async fn unchecked_submit(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.NetworkService/uncheckedSubmit");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Get all the information about an account, including balance and allowances. This does not get the list of
            /// account records.
            pub async fn get_account_details(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.NetworkService/getAccountDetails");
                self.inner.unary(request.into_request(), path, codec).await
            }
        }
    }
    /// Generated client implementations.
    pub mod token_service_client {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
        use tonic::codegen::*;
        /// Transactions and queries for the Token Service
        pub struct TokenServiceClient<T> {
            inner: tonic::client::Grpc<T>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for TokenServiceClient<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    TokenServiceClient {
                        inner: ref __self_0_0,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "TokenServiceClient");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "inner",
                            &&(*__self_0_0),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for TokenServiceClient<T> {
            #[inline]
            fn clone(&self) -> TokenServiceClient<T> {
                match *self {
                    TokenServiceClient {
                        inner: ref __self_0_0,
                    } => TokenServiceClient {
                        inner: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        impl TokenServiceClient<tonic::transport::Channel> {
            /// Attempt to create a new client by connecting to a given endpoint.
            pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
            where
                D: std::convert::TryInto<tonic::transport::Endpoint>,
                D::Error: Into<StdError>,
            {
                let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
                Ok(Self::new(conn))
            }
        }
        impl<T> TokenServiceClient<T>
        where
            T: tonic::client::GrpcService<tonic::body::BoxBody>,
            T::Error: Into<StdError>,
            T::ResponseBody: Body<Data = Bytes> + Send + 'static,
            <T::ResponseBody as Body>::Error: Into<StdError> + Send,
        {
            pub fn new(inner: T) -> Self {
                let inner = tonic::client::Grpc::new(inner);
                Self { inner }
            }
            pub fn with_interceptor<F>(
                inner: T,
                interceptor: F,
            ) -> TokenServiceClient<InterceptedService<T, F>>
            where
                F: tonic::service::Interceptor,
                T::ResponseBody: Default,
                T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
                <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                    Into<StdError> + Send + Sync,
            {
                TokenServiceClient::new(InterceptedService::new(inner, interceptor))
            }
            /// Compress requests with `gzip`.
            ///
            /// This requires the server to support it otherwise it might respond with an
            /// error.
            #[must_use]
            pub fn send_gzip(mut self) -> Self {
                self.inner = self.inner.send_gzip();
                self
            }
            /// Enable decompressing responses with `gzip`.
            #[must_use]
            pub fn accept_gzip(mut self) -> Self {
                self.inner = self.inner.accept_gzip();
                self
            }
            /// Creates a new Token by submitting the transaction
            pub async fn create_token(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.TokenService/createToken");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Updates the account by submitting the transaction
            pub async fn update_token(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.TokenService/updateToken");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Mints an amount of the token to the defined treasury account
            pub async fn mint_token(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.TokenService/mintToken");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Burns an amount of the token from the defined treasury account
            pub async fn burn_token(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.TokenService/burnToken");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Deletes a Token
            pub async fn delete_token(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.TokenService/deleteToken");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Wipes the provided amount of tokens from the specified Account ID
            pub async fn wipe_token_account(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.TokenService/wipeTokenAccount");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Freezes the transfer of tokens to or from the specified Account ID
            pub async fn freeze_token_account(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.TokenService/freezeTokenAccount");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Unfreezes the transfer of tokens to or from the specified Account ID
            pub async fn unfreeze_token_account(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.TokenService/unfreezeTokenAccount",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Flags the provided Account ID as having gone through KYC
            pub async fn grant_kyc_to_token_account(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.TokenService/grantKycToTokenAccount",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Removes the KYC flag of the provided Account ID
            pub async fn revoke_kyc_from_token_account(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.TokenService/revokeKycFromTokenAccount",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Associates tokens to an account
            pub async fn associate_tokens(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.TokenService/associateTokens");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Dissociates tokens from an account
            pub async fn dissociate_tokens(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.TokenService/dissociateTokens");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Updates the custom fee schedule on a token
            pub async fn update_token_fee_schedule(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.TokenService/updateTokenFeeSchedule",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the metadata of a token
            pub async fn get_token_info(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.TokenService/getTokenInfo");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// (DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given account
            pub async fn get_account_nft_infos(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.TokenService/getAccountNftInfos");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the metadata of an NFT by TokenID and serial number
            pub async fn get_token_nft_info(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.TokenService/getTokenNftInfo");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// (DEPRECATED) Gets info on NFTs N through M on the list of NFTs associated with a given Token of type NON_FUNGIBLE
            pub async fn get_token_nft_infos(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.TokenService/getTokenNftInfos");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Pause the token
            pub async fn pause_token(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.TokenService/pauseToken");
                self.inner.unary(request.into_request(), path, codec).await
            }
            ///  Unpause the token
            pub async fn unpause_token(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.TokenService/unpauseToken");
                self.inner.unary(request.into_request(), path, codec).await
            }
        }
    }
    /// Generated client implementations.
    pub mod crypto_service_client {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
        use tonic::codegen::*;
        /// Transactions and queries for the Crypto Service
        pub struct CryptoServiceClient<T> {
            inner: tonic::client::Grpc<T>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for CryptoServiceClient<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    CryptoServiceClient {
                        inner: ref __self_0_0,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "CryptoServiceClient");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "inner",
                            &&(*__self_0_0),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for CryptoServiceClient<T> {
            #[inline]
            fn clone(&self) -> CryptoServiceClient<T> {
                match *self {
                    CryptoServiceClient {
                        inner: ref __self_0_0,
                    } => CryptoServiceClient {
                        inner: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        impl CryptoServiceClient<tonic::transport::Channel> {
            /// Attempt to create a new client by connecting to a given endpoint.
            pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
            where
                D: std::convert::TryInto<tonic::transport::Endpoint>,
                D::Error: Into<StdError>,
            {
                let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
                Ok(Self::new(conn))
            }
        }
        impl<T> CryptoServiceClient<T>
        where
            T: tonic::client::GrpcService<tonic::body::BoxBody>,
            T::Error: Into<StdError>,
            T::ResponseBody: Body<Data = Bytes> + Send + 'static,
            <T::ResponseBody as Body>::Error: Into<StdError> + Send,
        {
            pub fn new(inner: T) -> Self {
                let inner = tonic::client::Grpc::new(inner);
                Self { inner }
            }
            pub fn with_interceptor<F>(
                inner: T,
                interceptor: F,
            ) -> CryptoServiceClient<InterceptedService<T, F>>
            where
                F: tonic::service::Interceptor,
                T::ResponseBody: Default,
                T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
                <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                    Into<StdError> + Send + Sync,
            {
                CryptoServiceClient::new(InterceptedService::new(inner, interceptor))
            }
            /// Compress requests with `gzip`.
            ///
            /// This requires the server to support it otherwise it might respond with an
            /// error.
            #[must_use]
            pub fn send_gzip(mut self) -> Self {
                self.inner = self.inner.send_gzip();
                self
            }
            /// Enable decompressing responses with `gzip`.
            #[must_use]
            pub fn accept_gzip(mut self) -> Self {
                self.inner = self.inner.accept_gzip();
                self
            }
            /// Creates a new account by submitting the transaction
            pub async fn create_account(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.CryptoService/createAccount");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Updates an account by submitting the transaction
            pub async fn update_account(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.CryptoService/updateAccount");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Initiates a transfer by submitting the transaction
            pub async fn crypto_transfer(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.CryptoService/cryptoTransfer");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Deletes and account by submitting the transaction
            pub async fn crypto_delete(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.CryptoService/cryptoDelete");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Adds one or more approved allowances for spenders to transfer the paying account's hbar or tokens.
            pub async fn approve_allowances(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.CryptoService/approveAllowances");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Deletes one or more of the specific approved NFT serial numbers on an owner account.
            pub async fn delete_allowances(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.CryptoService/deleteAllowances");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// (NOT CURRENTLY SUPPORTED) Adds a livehash
            pub async fn add_live_hash(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.CryptoService/addLiveHash");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// (NOT CURRENTLY SUPPORTED) Deletes a livehash
            pub async fn delete_live_hash(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.CryptoService/deleteLiveHash");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// (NOT CURRENTLY SUPPORTED) Retrieves a livehash for an account
            pub async fn get_live_hash(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.CryptoService/getLiveHash");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Returns all transactions in the last 180s of consensus time for which the given account was
            /// the effective payer <b>and</b> network property <tt>ledger.keepRecordsInState</tt> was
            /// <tt>true</tt>.
            pub async fn get_account_records(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.CryptoService/getAccountRecords");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the balance of an account
            pub async fn crypto_get_balance(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.CryptoService/cryptoGetBalance");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the metadata of an account
            pub async fn get_account_info(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.CryptoService/getAccountInfo");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the latest receipt for a transaction that is either awaiting consensus, or reached
            /// consensus in the last 180 seconds
            pub async fn get_transaction_receipts(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.CryptoService/getTransactionReceipts",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// (NOT CURRENTLY SUPPORTED) Returns the records of transactions recently funded by an account
            pub async fn get_fast_transaction_record(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.CryptoService/getFastTransactionRecord",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the record of a transaction that is either awaiting consensus, or reached consensus
            /// in the last 180 seconds
            pub async fn get_tx_record_by_tx_id(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.CryptoService/getTxRecordByTxID");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// (NOT CURRENTLY SUPPORTED) Retrieves the stakers for a node by account id
            pub async fn get_stakers_by_account_id(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static(
                    "/proto.CryptoService/getStakersByAccountID",
                );
                self.inner.unary(request.into_request(), path, codec).await
            }
        }
    }
    /// Generated client implementations.
    pub mod freeze_service_client {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
        use tonic::codegen::*;
        /// The request and responses for freeze service.
        pub struct FreezeServiceClient<T> {
            inner: tonic::client::Grpc<T>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for FreezeServiceClient<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    FreezeServiceClient {
                        inner: ref __self_0_0,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "FreezeServiceClient");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "inner",
                            &&(*__self_0_0),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for FreezeServiceClient<T> {
            #[inline]
            fn clone(&self) -> FreezeServiceClient<T> {
                match *self {
                    FreezeServiceClient {
                        inner: ref __self_0_0,
                    } => FreezeServiceClient {
                        inner: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        impl FreezeServiceClient<tonic::transport::Channel> {
            /// Attempt to create a new client by connecting to a given endpoint.
            pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
            where
                D: std::convert::TryInto<tonic::transport::Endpoint>,
                D::Error: Into<StdError>,
            {
                let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
                Ok(Self::new(conn))
            }
        }
        impl<T> FreezeServiceClient<T>
        where
            T: tonic::client::GrpcService<tonic::body::BoxBody>,
            T::Error: Into<StdError>,
            T::ResponseBody: Body<Data = Bytes> + Send + 'static,
            <T::ResponseBody as Body>::Error: Into<StdError> + Send,
        {
            pub fn new(inner: T) -> Self {
                let inner = tonic::client::Grpc::new(inner);
                Self { inner }
            }
            pub fn with_interceptor<F>(
                inner: T,
                interceptor: F,
            ) -> FreezeServiceClient<InterceptedService<T, F>>
            where
                F: tonic::service::Interceptor,
                T::ResponseBody: Default,
                T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
                <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                    Into<StdError> + Send + Sync,
            {
                FreezeServiceClient::new(InterceptedService::new(inner, interceptor))
            }
            /// Compress requests with `gzip`.
            ///
            /// This requires the server to support it otherwise it might respond with an
            /// error.
            #[must_use]
            pub fn send_gzip(mut self) -> Self {
                self.inner = self.inner.send_gzip();
                self
            }
            /// Enable decompressing responses with `gzip`.
            #[must_use]
            pub fn accept_gzip(mut self) -> Self {
                self.inner = self.inner.accept_gzip();
                self
            }
            /// Freezes the nodes by submitting the transaction. The grpc server returns the
            /// TransactionResponse
            pub async fn freeze(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.FreezeService/freeze");
                self.inner.unary(request.into_request(), path, codec).await
            }
        }
    }
    /// Generated client implementations.
    pub mod file_service_client {
        #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
        use tonic::codegen::*;
        /// Transactions and queries for the file service.
        pub struct FileServiceClient<T> {
            inner: tonic::client::Grpc<T>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for FileServiceClient<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    FileServiceClient {
                        inner: ref __self_0_0,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "FileServiceClient");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "inner",
                            &&(*__self_0_0),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for FileServiceClient<T> {
            #[inline]
            fn clone(&self) -> FileServiceClient<T> {
                match *self {
                    FileServiceClient {
                        inner: ref __self_0_0,
                    } => FileServiceClient {
                        inner: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        impl FileServiceClient<tonic::transport::Channel> {
            /// Attempt to create a new client by connecting to a given endpoint.
            pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
            where
                D: std::convert::TryInto<tonic::transport::Endpoint>,
                D::Error: Into<StdError>,
            {
                let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
                Ok(Self::new(conn))
            }
        }
        impl<T> FileServiceClient<T>
        where
            T: tonic::client::GrpcService<tonic::body::BoxBody>,
            T::Error: Into<StdError>,
            T::ResponseBody: Body<Data = Bytes> + Send + 'static,
            <T::ResponseBody as Body>::Error: Into<StdError> + Send,
        {
            pub fn new(inner: T) -> Self {
                let inner = tonic::client::Grpc::new(inner);
                Self { inner }
            }
            pub fn with_interceptor<F>(
                inner: T,
                interceptor: F,
            ) -> FileServiceClient<InterceptedService<T, F>>
            where
                F: tonic::service::Interceptor,
                T::ResponseBody: Default,
                T: tonic::codegen::Service<
                    http::Request<tonic::body::BoxBody>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                    >,
                >,
                <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                    Into<StdError> + Send + Sync,
            {
                FileServiceClient::new(InterceptedService::new(inner, interceptor))
            }
            /// Compress requests with `gzip`.
            ///
            /// This requires the server to support it otherwise it might respond with an
            /// error.
            #[must_use]
            pub fn send_gzip(mut self) -> Self {
                self.inner = self.inner.send_gzip();
                self
            }
            /// Enable decompressing responses with `gzip`.
            #[must_use]
            pub fn accept_gzip(mut self) -> Self {
                self.inner = self.inner.accept_gzip();
                self
            }
            /// Creates a file
            pub async fn create_file(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.FileService/createFile");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Updates a file
            pub async fn update_file(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.FileService/updateFile");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Deletes a file
            pub async fn delete_file(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.FileService/deleteFile");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Appends to a file
            pub async fn append_content(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.FileService/appendContent");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the file contents
            pub async fn get_file_content(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.FileService/getFileContent");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Retrieves the file information
            pub async fn get_file_info(
                &mut self,
                request: impl tonic::IntoRequest<super::Query>,
            ) -> Result<tonic::Response<super::Response>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.FileService/getFileInfo");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Deletes a file if the submitting account has network admin privileges
            pub async fn system_delete(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path = http::uri::PathAndQuery::from_static("/proto.FileService/systemDelete");
                self.inner.unary(request.into_request(), path, codec).await
            }
            /// Undeletes a file if the submitting account has network admin privileges
            pub async fn system_undelete(
                &mut self,
                request: impl tonic::IntoRequest<super::Transaction>,
            ) -> Result<tonic::Response<super::TransactionResponse>, tonic::Status> {
                self.inner.ready().await.map_err(|e| {
                    tonic::Status::new(tonic::Code::Unknown, {
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &["Service was not ready: "],
                            &[::core::fmt::ArgumentV1::new_display(&e.into())],
                        ));
                        res
                    })
                })?;
                let codec = tonic::codec::ProstCodec::default();
                let path =
                    http::uri::PathAndQuery::from_static("/proto.FileService/systemUndelete");
                self.inner.unary(request.into_request(), path, codec).await
            }
        }
    }
    pub struct SignedTransaction {
        /// TransactionBody serialized into bytes, which needs to be signed
        #[prost(bytes = "vec", tag = "1")]
        pub body_bytes: ::prost::alloc::vec::Vec<u8>,
        /// The signatures on the body with the new format, to authorize the transaction
        #[prost(message, optional, tag = "2")]
        pub sig_map: ::core::option::Option<SignatureMap>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for SignedTransaction {
        #[inline]
        fn clone(&self) -> SignedTransaction {
            match *self {
                SignedTransaction {
                    body_bytes: ref __self_0_0,
                    sig_map: ref __self_0_1,
                } => SignedTransaction {
                    body_bytes: ::core::clone::Clone::clone(&(*__self_0_0)),
                    sig_map: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for SignedTransaction {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for SignedTransaction {
        #[inline]
        fn eq(&self, other: &SignedTransaction) -> bool {
            match *other {
                SignedTransaction {
                    body_bytes: ref __self_1_0,
                    sig_map: ref __self_1_1,
                } => match *self {
                    SignedTransaction {
                        body_bytes: ref __self_0_0,
                        sig_map: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &SignedTransaction) -> bool {
            match *other {
                SignedTransaction {
                    body_bytes: ref __self_1_0,
                    sig_map: ref __self_1_1,
                } => match *self {
                    SignedTransaction {
                        body_bytes: ref __self_0_0,
                        sig_map: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::prost::Message for SignedTransaction {
        #[allow(unused_variables)]
        fn encode_raw<B>(&self, buf: &mut B)
        where
            B: ::prost::bytes::BufMut,
        {
            if self.body_bytes != b"" as &[u8] {
                ::prost::encoding::bytes::encode(1u32, &self.body_bytes, buf);
            }
            if let Some(ref msg) = self.sig_map {
                ::prost::encoding::message::encode(2u32, msg, buf);
            }
        }
        #[allow(unused_variables)]
        fn merge_field<B>(
            &mut self,
            tag: u32,
            wire_type: ::prost::encoding::WireType,
            buf: &mut B,
            ctx: ::prost::encoding::DecodeContext,
        ) -> ::core::result::Result<(), ::prost::DecodeError>
        where
            B: ::prost::bytes::Buf,
        {
            const STRUCT_NAME: &'static str = "SignedTransaction";
            match tag {
                1u32 => {
                    let mut value = &mut self.body_bytes;
                    ::prost::encoding::bytes::merge(wire_type, value, buf, ctx).map_err(
                        |mut error| {
                            error.push(STRUCT_NAME, "body_bytes");
                            error
                        },
                    )
                }
                2u32 => {
                    let mut value = &mut self.sig_map;
                    ::prost::encoding::message::merge(
                        wire_type,
                        value.get_or_insert_with(::core::default::Default::default),
                        buf,
                        ctx,
                    )
                    .map_err(|mut error| {
                        error.push(STRUCT_NAME, "sig_map");
                        error
                    })
                }
                _ => ::prost::encoding::skip_field(wire_type, tag, buf, ctx),
            }
        }
        #[inline]
        fn encoded_len(&self) -> usize {
            0 + if self.body_bytes != b"" as &[u8] {
                ::prost::encoding::bytes::encoded_len(1u32, &self.body_bytes)
            } else {
                0
            } + self
                .sig_map
                .as_ref()
                .map_or(0, |msg| ::prost::encoding::message::encoded_len(2u32, msg))
        }
        fn clear(&mut self) {
            self.body_bytes.clear();
            self.sig_map = ::core::option::Option::None;
        }
    }
    impl ::core::default::Default for SignedTransaction {
        fn default() -> Self {
            SignedTransaction {
                body_bytes: ::core::default::Default::default(),
                sig_map: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::fmt::Debug for SignedTransaction {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let mut builder = f.debug_struct("SignedTransaction");
            let builder = {
                let wrapper = {
                    fn ScalarWrapper<T>(v: T) -> T {
                        v
                    }
                    ScalarWrapper(&self.body_bytes)
                };
                builder.field("body_bytes", &wrapper)
            };
            let builder = {
                let wrapper = &self.sig_map;
                builder.field("sig_map", &wrapper)
            };
            builder.finish()
        }
    }
}
